---
title: "Smart Contract Development"
description: "Build, test, and deploy smart contracts on Cosmos EVM with industry-standard tools"
icon: "code"
---

# Smart Contract Development

Cosmos EVM provides full compatibility with Ethereum smart contracts while offering unique access to Cosmos SDK functionality. Choose your preferred development stack and start building.

## Development Stacks

<div className="grid md:grid-cols-3 gap-6 my-8">
  <div className="p-6 border border-blue-200 dark:border-blue-800 rounded-lg bg-blue-50 dark:bg-blue-900/20">
    <div className="flex items-center mb-4">
      <div className="w-10 h-10 bg-blue-500 rounded-lg flex items-center justify-center mr-3">
        <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
        </svg>
      </div>
      <h3 className="text-lg font-semibold text-blue-900 dark:text-blue-100">Hardhat</h3>
    </div>
    <p className="text-blue-800 dark:text-blue-200 mb-4">
      The most popular Ethereum development environment with excellent tooling and plugin ecosystem.
    </p>
    <a href="/docs/cosmos-evm/smart-contracts/hardhat" className="text-blue-600 dark:text-blue-400 hover:underline text-sm font-medium">
      Learn Hardhat â†’
    </a>
  </div>
  
  <div className="p-6 border border-purple-200 dark:border-purple-800 rounded-lg bg-purple-50 dark:bg-purple-900/20">
    <div className="flex items-center mb-4">
      <div className="w-10 h-10 bg-purple-500 rounded-lg flex items-center justify-center mr-3">
        <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
        </svg>
      </div>
      <h3 className="text-lg font-semibold text-purple-900 dark:text-purple-100">Foundry</h3>
    </div>
    <p className="text-purple-800 dark:text-purple-200 mb-4">
      Fast, portable toolkit written in Rust with powerful testing capabilities and gas optimization.
    </p>
    <a href="/docs/cosmos-evm/smart-contracts/foundry" className="text-purple-600 dark:text-purple-400 hover:underline text-sm font-medium">
      Learn Foundry â†’
    </a>
  </div>
  
  <div className="p-6 border border-green-200 dark:border-green-800 rounded-lg bg-green-50 dark:bg-green-900/20">
    <div className="flex items-center mb-4">
      <div className="w-10 h-10 bg-green-500 rounded-lg flex items-center justify-center mr-3">
        <svg className="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9v-9m0-9v9m0 9a9 9 0 01-9-9m9 9c0 5-4 9-9 9s-9-4-9-9m9 9a9 9 0 019-9" />
        </svg>
      </div>
      <h3 className="text-lg font-semibold text-green-900 dark:text-green-100">Remix IDE</h3>
    </div>
    <p className="text-green-800 dark:text-green-200 mb-4">
      Browser-based IDE for quick prototyping and learning with zero setup required.
    </p>
    <a href="/docs/cosmos-evm/smart-contracts/remix" className="text-green-600 dark:text-green-400 hover:underline text-sm font-medium">
      Learn Remix â†’
    </a>
  </div>
</div>

## Smart Contract Types

### Standard ERC Contracts

Build with battle-tested OpenZeppelin implementations:

<CodeGroup>

```solidity ERC20 Token
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract CosmosToken is ERC20, Ownable {
    constructor(address initialOwner)
        ERC20("Cosmos Token", "ATOM")
        Ownable(initialOwner)
    {
        _mint(msg.sender, 1000000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
```

```solidity ERC721 NFT
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract CosmosNFT is ERC721, Ownable {
    uint256 private _nextTokenId;
    string private _baseTokenURI;

    constructor(address initialOwner, string memory baseURI)
        ERC721("Cosmos NFT", "CNFT")
        Ownable(initialOwner)
    {
        _baseTokenURI = baseURI;
    }

    function safeMint(address to) public onlyOwner {
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }
}
```

</CodeGroup>

### Cosmos-Enhanced Contracts

Leverage unique Cosmos EVM features:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract StakingRewardsToken is ERC20 {
    // Precompiled contract addresses
    address constant STAKING_PRECOMPILE = 0x0000000000000000000000000000000000000800;
    address constant DISTRIBUTION_PRECOMPILE = 0x0000000000000000000000000000000000000801;
    
    constructor() ERC20("Staking Rewards", "SREWARDS") {}
    
    function claimStakingRewards() external {
        // Call Cosmos SDK distribution module
        (bool success, bytes memory data) = DISTRIBUTION_PRECOMPILE.call(
            abi.encodeWithSignature("withdrawDelegatorReward(string)", "cosmosvaloper...")
        );
        require(success, "Failed to claim rewards");
        
        // Mint tokens based on claimed rewards
        uint256 rewardAmount = abi.decode(data, (uint256));
        _mint(msg.sender, rewardAmount);
    }
    
    function delegateToValidator(string memory validatorAddr, uint256 amount) external {
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        
        // Burn tokens and delegate via staking precompile
        _burn(msg.sender, amount);
        
        (bool success,) = STAKING_PRECOMPILE.call(
            abi.encodeWithSignature("delegate(string,uint256)", validatorAddr, amount)
        );
        require(success, "Delegation failed");
    }
}
```

## Development Workflow

### 1. Project Setup

<CodeGroup>

```bash Hardhat
# Create new project
mkdir my-cosmos-contract
cd my-cosmos-contract

# Initialize Hardhat
npx hardhat init

# Install dependencies
npm install @openzeppelin/contracts
npm install @cosmoshub/evm-precompiles
```

```bash Foundry
# Create new project
forge init my-cosmos-contract
cd my-cosmos-contract

# Install dependencies
forge install OpenZeppelin/openzeppelin-contracts
forge install cosmos/evm-precompiles
```

</CodeGroup>

### 2. Write & Test Contracts

```solidity
// contracts/MyContract.sol
pragma solidity ^0.8.20;

contract MyContract {
    mapping(address => uint256) public balances;
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        payable(msg.sender).transfer(amount);
    }
}
```

```javascript
// test/MyContract.test.js
const { expect } = require("chai");

describe("MyContract", function () {
  let contract;
  let owner, addr1;

  beforeEach(async function () {
    [owner, addr1] = await ethers.getSigners();
    const MyContract = await ethers.getContractFactory("MyContract");
    contract = await MyContract.deploy();
  });

  it("Should deposit and withdraw correctly", async function () {
    // Deposit 1 ETH
    await contract.connect(addr1).deposit({ value: ethers.parseEther("1.0") });
    expect(await contract.balances(addr1.address)).to.equal(ethers.parseEther("1.0"));
    
    // Withdraw 0.5 ETH
    await contract.connect(addr1).withdraw(ethers.parseEther("0.5"));
    expect(await contract.balances(addr1.address)).to.equal(ethers.parseEther("0.5"));
  });
});
```

### 3. Deploy to Networks

```javascript
// scripts/deploy.js
async function main() {
  const [deployer] = await ethers.getSigners();
  console.log("Deploying with account:", deployer.address);

  const MyContract = await ethers.getContractFactory("MyContract");
  const contract = await MyContract.deploy();
  
  await contract.waitForDeployment();
  console.log("Contract deployed to:", await contract.getAddress());
  
  // Verify on block explorer
  if (network.name !== "hardhat") {
    console.log("Waiting for verification...");
    await new Promise(resolve => setTimeout(resolve, 60000));
    
    await hre.run("verify:verify", {
      address: await contract.getAddress(),
      constructorArguments: [],
    });
  }
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
```

## Testing Strategies

### Unit Testing

Test individual contract functions:

```javascript
describe("Token Contract", function () {
  it("Should mint tokens correctly", async function () {
    await token.mint(addr1.address, 1000);
    expect(await token.balanceOf(addr1.address)).to.equal(1000);
  });
  
  it("Should handle transfers", async function () {
    await token.mint(owner.address, 1000);
    await token.transfer(addr1.address, 500);
    expect(await token.balanceOf(addr1.address)).to.equal(500);
  });
});
```

### Integration Testing

Test interactions between contracts:

```javascript
describe("DeFi Protocol Integration", function () {
  let token, pool, router;
  
  beforeEach(async function () {
    // Deploy all contracts
    token = await deployToken();
    pool = await deployPool(token.address);
    router = await deployRouter(pool.address);
  });
  
  it("Should handle full swap workflow", async function () {
    // Add liquidity
    await token.approve(router.address, 1000);
    await router.addLiquidity(token.address, 1000, { value: 1000 });
    
    // Execute swap
    await router.swapExactTokensForETH(100, 90, [token.address], addr1.address);
    
    // Verify results
    expect(await ethers.provider.getBalance(addr1.address)).to.be.above(initialBalance);
  });
});
```

### Gas Optimization Testing

```javascript
describe("Gas Optimization", function () {
  it("Should use minimal gas for batch operations", async function () {
    const addresses = [addr1.address, addr2.address, addr3.address];
    const amounts = [100, 200, 300];
    
    const tx = await token.batchTransfer(addresses, amounts);
    const receipt = await tx.wait();
    
    console.log("Gas used:", receipt.gasUsed.toString());
    expect(receipt.gasUsed).to.be.below(100000); // Set reasonable limit
  });
});
```

## Security Best Practices

### Access Control

```solidity
import "@openzeppelin/contracts/access/AccessControl.sol";

contract SecureContract is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }
    
    function criticalFunction() external onlyRole(ADMIN_ROLE) {
        // Admin-only functionality
    }
    
    function operatorFunction() external onlyRole(OPERATOR_ROLE) {
        // Operator functionality
    }
}
```

### Reentrancy Protection

```solidity
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract SafeContract is ReentrancyGuard {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount;
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

### Input Validation

```solidity
contract ValidatedContract {
    function safeTransfer(address to, uint256 amount) external {
        require(to != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be positive");
        require(amount <= balanceOf(msg.sender), "Insufficient balance");
        
        _transfer(msg.sender, to, amount);
    }
}
```

## Advanced Features

### Proxy Patterns

```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract UpgradeableContract is Initializable, UUPSUpgradeable {
    uint256 public value;
    
    function initialize(uint256 _value) public initializer {
        value = _value;
        __UUPSUpgradeable_init();
    }
    
    function _authorizeUpgrade(address newImplementation) internal override {
        // Add authorization logic
    }
}
```

### Multi-Signature Wallets

```solidity
contract MultiSigWallet {
    mapping(address => bool) public isOwner;
    uint256 public required;
    
    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmations;
    }
    
    Transaction[] public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    
    modifier onlyOwner() {
        require(isOwner[msg.sender], "Not an owner");
        _;
    }
    
    function submitTransaction(address to, uint256 value, bytes memory data) 
        external onlyOwner returns (uint256) {
        uint256 txIndex = transactions.length;
        transactions.push(Transaction({
            to: to,
            value: value,
            data: data,
            executed: false,
            confirmations: 0
        }));
        
        return txIndex;
    }
}
```

## Performance Optimization

### Gas Efficient Patterns

```solidity
contract OptimizedContract {
    // Use packed structs
    struct User {
        uint128 balance;    // Instead of uint256
        uint64 lastSeen;    // Timestamp fits in uint64
        uint32 level;       // Level fits in uint32
        bool active;        // Boolean
    }
    
    // Batch operations
    function batchTransfer(address[] memory recipients, uint256[] memory amounts) 
        external {
        require(recipients.length == amounts.length, "Array length mismatch");
        
        for (uint256 i = 0; i < recipients.length; i++) {
            _transfer(msg.sender, recipients[i], amounts[i]);
        }
    }
    
    // Use events for cheap storage
    event UserAction(address indexed user, uint256 indexed action, uint256 value);
    
    function logAction(uint256 action, uint256 value) external {
        emit UserAction(msg.sender, action, value);
    }
}
```

## Next Steps

<div className="grid md:grid-cols-2 gap-4 my-8">
  <a href="/docs/cosmos-evm/smart-contracts/hardhat" className="block p-4 border border-gray-200 dark:border-gray-700 rounded-lg hover:border-blue-500 dark:hover:border-blue-400 transition-colors">
    <div className="font-semibold mb-2">ðŸ”¨ Hardhat Development</div>
    <div className="text-sm text-gray-600 dark:text-gray-400">Complete guide to Hardhat development on Cosmos EVM</div>
  </a>
  
  <a href="/docs/cosmos-evm/smart-contracts/foundry" className="block p-4 border border-gray-200 dark:border-gray-700 rounded-lg hover:border-blue-500 dark:hover:border-blue-400 transition-colors">
    <div className="font-semibold mb-2">âš¡ Foundry Toolkit</div>
    <div className="text-sm text-gray-600 dark:text-gray-400">Fast development and testing with Foundry</div>
  </a>
  
  <a href="/docs/cosmos-evm/advanced/precompiles" className="block p-4 border border-gray-200 dark:border-gray-700 rounded-lg hover:border-blue-500 dark:hover:border-blue-400 transition-colors">
    <div className="font-semibold mb-2">ðŸŒŸ Precompiled Contracts</div>
    <div className="text-sm text-gray-600 dark:text-gray-400">Access Cosmos SDK features from smart contracts</div>
  </a>
  
  <a href="/docs/cosmos-evm/frontend" className="block p-4 border border-gray-200 dark:border-gray-700 rounded-lg hover:border-blue-500 dark:hover:border-blue-400 transition-colors">
    <div className="font-semibold mb-2">ðŸŽ¨ Frontend Integration</div>
    <div className="text-sm text-gray-600 dark:text-gray-400">Build user interfaces for your smart contracts</div>
  </a>
</div>

## Resources

- **[OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)** - Secure, reusable smart contracts
- **[Solidity Documentation](https://docs.soliditylang.org/)** - Official Solidity language reference
- **[Cosmos EVM Examples](https://github.com/cosmos/evm-examples)** - Sample contracts and applications
- **[Security Guidelines](https://consensys.github.io/smart-contract-best-practices/)** - Smart contract security best practices