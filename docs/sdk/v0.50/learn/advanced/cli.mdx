---
title: Command-Line Interface
---

<Note>
**Synopsis**
This document describes how command-line interface (CLI) works on a high-level, for an [**application**](/docs/sdk/v0.50/beginner/app-anatomy). A separate document for implementing a CLI for a Cosmos SDK [**module**](/docs/sdk/v0.50//build/building-modules/intro) can be found [here](/docs/sdk/v0.50//build/building-modules/module-interfaces#cli).
</Note>

## Command-Line Interface

### Example Command

There is no set way to create a CLI, but Cosmos SDK modules typically use the [Cobra Library](https://github.com/spf13/cobra). Building a CLI with Cobra entails defining commands, arguments, and flags. [**Commands**](#root-command) understand the actions users wish to take, such as `tx` for creating a transaction and `query` for querying the application. Each command can also have nested subcommands, necessary for naming the specific transaction type. Users also supply **Arguments**, such as account numbers to send coins to, and [**Flags**](#flags) to modify various aspects of the commands, such as gas prices or which node to broadcast to.

Here is an example of a command a user might enter to interact with the simapp CLI `simd` in order to send some tokens:

```bash
simd tx bank send $MY_VALIDATOR_ADDRESS $RECIPIENT 1000stake --gas auto --gas-prices <gasPrices>
```

The first four strings specify the command:

* The root command for the entire application `simd`.
* The subcommand `tx`, which contains all commands that let users create transactions.
* The subcommand `bank` to indicate which module to route the command to ([`x/bank`](/docs/sdk/v0.50//build/modules/bank/README) module in this case).
* The type of transaction `send`.

The next two strings are arguments: the `from_address` the user wishes to send from, the `to_address` of the recipient, and the `amount` they want to send. Finally, the last few strings of the command are optional flags to indicate how much the user is willing to pay in fees (calculated using the amount of gas used to execute the transaction and the gas prices provided by the user).

The CLI interacts with a [node](/docs/sdk/v0.50/node) to handle this command. The interface itself is defined in a `main.go` file.

### Building the CLI

The `main.go` file needs to have a `main()` function that creates a root command, to which all the application commands will be added as subcommands. The root command additionally handles:

* **setting configurations** by reading in configuration files (e.g. the Cosmos SDK config file).
* **adding any flags** to it, such as `--chain-id`.
* **instantiating the `codec`** by injecting the application codecs. The [`codec`](/docs/sdk/v0.50/encoding) is used to encode and decode data structures for the application - stores can only persist `[]byte`s so the developer must define a serialization format for their data structures or use the default, Protobuf.
* **adding subcommand** for all the possible user interactions, including [transaction commands](#transaction-commands) and [query commands](#query-commands).

The `main()` function finally creates an executor and [execute](https://pkg.go.dev/github.com/spf13/cobra#Command.Execute) the root command. See an example of `main()` function from the `simapp` application:

```go expandable
package main

import (
    
	"os"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
    "cosmossdk.io/simapp/simd/cmd"
	svrcmd "github.com/cosmos/cosmos-sdk/server/cmd"
)

func main() {
    rootCmd := cmd.NewRootCmd()
    if err := svrcmd.Execute(rootCmd, "", simapp.DefaultNodeHome); err != nil {
    log.NewLogger(rootCmd.OutOrStderr()).Error("failure when running app", "err", err)

os.Exit(1)
}
}
```

The rest of the document will detail what needs to be implemented for each step and include smaller portions of code from the `simapp` CLI files.

## Adding Commands to the CLI

Every application CLI first constructs a root command, then adds functionality by aggregating subcommands (often with further nested subcommands) using `rootCmd.AddCommand()`. The bulk of an application's unique capabilities lies in its transaction and query commands, called `TxCmd` and `QueryCmd` respectively.

### Root Command

The root command (called `rootCmd`) is what the user first types into the command line to indicate which application they wish to interact with. The string used to invoke the command (the "Use" field) is typically the name of the application suffixed with `-d`, e.g. `simd` or `gaiad`. The root command typically includes the following commands to support basic functionality in the application.

* **Status** command from the Cosmos SDK rpc client tools, which prints information about the status of the connected [`Node`](/docs/sdk/v0.50/node). The Status of a node includes `NodeInfo`,`SyncInfo` and `ValidatorInfo`.
* **Keys** [commands](https://github.com/cosmos/cosmos-sdk/blob/v0.50.0-alpha.0/client/keys) from the Cosmos SDK client tools, which includes a collection of subcommands for using the key functions in the Cosmos SDK crypto tools, including adding a new key and saving it to the keyring, listing all public keys stored in the keyring, and deleting a key. For example, users can type `simd keys add <name>` to add a new key and save an encrypted copy to the keyring, using the flag `--recover` to recover a private key from a seed phrase or the flag `--multisig` to group multiple keys together to create a multisig key. For full details on the `add` key command, see the code [here](https://github.com/cosmos/cosmos-sdk/blob/v0.50.0-alpha.0/client/keys/add.go). For more details about usage of `--keyring-backend` for storage of key credentials look at the [keyring docs](/docs/sdk/v0.50//user/run-node/keyring).
* **Server** commands from the Cosmos SDK server package. These commands are responsible for providing the mechanisms necessary to start an ABCI CometBFT application and provides the CLI framework (based on [cobra](https://github.com/spf13/cobra)) necessary to fully bootstrap an application. The package exposes two core functions: `StartCmd` and `ExportCmd` which creates commands to start the application and export state respectively.
  Learn more [here](https://github.com/cosmos/cosmos-sdk/blob/v0.50.0-alpha.0/server).
* [**Transaction**](#transaction-commands) commands.
* [**Query**](#query-commands) commands.

Next is an example `rootCmd` function from the `simapp` application. It instantiates the root command, adds a [*persistent* flag](#flags) and `PreRun` function to be run before every execution, and adds all of the necessary subcommands.

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

<Tip>
Use the `EnhanceRootCommand()` from the AutoCLI options to automatically add auto-generated commands from the modules to the root command.
Additionnally it adds all manually defined modules commands (`tx` and `query`) as well.
Read more about [AutoCLI](https://docs.cosmos.network/main/core/autocli) in its dedicated section.
</Tip>

`rootCmd` has a function called `initAppConfig()` which is useful for setting the application's custom configs.
By default app uses CometBFT app config template from Cosmos SDK, which can be over-written via `initAppConfig()`.
Here's an example code to override default `app.toml` template.

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

The `initAppConfig()` also allows overriding the default Cosmos SDK's [server config](https://github.com/cosmos/cosmos-sdk/blob/v0.50.0-alpha.0/server/config/config.go#L235). One example is the `min-gas-prices` config, which defines the minimum gas prices a validator is willing to accept for processing a transaction. By default, the Cosmos SDK sets this parameter to `""` (empty string), which forces all validators to tweak their own `app.toml` and set a non-empty value, or else the node will halt on startup. This might not be the best UX for validators, so the chain developer can set a default `app.toml` value for validators inside this `initAppConfig()` function.

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

The root-level `status` and `keys` subcommands are common across most applications and do not interact with application state. The bulk of an application's functionality - what users can actually *do* with it - is enabled by its `tx` and `query` commands.

### Transaction Commands

[Transactions](/docs/sdk/v0.50/transactions) are objects wrapping [`Msg`s](/docs/sdk/v0.50//build/building-modules/messages-and-queries#messages) that trigger state changes. To enable the creation of transactions using the CLI interface, a function `txCommand` is generally added to the `rootCmd`:

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

This `txCommand` function adds all the transaction available to end-users for the application. This typically includes:

* **Sign command** from the [`auth`](/docs/sdk/v0.50//build/modules/auth/README) module that signs messages in a transaction. To enable multisig, add the `auth` module's `MultiSign` command. Since every transaction requires some sort of signature in order to be valid, the signing command is necessary for every application.
* **Broadcast command** from the Cosmos SDK client tools, to broadcast transactions.
* **All [module transaction commands](/docs/sdk/v0.50//build/building-modules/module-interfaces#transaction-commands)** the application is dependent on, retrieved by using the [basic module manager's](/docs/sdk/v0.50//build/building-modules/module-manager#basic-manager) `AddTxCommands()` function, or enhanced by [AutoCLI](https://docs.cosmos.network/main/core/autocli).

Here is an example of a `txCommand` aggregating these subcommands from the `simapp` application:

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

<Tip>
When using AutoCLI to generate module transaction commands, `EnhanceRootCommand()` automatically adds the module `tx` command to the root command.
Read more about [AutoCLI](https://docs.cosmos.network/main/core/autocli) in its dedicated section.
</Tip>

### Query Commands

[**Queries**](/docs/sdk/v0.50//build/building-modules/messages-and-queries#queries) are objects that allow users to retrieve information about the application's state. To enable the creation of queries using the CLI interface, a function `queryCommand` is generally added to the `rootCmd`:

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

This `queryCommand` function adds all the queries available to end-users for the application. This typically includes:

* **QueryTx** and/or other transaction query commands from the `auth` module which allow the user to search for a transaction by inputting its hash, a list of tags, or a block height. These queries allow users to see if transactions have been included in a block.
* **Account command** from the `auth` module, which displays the state (e.g. account balance) of an account given an address.
* **Validator command** from the Cosmos SDK rpc client tools, which displays the validator set of a given height.
* **Block command** from the Cosmos SDK RPC client tools, which displays the block data for a given height.
* **All [module query commands](/docs/sdk/v0.50//build/building-modules/module-interfaces#query-commands)** the application is dependent on, retrieved by using the [basic module manager's](/docs/sdk/v0.50//build/building-modules/module-manager#basic-manager) `AddQueryCommands()` function, or enhanced by [AutoCLI](https://docs.cosmos.network/main/core/autocli).

Here is an example of a `queryCommand` aggregating subcommands from the `simapp` application:

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

<Tip>
When using AutoCLI to generate module query commands, `EnhanceRootCommand()` automatically adds the module `query` command to the root command.
Read more about [AutoCLI](https://docs.cosmos.network/main/core/autocli) in its dedicated section.
</Tip>

## Flags

Flags are used to modify commands; developers can include them in a `flags.go` file with their CLI. Users can explicitly include them in commands or pre-configure them by inside their [`app.toml`](/docs/sdk/v0.50//user/run-node/run-node#configuring-the-node-using-apptoml-and-configtoml). Commonly pre-configured flags include the `--node` to connect to and `--chain-id` of the blockchain the user wishes to interact with.

A *persistent* flag (as opposed to a *local* flag) added to a command transcends all of its children: subcommands will inherit the configured values for these flags. Additionally, all flags have default values when they are added to commands; some toggle an option off but others are empty values that the user needs to override to create valid commands. A flag can be explicitly marked as *required* so that an error is automatically thrown if the user does not provide a value, but it is also acceptable to handle unexpected missing flags differently.

Flags are added to commands directly (generally in the [module's CLI file](/docs/sdk/v0.50//build/building-modules/module-interfaces#flags) where module commands are defined) and no flag except for the `rootCmd` persistent flags has to be added at application level. It is common to add a *persistent* flag for `--chain-id`, the unique identifier of the blockchain the application pertains to, to the root command. Adding this flag can be done in the `main()` function. Adding this flag makes sense as the chain ID should not be changing across commands in this application CLI.

## Environment variables

Each flag is bound to its respective named environment variable. Then name of the environment variable consist of two parts - capital case `basename` followed by flag name of the flag. `-` must be substituted with `_`. For example flag `--node` for application with basename `GAIA` is bound to `GAIA_NODE`. It allows reducing the amount of flags typed for routine operations. For example instead of:

```shell
gaia --home=./ --node=<node address> --chain-id="testchain-1" --keyring-backend=test tx ... --from=<key name>
```

this will be more convenient:

```shell
# define env variables in .env, .envrc etc
GAIA_HOME=<path to home>
GAIA_NODE=<node address>
GAIA_CHAIN_ID="testchain-1"
GAIA_KEYRING_BACKEND="test"

# and later just use
gaia tx ... --from=<key name>
```

## Configurations

It is vital that the root command of an application uses `PersistentPreRun()` cobra command property for executing the command, so all child commands have access to the server and client contexts. These contexts are set as their default values initially and may be modified, scoped to the command, in their respective `PersistentPreRun()` functions. Note that the `client.Context` is typically pre-populated with "default" values that may be useful for all commands to inherit and override if necessary.

Here is an example of an `PersistentPreRun()` function from `simapp`:

```go expandable
//go:build !app_v1

package cmd

import (
    
	"errors"
    "io"
    "os"

	cmtcfg "github.com/cometbft/cometbft/config"
	dbm "github.com/cosmos/cosmos-db"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "cosmossdk.io/client/v2/autocli"
    "cosmossdk.io/depinject"
    "cosmossdk.io/log"
    "cosmossdk.io/simapp"
	confixcmd "cosmossdk.io/tools/confix/cmd"
	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/client/snapshot"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/types/tx/signing"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/tx"
	txmodule "github.com/cosmos/cosmos-sdk/x/auth/tx/config"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the main function.
func NewRootCmd() *cobra.Command {
    var (
		interfaceRegistry  codectypes.InterfaceRegistry
		appCodec           codec.Codec
		txConfig           client.TxConfig
		legacyAmino        *codec.LegacyAmino
		autoCliOpts        autocli.AppOptions
		moduleBasicManager module.BasicManager
	)
    if err := depinject.Inject(depinject.Configs(simapp.AppConfig, depinject.Supply(log.NewNopLogger())),
		&interfaceRegistry,
		&appCodec,
		&txConfig,
		&legacyAmino,
		&autoCliOpts,
		&moduleBasicManager,
	); err != nil {
    panic(err)
}
    initClientCtx := client.Context{
}.
		WithCodec(appCodec).
		WithInterfaceRegistry(interfaceRegistry).
		WithLegacyAmino(legacyAmino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx = initClientCtx.WithCmdContext(cmd.Context())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}

			// This needs to go after ReadFromClientConfig, as that function
			// sets the RPC client needed for SIGN_MODE_TEXTUAL.
    enabledSignModes := append(tx.DefaultSignModes, signing.SignMode_SIGN_MODE_TEXTUAL)
    txConfigOpts := tx.ConfigOptions{
    EnabledSignModes:           enabledSignModes,
    TextualCoinMetadataQueryFn: txmodule.NewGRPCCoinMetadataQueryFn(initClientCtx),
}

txConfigWithTextual, err := tx.NewTxConfigWithOptions(
				codec.NewProtoCodec(interfaceRegistry),
				txConfigOpts,
			)
    if err != nil {
    return err
}

initClientCtx = initClientCtx.WithTxConfig(txConfigWithTextual)
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customCMTConfig := initCometBFTConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)
},
}

initRootCmd(rootCmd, txConfig, interfaceRegistry, appCodec, moduleBasicManager)
    if err := autoCliOpts.EnhanceRootCommand(rootCmd); err != nil {
    panic(err)
}

return rootCmd
}

// initCometBFTConfig helps to override default CometBFT Config values.
// return cmtcfg.DefaultConfig if no custom configuration is required for the application.
func initCometBFTConfig() *cmtcfg.Config {
    cfg := cmtcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(
	rootCmd *cobra.Command,
	txConfig client.TxConfig,
	interfaceRegistry codectypes.InterfaceRegistry,
	appCodec codec.Codec,
	basicManager module.BasicManager,
) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(basicManager, simapp.DefaultNodeHome),
		NewTestnetCmd(basicManager, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		confixcmd.ConfigCommand(),
		pruning.Cmd(newApp),
		snapshot.Cmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(txConfig, basicManager),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(interfaceRegistry, appCodec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(txConfig client.TxConfig, basicManager module.BasicManager, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.Commands(txConfig, basicManager, simapp.DefaultNodeHome)
    for _, subCmd := range cmds {
    cmd.AddCommand(subCmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		rpc.ValidatorCommand(),
		server.QueryBlockCmd(),
		authcmd.QueryTxsByEventsCmd(),
		server.QueryBlocksCmd(),
		authcmd.QueryTxCmd(),
	)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts

	var simApp *simapp.SimApp
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

The `SetCmdClientContextHandler` call reads persistent flags via `ReadPersistentCommandFlags` which creates a `client.Context` and sets that on the root command's `Context`.

The `InterceptConfigsPreRunHandler` call creates a viper literal, default `server.Context`, and a logger and sets that on the root command's `Context`. The `server.Context` will be modified and saved to disk. The internal `interceptConfigs` call reads or creates a CometBFT configuration based on the home path provided. In addition, `interceptConfigs` also reads and loads the application configuration, `app.toml`, and binds that to the `server.Context` viper literal. This is vital so the application can get access to not only the CLI flags, but also to the application configuration values provided by this file.

<Tip>
When willing to configure which logger is used, do not use `InterceptConfigsPreRunHandler`, which sets the default SDK logger, but instead use `InterceptConfigsAndCreateContext` and set the server context and the logger manually:

```diff expandable
-return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customCMTConfig)

+serverCtx, err := server.InterceptConfigsAndCreateContext(cmd, customAppTemplate, customAppConfig, customCMTConfig)
+if err != nil {
+	return err
+}

+// overwrite default server logger
+logger, err := server.CreateSDKLogger(serverCtx, cmd.OutOrStdout())
+if err != nil {
+	return err
+}
+serverCtx.Logger = logger.With(log.ModuleKey, "server")

+// set server context
+return server.SetCmdServerContext(cmd, serverCtx)
```

</Tip>
