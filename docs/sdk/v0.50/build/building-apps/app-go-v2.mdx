---
title: Overview of `app_v2.go`
---

<Note>
**Synopsis**

The Cosmos SDK allows much easier wiring of an `app.go` thanks to App Wiring and [`depinject`](/docs/sdk/v0.50/packages/depinject).
Learn more about the rationale of App Wiring in [ADR-057](/docs/sdk/v0.50/architecture/adr-057-app-wiring).

</Note>

<Note>
**Pre-requisite Readings**

* [ADR 057: App Wiring](/docs/sdk/v0.50/architecture/adr-057-app-wiring)
* [Depinject Documentation](/docs/sdk/v0.50/packages/depinject)
* [Modules depinject-ready](/docs/sdk/v0.50/building-modules/depinject)

</Note>

This section is intended to provide an overview of the `SimApp` `app_v2.go` file with App Wiring.

## `app_config.go`

The `app_config.go` file is the single place to configure all modules parameters.

1. Create the `AppConfig` variable:

   ```go expandable
   package simapp

   import (
       
   	"time"
       "google.golang.org/protobuf/types/known/durationpb"

   	runtimev1alpha1 "cosmossdk.io/api/cosmos/app/runtime/v1alpha1"
   	appv1alpha1 "cosmossdk.io/api/cosmos/app/v1alpha1"
   	authmodulev1 "cosmossdk.io/api/cosmos/auth/module/v1"
   	authzmodulev1 "cosmossdk.io/api/cosmos/authz/module/v1"
   	bankmodulev1 "cosmossdk.io/api/cosmos/bank/module/v1"
   	circuitmodulev1 "cosmossdk.io/api/cosmos/circuit/module/v1"
   	consensusmodulev1 "cosmossdk.io/api/cosmos/consensus/module/v1"
   	crisismodulev1 "cosmossdk.io/api/cosmos/crisis/module/v1"
   	distrmodulev1 "cosmossdk.io/api/cosmos/distribution/module/v1"
   	evidencemodulev1 "cosmossdk.io/api/cosmos/evidence/module/v1"
   	feegrantmodulev1 "cosmossdk.io/api/cosmos/feegrant/module/v1"
   	genutilmodulev1 "cosmossdk.io/api/cosmos/genutil/module/v1"
   	govmodulev1 "cosmossdk.io/api/cosmos/gov/module/v1"
   	groupmodulev1 "cosmossdk.io/api/cosmos/group/module/v1"
   	mintmodulev1 "cosmossdk.io/api/cosmos/mint/module/v1"
   	nftmodulev1 "cosmossdk.io/api/cosmos/nft/module/v1"
   	paramsmodulev1 "cosmossdk.io/api/cosmos/params/module/v1"
   	slashingmodulev1 "cosmossdk.io/api/cosmos/slashing/module/v1"
   	stakingmodulev1 "cosmossdk.io/api/cosmos/staking/module/v1"
   	txconfigv1 "cosmossdk.io/api/cosmos/tx/config/v1"
   	upgrademodulev1 "cosmossdk.io/api/cosmos/upgrade/module/v1"
   	vestingmodulev1 "cosmossdk.io/api/cosmos/vesting/module/v1"
       "cosmossdk.io/depinject"

   	_ "cosmossdk.io/x/circuit"                        // import for side-effects
   	_ "cosmossdk.io/x/evidence"                       // import for side-effects
   	_ "cosmossdk.io/x/feegrant/module"                // import for side-effects
   	_ "cosmossdk.io/x/nft/module"                     // import for side-effects
   	_ "cosmossdk.io/x/upgrade"                        // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/tx/config" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/vesting"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/authz/module"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/bank"           // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/consensus"      // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/crisis"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/distribution"   // import for side-effects
   	"github.com/cosmos/cosmos-sdk/x/genutil"
       "github.com/cosmos/cosmos-sdk/x/gov"
   	_ "github.com/cosmos/cosmos-sdk/x/group/module" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/mint"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/params"       // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/slashing"     // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/staking"      // import for side-effects

   	"cosmossdk.io/core/appconfig"
   	circuittypes "cosmossdk.io/x/circuit/types"
   	evidencetypes "cosmossdk.io/x/evidence/types"
       "cosmossdk.io/x/feegrant"
       "cosmossdk.io/x/nft"
   	upgradetypes "cosmossdk.io/x/upgrade/types"
       "github.com/cosmos/cosmos-sdk/runtime"
       "github.com/cosmos/cosmos-sdk/types/module"
   	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
   	vestingtypes "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
       "github.com/cosmos/cosmos-sdk/x/authz"
   	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
   	consensustypes "github.com/cosmos/cosmos-sdk/x/consensus/types"
   	crisistypes "github.com/cosmos/cosmos-sdk/x/crisis/types"
   	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
   	genutiltypes "github.com/cosmos/cosmos-sdk/x/genutil/types"
   	govclient "github.com/cosmos/cosmos-sdk/x/gov/client"
   	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
       "github.com/cosmos/cosmos-sdk/x/group"
   	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
   	paramsclient "github.com/cosmos/cosmos-sdk/x/params/client"
   	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
   	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
   	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
   )

   var (
   	// module account permissions
   	moduleAccPerms = []*authmodulev1.ModuleAccountPermission{
   		{
       Account: authtypes.FeeCollectorName
   },
   		{
       Account: distrtypes.ModuleName
   },
   		{
       Account: minttypes.ModuleName,
       Permissions: []string{
       authtypes.Minter
   }},
   		{
       Account: stakingtypes.BondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: stakingtypes.NotBondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: govtypes.ModuleName,
       Permissions: []string{
       authtypes.Burner
   }},
   		{
       Account: nft.ModuleName
   },
   }

   	// blocked account addresses
   	blockAccAddrs = []string{
       authtypes.FeeCollectorName,
   		distrtypes.ModuleName,
   		minttypes.ModuleName,
   		stakingtypes.BondedPoolName,
   		stakingtypes.NotBondedPoolName,
   		nft.ModuleName,
   		// We allow the following module accounts to receive funds:
   		// govtypes.ModuleName
   }

   	// application configuration (used by depinject)

   AppConfig = depinject.Configs(appconfig.Compose(&appv1alpha1.Config{
       Modules: []*appv1alpha1.ModuleConfig{
   			{
       Name: runtime.ModuleName,
       Config: appconfig.WrapAny(&runtimev1alpha1.Module{
       AppName: "SimApp",
   					// During begin block slashing happens after distr.BeginBlocker so that
   					// there is nothing left over in the validator fee pool, so as to keep the
   					// CanWithdrawInvariant invariant.
   					// NOTE: staking module is required if HistoricalEntries param > 0
   					BeginBlockers: []string{
       upgradetypes.ModuleName,
   						minttypes.ModuleName,
   						distrtypes.ModuleName,
   						slashingtypes.ModuleName,
   						evidencetypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						authz.ModuleName,
   },
       EndBlockers: []string{
       crisistypes.ModuleName,
   						govtypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						feegrant.ModuleName,
   						group.ModuleName,
   },
       OverrideStoreKeys: []*runtimev1alpha1.StoreKeyConfig{
   						{
       ModuleName: authtypes.ModuleName,
       KvStoreKey: "acc",
   },
   },
   					// NOTE: The genutils module must occur after staking so that pools are
   					// properly initialized with tokens from genesis accounts.
   					// NOTE: The genutils module must also occur after auth so that it can access the params from auth.
   					InitGenesis: []string{
       authtypes.ModuleName,
   						banktypes.ModuleName,
   						distrtypes.ModuleName,
   						stakingtypes.ModuleName,
   						slashingtypes.ModuleName,
   						govtypes.ModuleName,
   						minttypes.ModuleName,
   						crisistypes.ModuleName,
   						genutiltypes.ModuleName,
   						evidencetypes.ModuleName,
   						authz.ModuleName,
   						feegrant.ModuleName,
   						nft.ModuleName,
   						group.ModuleName,
   						paramstypes.ModuleName,
   						upgradetypes.ModuleName,
   						vestingtypes.ModuleName,
   						consensustypes.ModuleName,
   						circuittypes.ModuleName,
   },
   					// When ExportGenesis is not specified, the export genesis module order
   					// is equal to the init genesis order
   					// ExportGenesis: []string{
   },
   					// Uncomment if you want to set a custom migration order here.
   					// OrderMigrations: []string{
   },
   }),
   },
   			{
       Name: authtypes.ModuleName,
       Config: appconfig.WrapAny(&authmodulev1.Module{
       Bech32Prefix:             "cosmos",
       ModuleAccountPermissions: moduleAccPerms,
   					// By default modules authority is the governance module. This is configurable with the following:
   					// Authority: "group", // A custom module authority can be set using a module name
   					// Authority: "cosmos1cwwv22j5ca08ggdv9c2uky355k908694z577tv", // or a specific address
   }),
   },
   			{
       Name:   vestingtypes.ModuleName,
       Config: appconfig.WrapAny(&vestingmodulev1.Module{
   }),
   },
   			{
       Name: banktypes.ModuleName,
       Config: appconfig.WrapAny(&bankmodulev1.Module{
       BlockedModuleAccountsOverride: blockAccAddrs,
   }),
   },
   			{
       Name:   stakingtypes.ModuleName,
       Config: appconfig.WrapAny(&stakingmodulev1.Module{
   }),
   },
   			{
       Name:   slashingtypes.ModuleName,
       Config: appconfig.WrapAny(&slashingmodulev1.Module{
   }),
   },
   			{
       Name:   paramstypes.ModuleName,
       Config: appconfig.WrapAny(&paramsmodulev1.Module{
   }),
   },
   			{
       Name:   "tx",
       Config: appconfig.WrapAny(&txconfigv1.Config{
   }),
   },
   			{
       Name:   genutiltypes.ModuleName,
       Config: appconfig.WrapAny(&genutilmodulev1.Module{
   }),
   },
   			{
       Name:   authz.ModuleName,
       Config: appconfig.WrapAny(&authzmodulev1.Module{
   }),
   },
   			{
       Name:   upgradetypes.ModuleName,
       Config: appconfig.WrapAny(&upgrademodulev1.Module{
   }),
   },
   			{
       Name:   distrtypes.ModuleName,
       Config: appconfig.WrapAny(&distrmodulev1.Module{
   }),
   },
   			{
       Name:   evidencetypes.ModuleName,
       Config: appconfig.WrapAny(&evidencemodulev1.Module{
   }),
   },
   			{
       Name:   minttypes.ModuleName,
       Config: appconfig.WrapAny(&mintmodulev1.Module{
   }),
   },
   			{
       Name: group.ModuleName,
       Config: appconfig.WrapAny(&groupmodulev1.Module{
       MaxExecutionPeriod: durationpb.New(time.Second * 1209600),
       MaxMetadataLen:     255,
   }),
   },
   			{
       Name:   nft.ModuleName,
       Config: appconfig.WrapAny(&nftmodulev1.Module{
   }),
   },
   			{
       Name:   feegrant.ModuleName,
       Config: appconfig.WrapAny(&feegrantmodulev1.Module{
   }),
   },
   			{
       Name:   govtypes.ModuleName,
       Config: appconfig.WrapAny(&govmodulev1.Module{
   }),
   },
   			{
       Name:   crisistypes.ModuleName,
       Config: appconfig.WrapAny(&crisismodulev1.Module{
   }),
   },
   			{
       Name:   consensustypes.ModuleName,
       Config: appconfig.WrapAny(&consensusmodulev1.Module{
   }),
   },
   			{
       Name:   circuittypes.ModuleName,
       Config: appconfig.WrapAny(&circuitmodulev1.Module{
   }),
   },
   },
   }),
   		depinject.Supply(
   			// supply custom module basics
   			map[string]module.AppModuleBasic{
       genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),
   				govtypes.ModuleName: gov.NewAppModuleBasic(
   					[]govclient.ProposalHandler{
       paramsclient.ProposalHandler,
   },
   				),
   },
   		))
   )
   ```

2. Configure the `runtime` module:

   ```go expandable
   package simapp

   import (
       
   	"time"
       "google.golang.org/protobuf/types/known/durationpb"

   	runtimev1alpha1 "cosmossdk.io/api/cosmos/app/runtime/v1alpha1"
   	appv1alpha1 "cosmossdk.io/api/cosmos/app/v1alpha1"
   	authmodulev1 "cosmossdk.io/api/cosmos/auth/module/v1"
   	authzmodulev1 "cosmossdk.io/api/cosmos/authz/module/v1"
   	bankmodulev1 "cosmossdk.io/api/cosmos/bank/module/v1"
   	circuitmodulev1 "cosmossdk.io/api/cosmos/circuit/module/v1"
   	consensusmodulev1 "cosmossdk.io/api/cosmos/consensus/module/v1"
   	crisismodulev1 "cosmossdk.io/api/cosmos/crisis/module/v1"
   	distrmodulev1 "cosmossdk.io/api/cosmos/distribution/module/v1"
   	evidencemodulev1 "cosmossdk.io/api/cosmos/evidence/module/v1"
   	feegrantmodulev1 "cosmossdk.io/api/cosmos/feegrant/module/v1"
   	genutilmodulev1 "cosmossdk.io/api/cosmos/genutil/module/v1"
   	govmodulev1 "cosmossdk.io/api/cosmos/gov/module/v1"
   	groupmodulev1 "cosmossdk.io/api/cosmos/group/module/v1"
   	mintmodulev1 "cosmossdk.io/api/cosmos/mint/module/v1"
   	nftmodulev1 "cosmossdk.io/api/cosmos/nft/module/v1"
   	paramsmodulev1 "cosmossdk.io/api/cosmos/params/module/v1"
   	slashingmodulev1 "cosmossdk.io/api/cosmos/slashing/module/v1"
   	stakingmodulev1 "cosmossdk.io/api/cosmos/staking/module/v1"
   	txconfigv1 "cosmossdk.io/api/cosmos/tx/config/v1"
   	upgrademodulev1 "cosmossdk.io/api/cosmos/upgrade/module/v1"
   	vestingmodulev1 "cosmossdk.io/api/cosmos/vesting/module/v1"
       "cosmossdk.io/depinject"

   	_ "cosmossdk.io/x/circuit"                        // import for side-effects
   	_ "cosmossdk.io/x/evidence"                       // import for side-effects
   	_ "cosmossdk.io/x/feegrant/module"                // import for side-effects
   	_ "cosmossdk.io/x/nft/module"                     // import for side-effects
   	_ "cosmossdk.io/x/upgrade"                        // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/tx/config" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/vesting"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/authz/module"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/bank"           // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/consensus"      // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/crisis"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/distribution"   // import for side-effects
   	"github.com/cosmos/cosmos-sdk/x/genutil"
       "github.com/cosmos/cosmos-sdk/x/gov"
   	_ "github.com/cosmos/cosmos-sdk/x/group/module" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/mint"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/params"       // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/slashing"     // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/staking"      // import for side-effects

   	"cosmossdk.io/core/appconfig"
   	circuittypes "cosmossdk.io/x/circuit/types"
   	evidencetypes "cosmossdk.io/x/evidence/types"
       "cosmossdk.io/x/feegrant"
       "cosmossdk.io/x/nft"
   	upgradetypes "cosmossdk.io/x/upgrade/types"
       "github.com/cosmos/cosmos-sdk/runtime"
       "github.com/cosmos/cosmos-sdk/types/module"
   	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
   	vestingtypes "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
       "github.com/cosmos/cosmos-sdk/x/authz"
   	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
   	consensustypes "github.com/cosmos/cosmos-sdk/x/consensus/types"
   	crisistypes "github.com/cosmos/cosmos-sdk/x/crisis/types"
   	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
   	genutiltypes "github.com/cosmos/cosmos-sdk/x/genutil/types"
   	govclient "github.com/cosmos/cosmos-sdk/x/gov/client"
   	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
       "github.com/cosmos/cosmos-sdk/x/group"
   	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
   	paramsclient "github.com/cosmos/cosmos-sdk/x/params/client"
   	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
   	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
   	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
   )

   var (
   	// module account permissions
   	moduleAccPerms = []*authmodulev1.ModuleAccountPermission{
   		{
       Account: authtypes.FeeCollectorName
   },
   		{
       Account: distrtypes.ModuleName
   },
   		{
       Account: minttypes.ModuleName,
       Permissions: []string{
       authtypes.Minter
   }},
   		{
       Account: stakingtypes.BondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: stakingtypes.NotBondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: govtypes.ModuleName,
       Permissions: []string{
       authtypes.Burner
   }},
   		{
       Account: nft.ModuleName
   },
   }

   	// blocked account addresses
   	blockAccAddrs = []string{
       authtypes.FeeCollectorName,
   		distrtypes.ModuleName,
   		minttypes.ModuleName,
   		stakingtypes.BondedPoolName,
   		stakingtypes.NotBondedPoolName,
   		nft.ModuleName,
   		// We allow the following module accounts to receive funds:
   		// govtypes.ModuleName
   }

   	// application configuration (used by depinject)

   AppConfig = depinject.Configs(appconfig.Compose(&appv1alpha1.Config{
       Modules: []*appv1alpha1.ModuleConfig{
   			{
       Name: runtime.ModuleName,
       Config: appconfig.WrapAny(&runtimev1alpha1.Module{
       AppName: "SimApp",
   					// During begin block slashing happens after distr.BeginBlocker so that
   					// there is nothing left over in the validator fee pool, so as to keep the
   					// CanWithdrawInvariant invariant.
   					// NOTE: staking module is required if HistoricalEntries param > 0
   					BeginBlockers: []string{
       upgradetypes.ModuleName,
   						minttypes.ModuleName,
   						distrtypes.ModuleName,
   						slashingtypes.ModuleName,
   						evidencetypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						authz.ModuleName,
   },
       EndBlockers: []string{
       crisistypes.ModuleName,
   						govtypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						feegrant.ModuleName,
   						group.ModuleName,
   },
       OverrideStoreKeys: []*runtimev1alpha1.StoreKeyConfig{
   						{
       ModuleName: authtypes.ModuleName,
       KvStoreKey: "acc",
   },
   },
   					// NOTE: The genutils module must occur after staking so that pools are
   					// properly initialized with tokens from genesis accounts.
   					// NOTE: The genutils module must also occur after auth so that it can access the params from auth.
   					InitGenesis: []string{
       authtypes.ModuleName,
   						banktypes.ModuleName,
   						distrtypes.ModuleName,
   						stakingtypes.ModuleName,
   						slashingtypes.ModuleName,
   						govtypes.ModuleName,
   						minttypes.ModuleName,
   						crisistypes.ModuleName,
   						genutiltypes.ModuleName,
   						evidencetypes.ModuleName,
   						authz.ModuleName,
   						feegrant.ModuleName,
   						nft.ModuleName,
   						group.ModuleName,
   						paramstypes.ModuleName,
   						upgradetypes.ModuleName,
   						vestingtypes.ModuleName,
   						consensustypes.ModuleName,
   						circuittypes.ModuleName,
   },
   					// When ExportGenesis is not specified, the export genesis module order
   					// is equal to the init genesis order
   					// ExportGenesis: []string{
   },
   					// Uncomment if you want to set a custom migration order here.
   					// OrderMigrations: []string{
   },
   }),
   },
   			{
       Name: authtypes.ModuleName,
       Config: appconfig.WrapAny(&authmodulev1.Module{
       Bech32Prefix:             "cosmos",
       ModuleAccountPermissions: moduleAccPerms,
   					// By default modules authority is the governance module. This is configurable with the following:
   					// Authority: "group", // A custom module authority can be set using a module name
   					// Authority: "cosmos1cwwv22j5ca08ggdv9c2uky355k908694z577tv", // or a specific address
   }),
   },
   			{
       Name:   vestingtypes.ModuleName,
       Config: appconfig.WrapAny(&vestingmodulev1.Module{
   }),
   },
   			{
       Name: banktypes.ModuleName,
       Config: appconfig.WrapAny(&bankmodulev1.Module{
       BlockedModuleAccountsOverride: blockAccAddrs,
   }),
   },
   			{
       Name:   stakingtypes.ModuleName,
       Config: appconfig.WrapAny(&stakingmodulev1.Module{
   }),
   },
   			{
       Name:   slashingtypes.ModuleName,
       Config: appconfig.WrapAny(&slashingmodulev1.Module{
   }),
   },
   			{
       Name:   paramstypes.ModuleName,
       Config: appconfig.WrapAny(&paramsmodulev1.Module{
   }),
   },
   			{
       Name:   "tx",
       Config: appconfig.WrapAny(&txconfigv1.Config{
   }),
   },
   			{
       Name:   genutiltypes.ModuleName,
       Config: appconfig.WrapAny(&genutilmodulev1.Module{
   }),
   },
   			{
       Name:   authz.ModuleName,
       Config: appconfig.WrapAny(&authzmodulev1.Module{
   }),
   },
   			{
       Name:   upgradetypes.ModuleName,
       Config: appconfig.WrapAny(&upgrademodulev1.Module{
   }),
   },
   			{
       Name:   distrtypes.ModuleName,
       Config: appconfig.WrapAny(&distrmodulev1.Module{
   }),
   },
   			{
       Name:   evidencetypes.ModuleName,
       Config: appconfig.WrapAny(&evidencemodulev1.Module{
   }),
   },
   			{
       Name:   minttypes.ModuleName,
       Config: appconfig.WrapAny(&mintmodulev1.Module{
   }),
   },
   			{
       Name: group.ModuleName,
       Config: appconfig.WrapAny(&groupmodulev1.Module{
       MaxExecutionPeriod: durationpb.New(time.Second * 1209600),
       MaxMetadataLen:     255,
   }),
   },
   			{
       Name:   nft.ModuleName,
       Config: appconfig.WrapAny(&nftmodulev1.Module{
   }),
   },
   			{
       Name:   feegrant.ModuleName,
       Config: appconfig.WrapAny(&feegrantmodulev1.Module{
   }),
   },
   			{
       Name:   govtypes.ModuleName,
       Config: appconfig.WrapAny(&govmodulev1.Module{
   }),
   },
   			{
       Name:   crisistypes.ModuleName,
       Config: appconfig.WrapAny(&crisismodulev1.Module{
   }),
   },
   			{
       Name:   consensustypes.ModuleName,
       Config: appconfig.WrapAny(&consensusmodulev1.Module{
   }),
   },
   			{
       Name:   circuittypes.ModuleName,
       Config: appconfig.WrapAny(&circuitmodulev1.Module{
   }),
   },
   },
   }),
   		depinject.Supply(
   			// supply custom module basics
   			map[string]module.AppModuleBasic{
       genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),
   				govtypes.ModuleName: gov.NewAppModuleBasic(
   					[]govclient.ProposalHandler{
       paramsclient.ProposalHandler,
   },
   				),
   },
   		))
   )
   ```

3. Configure the modules defined in the `PreBlocker`, `BeginBlocker` and `EndBlocker` and the `tx` module:

   ```go expandable
   package simapp

   import (
       
   	"time"
       "google.golang.org/protobuf/types/known/durationpb"

   	runtimev1alpha1 "cosmossdk.io/api/cosmos/app/runtime/v1alpha1"
   	appv1alpha1 "cosmossdk.io/api/cosmos/app/v1alpha1"
   	authmodulev1 "cosmossdk.io/api/cosmos/auth/module/v1"
   	authzmodulev1 "cosmossdk.io/api/cosmos/authz/module/v1"
   	bankmodulev1 "cosmossdk.io/api/cosmos/bank/module/v1"
   	circuitmodulev1 "cosmossdk.io/api/cosmos/circuit/module/v1"
   	consensusmodulev1 "cosmossdk.io/api/cosmos/consensus/module/v1"
   	crisismodulev1 "cosmossdk.io/api/cosmos/crisis/module/v1"
   	distrmodulev1 "cosmossdk.io/api/cosmos/distribution/module/v1"
   	evidencemodulev1 "cosmossdk.io/api/cosmos/evidence/module/v1"
   	feegrantmodulev1 "cosmossdk.io/api/cosmos/feegrant/module/v1"
   	genutilmodulev1 "cosmossdk.io/api/cosmos/genutil/module/v1"
   	govmodulev1 "cosmossdk.io/api/cosmos/gov/module/v1"
   	groupmodulev1 "cosmossdk.io/api/cosmos/group/module/v1"
   	mintmodulev1 "cosmossdk.io/api/cosmos/mint/module/v1"
   	nftmodulev1 "cosmossdk.io/api/cosmos/nft/module/v1"
   	paramsmodulev1 "cosmossdk.io/api/cosmos/params/module/v1"
   	slashingmodulev1 "cosmossdk.io/api/cosmos/slashing/module/v1"
   	stakingmodulev1 "cosmossdk.io/api/cosmos/staking/module/v1"
   	txconfigv1 "cosmossdk.io/api/cosmos/tx/config/v1"
   	upgrademodulev1 "cosmossdk.io/api/cosmos/upgrade/module/v1"
   	vestingmodulev1 "cosmossdk.io/api/cosmos/vesting/module/v1"
       "cosmossdk.io/depinject"

   	_ "cosmossdk.io/x/circuit"                        // import for side-effects
   	_ "cosmossdk.io/x/evidence"                       // import for side-effects
   	_ "cosmossdk.io/x/feegrant/module"                // import for side-effects
   	_ "cosmossdk.io/x/nft/module"                     // import for side-effects
   	_ "cosmossdk.io/x/upgrade"                        // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/tx/config" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/vesting"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/authz/module"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/bank"           // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/consensus"      // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/crisis"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/distribution"   // import for side-effects
   	"github.com/cosmos/cosmos-sdk/x/genutil"
       "github.com/cosmos/cosmos-sdk/x/gov"
   	_ "github.com/cosmos/cosmos-sdk/x/group/module" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/mint"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/params"       // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/slashing"     // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/staking"      // import for side-effects

   	"cosmossdk.io/core/appconfig"
   	circuittypes "cosmossdk.io/x/circuit/types"
   	evidencetypes "cosmossdk.io/x/evidence/types"
       "cosmossdk.io/x/feegrant"
       "cosmossdk.io/x/nft"
   	upgradetypes "cosmossdk.io/x/upgrade/types"
       "github.com/cosmos/cosmos-sdk/runtime"
       "github.com/cosmos/cosmos-sdk/types/module"
   	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
   	vestingtypes "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
       "github.com/cosmos/cosmos-sdk/x/authz"
   	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
   	consensustypes "github.com/cosmos/cosmos-sdk/x/consensus/types"
   	crisistypes "github.com/cosmos/cosmos-sdk/x/crisis/types"
   	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
   	genutiltypes "github.com/cosmos/cosmos-sdk/x/genutil/types"
   	govclient "github.com/cosmos/cosmos-sdk/x/gov/client"
   	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
       "github.com/cosmos/cosmos-sdk/x/group"
   	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
   	paramsclient "github.com/cosmos/cosmos-sdk/x/params/client"
   	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
   	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
   	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
   )

   var (
   	// module account permissions
   	moduleAccPerms = []*authmodulev1.ModuleAccountPermission{
   		{
       Account: authtypes.FeeCollectorName
   },
   		{
       Account: distrtypes.ModuleName
   },
   		{
       Account: minttypes.ModuleName,
       Permissions: []string{
       authtypes.Minter
   }},
   		{
       Account: stakingtypes.BondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: stakingtypes.NotBondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: govtypes.ModuleName,
       Permissions: []string{
       authtypes.Burner
   }},
   		{
       Account: nft.ModuleName
   },
   }

   	// blocked account addresses
   	blockAccAddrs = []string{
       authtypes.FeeCollectorName,
   		distrtypes.ModuleName,
   		minttypes.ModuleName,
   		stakingtypes.BondedPoolName,
   		stakingtypes.NotBondedPoolName,
   		nft.ModuleName,
   		// We allow the following module accounts to receive funds:
   		// govtypes.ModuleName
   }

   	// application configuration (used by depinject)

   AppConfig = depinject.Configs(appconfig.Compose(&appv1alpha1.Config{
       Modules: []*appv1alpha1.ModuleConfig{
   			{
       Name: runtime.ModuleName,
       Config: appconfig.WrapAny(&runtimev1alpha1.Module{
       AppName: "SimApp",
   					// During begin block slashing happens after distr.BeginBlocker so that
   					// there is nothing left over in the validator fee pool, so as to keep the
   					// CanWithdrawInvariant invariant.
   					// NOTE: staking module is required if HistoricalEntries param > 0
   					BeginBlockers: []string{
       upgradetypes.ModuleName,
   						minttypes.ModuleName,
   						distrtypes.ModuleName,
   						slashingtypes.ModuleName,
   						evidencetypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						authz.ModuleName,
   },
       EndBlockers: []string{
       crisistypes.ModuleName,
   						govtypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						feegrant.ModuleName,
   						group.ModuleName,
   },
       OverrideStoreKeys: []*runtimev1alpha1.StoreKeyConfig{
   						{
       ModuleName: authtypes.ModuleName,
       KvStoreKey: "acc",
   },
   },
   					// NOTE: The genutils module must occur after staking so that pools are
   					// properly initialized with tokens from genesis accounts.
   					// NOTE: The genutils module must also occur after auth so that it can access the params from auth.
   					InitGenesis: []string{
       authtypes.ModuleName,
   						banktypes.ModuleName,
   						distrtypes.ModuleName,
   						stakingtypes.ModuleName,
   						slashingtypes.ModuleName,
   						govtypes.ModuleName,
   						minttypes.ModuleName,
   						crisistypes.ModuleName,
   						genutiltypes.ModuleName,
   						evidencetypes.ModuleName,
   						authz.ModuleName,
   						feegrant.ModuleName,
   						nft.ModuleName,
   						group.ModuleName,
   						paramstypes.ModuleName,
   						upgradetypes.ModuleName,
   						vestingtypes.ModuleName,
   						consensustypes.ModuleName,
   						circuittypes.ModuleName,
   },
   					// When ExportGenesis is not specified, the export genesis module order
   					// is equal to the init genesis order
   					// ExportGenesis: []string{
   },
   					// Uncomment if you want to set a custom migration order here.
   					// OrderMigrations: []string{
   },
   }),
   },
   			{
       Name: authtypes.ModuleName,
       Config: appconfig.WrapAny(&authmodulev1.Module{
       Bech32Prefix:             "cosmos",
       ModuleAccountPermissions: moduleAccPerms,
   					// By default modules authority is the governance module. This is configurable with the following:
   					// Authority: "group", // A custom module authority can be set using a module name
   					// Authority: "cosmos1cwwv22j5ca08ggdv9c2uky355k908694z577tv", // or a specific address
   }),
   },
   			{
       Name:   vestingtypes.ModuleName,
       Config: appconfig.WrapAny(&vestingmodulev1.Module{
   }),
   },
   			{
       Name: banktypes.ModuleName,
       Config: appconfig.WrapAny(&bankmodulev1.Module{
       BlockedModuleAccountsOverride: blockAccAddrs,
   }),
   },
   			{
       Name:   stakingtypes.ModuleName,
       Config: appconfig.WrapAny(&stakingmodulev1.Module{
   }),
   },
   			{
       Name:   slashingtypes.ModuleName,
       Config: appconfig.WrapAny(&slashingmodulev1.Module{
   }),
   },
   			{
       Name:   paramstypes.ModuleName,
       Config: appconfig.WrapAny(&paramsmodulev1.Module{
   }),
   },
   			{
       Name:   "tx",
       Config: appconfig.WrapAny(&txconfigv1.Config{
   }),
   },
   			{
       Name:   genutiltypes.ModuleName,
       Config: appconfig.WrapAny(&genutilmodulev1.Module{
   }),
   },
   			{
       Name:   authz.ModuleName,
       Config: appconfig.WrapAny(&authzmodulev1.Module{
   }),
   },
   			{
       Name:   upgradetypes.ModuleName,
       Config: appconfig.WrapAny(&upgrademodulev1.Module{
   }),
   },
   			{
       Name:   distrtypes.ModuleName,
       Config: appconfig.WrapAny(&distrmodulev1.Module{
   }),
   },
   			{
       Name:   evidencetypes.ModuleName,
       Config: appconfig.WrapAny(&evidencemodulev1.Module{
   }),
   },
   			{
       Name:   minttypes.ModuleName,
       Config: appconfig.WrapAny(&mintmodulev1.Module{
   }),
   },
   			{
       Name: group.ModuleName,
       Config: appconfig.WrapAny(&groupmodulev1.Module{
       MaxExecutionPeriod: durationpb.New(time.Second * 1209600),
       MaxMetadataLen:     255,
   }),
   },
   			{
       Name:   nft.ModuleName,
       Config: appconfig.WrapAny(&nftmodulev1.Module{
   }),
   },
   			{
       Name:   feegrant.ModuleName,
       Config: appconfig.WrapAny(&feegrantmodulev1.Module{
   }),
   },
   			{
       Name:   govtypes.ModuleName,
       Config: appconfig.WrapAny(&govmodulev1.Module{
   }),
   },
   			{
       Name:   crisistypes.ModuleName,
       Config: appconfig.WrapAny(&crisismodulev1.Module{
   }),
   },
   			{
       Name:   consensustypes.ModuleName,
       Config: appconfig.WrapAny(&consensusmodulev1.Module{
   }),
   },
   			{
       Name:   circuittypes.ModuleName,
       Config: appconfig.WrapAny(&circuitmodulev1.Module{
   }),
   },
   },
   }),
   		depinject.Supply(
   			// supply custom module basics
   			map[string]module.AppModuleBasic{
       genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),
   				govtypes.ModuleName: gov.NewAppModuleBasic(
   					[]govclient.ProposalHandler{
       paramsclient.ProposalHandler,
   },
   				),
   },
   		))
   )
   ```

   ```go expandable
   package simapp

   import (
       
   	"time"
       "google.golang.org/protobuf/types/known/durationpb"

   	runtimev1alpha1 "cosmossdk.io/api/cosmos/app/runtime/v1alpha1"
   	appv1alpha1 "cosmossdk.io/api/cosmos/app/v1alpha1"
   	authmodulev1 "cosmossdk.io/api/cosmos/auth/module/v1"
   	authzmodulev1 "cosmossdk.io/api/cosmos/authz/module/v1"
   	bankmodulev1 "cosmossdk.io/api/cosmos/bank/module/v1"
   	circuitmodulev1 "cosmossdk.io/api/cosmos/circuit/module/v1"
   	consensusmodulev1 "cosmossdk.io/api/cosmos/consensus/module/v1"
   	crisismodulev1 "cosmossdk.io/api/cosmos/crisis/module/v1"
   	distrmodulev1 "cosmossdk.io/api/cosmos/distribution/module/v1"
   	evidencemodulev1 "cosmossdk.io/api/cosmos/evidence/module/v1"
   	feegrantmodulev1 "cosmossdk.io/api/cosmos/feegrant/module/v1"
   	genutilmodulev1 "cosmossdk.io/api/cosmos/genutil/module/v1"
   	govmodulev1 "cosmossdk.io/api/cosmos/gov/module/v1"
   	groupmodulev1 "cosmossdk.io/api/cosmos/group/module/v1"
   	mintmodulev1 "cosmossdk.io/api/cosmos/mint/module/v1"
   	nftmodulev1 "cosmossdk.io/api/cosmos/nft/module/v1"
   	paramsmodulev1 "cosmossdk.io/api/cosmos/params/module/v1"
   	slashingmodulev1 "cosmossdk.io/api/cosmos/slashing/module/v1"
   	stakingmodulev1 "cosmossdk.io/api/cosmos/staking/module/v1"
   	txconfigv1 "cosmossdk.io/api/cosmos/tx/config/v1"
   	upgrademodulev1 "cosmossdk.io/api/cosmos/upgrade/module/v1"
   	vestingmodulev1 "cosmossdk.io/api/cosmos/vesting/module/v1"
       "cosmossdk.io/depinject"

   	_ "cosmossdk.io/x/circuit"                        // import for side-effects
   	_ "cosmossdk.io/x/evidence"                       // import for side-effects
   	_ "cosmossdk.io/x/feegrant/module"                // import for side-effects
   	_ "cosmossdk.io/x/nft/module"                     // import for side-effects
   	_ "cosmossdk.io/x/upgrade"                        // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/tx/config" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/auth/vesting"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/authz/module"   // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/bank"           // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/consensus"      // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/crisis"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/distribution"   // import for side-effects
   	"github.com/cosmos/cosmos-sdk/x/genutil"
       "github.com/cosmos/cosmos-sdk/x/gov"
   	_ "github.com/cosmos/cosmos-sdk/x/group/module" // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/mint"         // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/params"       // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/slashing"     // import for side-effects
   	_ "github.com/cosmos/cosmos-sdk/x/staking"      // import for side-effects

   	"cosmossdk.io/core/appconfig"
   	circuittypes "cosmossdk.io/x/circuit/types"
   	evidencetypes "cosmossdk.io/x/evidence/types"
       "cosmossdk.io/x/feegrant"
       "cosmossdk.io/x/nft"
   	upgradetypes "cosmossdk.io/x/upgrade/types"
       "github.com/cosmos/cosmos-sdk/runtime"
       "github.com/cosmos/cosmos-sdk/types/module"
   	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
   	vestingtypes "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
       "github.com/cosmos/cosmos-sdk/x/authz"
   	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
   	consensustypes "github.com/cosmos/cosmos-sdk/x/consensus/types"
   	crisistypes "github.com/cosmos/cosmos-sdk/x/crisis/types"
   	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
   	genutiltypes "github.com/cosmos/cosmos-sdk/x/genutil/types"
   	govclient "github.com/cosmos/cosmos-sdk/x/gov/client"
   	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
       "github.com/cosmos/cosmos-sdk/x/group"
   	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
   	paramsclient "github.com/cosmos/cosmos-sdk/x/params/client"
   	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
   	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
   	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
   )

   var (
   	// module account permissions
   	moduleAccPerms = []*authmodulev1.ModuleAccountPermission{
   		{
       Account: authtypes.FeeCollectorName
   },
   		{
       Account: distrtypes.ModuleName
   },
   		{
       Account: minttypes.ModuleName,
       Permissions: []string{
       authtypes.Minter
   }},
   		{
       Account: stakingtypes.BondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: stakingtypes.NotBondedPoolName,
       Permissions: []string{
       authtypes.Burner, stakingtypes.ModuleName
   }},
   		{
       Account: govtypes.ModuleName,
       Permissions: []string{
       authtypes.Burner
   }},
   		{
       Account: nft.ModuleName
   },
   }

   	// blocked account addresses
   	blockAccAddrs = []string{
       authtypes.FeeCollectorName,
   		distrtypes.ModuleName,
   		minttypes.ModuleName,
   		stakingtypes.BondedPoolName,
   		stakingtypes.NotBondedPoolName,
   		nft.ModuleName,
   		// We allow the following module accounts to receive funds:
   		// govtypes.ModuleName
   }

   	// application configuration (used by depinject)

   AppConfig = depinject.Configs(appconfig.Compose(&appv1alpha1.Config{
       Modules: []*appv1alpha1.ModuleConfig{
   			{
       Name: runtime.ModuleName,
       Config: appconfig.WrapAny(&runtimev1alpha1.Module{
       AppName: "SimApp",
   					// During begin block slashing happens after distr.BeginBlocker so that
   					// there is nothing left over in the validator fee pool, so as to keep the
   					// CanWithdrawInvariant invariant.
   					// NOTE: staking module is required if HistoricalEntries param > 0
   					BeginBlockers: []string{
       upgradetypes.ModuleName,
   						minttypes.ModuleName,
   						distrtypes.ModuleName,
   						slashingtypes.ModuleName,
   						evidencetypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						authz.ModuleName,
   },
       EndBlockers: []string{
       crisistypes.ModuleName,
   						govtypes.ModuleName,
   						stakingtypes.ModuleName,
   						genutiltypes.ModuleName,
   						feegrant.ModuleName,
   						group.ModuleName,
   },
       OverrideStoreKeys: []*runtimev1alpha1.StoreKeyConfig{
   						{
       ModuleName: authtypes.ModuleName,
       KvStoreKey: "acc",
   },
   },
   					// NOTE: The genutils module must occur after staking so that pools are
   					// properly initialized with tokens from genesis accounts.
   					// NOTE: The genutils module must also occur after auth so that it can access the params from auth.
   					InitGenesis: []string{
       authtypes.ModuleName,
   						banktypes.ModuleName,
   						distrtypes.ModuleName,
   						stakingtypes.ModuleName,
   						slashingtypes.ModuleName,
   						govtypes.ModuleName,
   						minttypes.ModuleName,
   						crisistypes.ModuleName,
   						genutiltypes.ModuleName,
   						evidencetypes.ModuleName,
   						authz.ModuleName,
   						feegrant.ModuleName,
   						nft.ModuleName,
   						group.ModuleName,
   						paramstypes.ModuleName,
   						upgradetypes.ModuleName,
   						vestingtypes.ModuleName,
   						consensustypes.ModuleName,
   						circuittypes.ModuleName,
   },
   					// When ExportGenesis is not specified, the export genesis module order
   					// is equal to the init genesis order
   					// ExportGenesis: []string{
   },
   					// Uncomment if you want to set a custom migration order here.
   					// OrderMigrations: []string{
   },
   }),
   },
   			{
       Name: authtypes.ModuleName,
       Config: appconfig.WrapAny(&authmodulev1.Module{
       Bech32Prefix:             "cosmos",
       ModuleAccountPermissions: moduleAccPerms,
   					// By default modules authority is the governance module. This is configurable with the following:
   					// Authority: "group", // A custom module authority can be set using a module name
   					// Authority: "cosmos1cwwv22j5ca08ggdv9c2uky355k908694z577tv", // or a specific address
   }),
   },
   			{
       Name:   vestingtypes.ModuleName,
       Config: appconfig.WrapAny(&vestingmodulev1.Module{
   }),
   },
   			{
       Name: banktypes.ModuleName,
       Config: appconfig.WrapAny(&bankmodulev1.Module{
       BlockedModuleAccountsOverride: blockAccAddrs,
   }),
   },
   			{
       Name:   stakingtypes.ModuleName,
       Config: appconfig.WrapAny(&stakingmodulev1.Module{
   }),
   },
   			{
       Name:   slashingtypes.ModuleName,
       Config: appconfig.WrapAny(&slashingmodulev1.Module{
   }),
   },
   			{
       Name:   paramstypes.ModuleName,
       Config: appconfig.WrapAny(&paramsmodulev1.Module{
   }),
   },
   			{
       Name:   "tx",
       Config: appconfig.WrapAny(&txconfigv1.Config{
   }),
   },
   			{
       Name:   genutiltypes.ModuleName,
       Config: appconfig.WrapAny(&genutilmodulev1.Module{
   }),
   },
   			{
       Name:   authz.ModuleName,
       Config: appconfig.WrapAny(&authzmodulev1.Module{
   }),
   },
   			{
       Name:   upgradetypes.ModuleName,
       Config: appconfig.WrapAny(&upgrademodulev1.Module{
   }),
   },
   			{
       Name:   distrtypes.ModuleName,
       Config: appconfig.WrapAny(&distrmodulev1.Module{
   }),
   },
   			{
       Name:   evidencetypes.ModuleName,
       Config: appconfig.WrapAny(&evidencemodulev1.Module{
   }),
   },
   			{
       Name:   minttypes.ModuleName,
       Config: appconfig.WrapAny(&mintmodulev1.Module{
   }),
   },
   			{
       Name: group.ModuleName,
       Config: appconfig.WrapAny(&groupmodulev1.Module{
       MaxExecutionPeriod: durationpb.New(time.Second * 1209600),
       MaxMetadataLen:     255,
   }),
   },
   			{
       Name:   nft.ModuleName,
       Config: appconfig.WrapAny(&nftmodulev1.Module{
   }),
   },
   			{
       Name:   feegrant.ModuleName,
       Config: appconfig.WrapAny(&feegrantmodulev1.Module{
   }),
   },
   			{
       Name:   govtypes.ModuleName,
       Config: appconfig.WrapAny(&govmodulev1.Module{
   }),
   },
   			{
       Name:   crisistypes.ModuleName,
       Config: appconfig.WrapAny(&crisismodulev1.Module{
   }),
   },
   			{
       Name:   consensustypes.ModuleName,
       Config: appconfig.WrapAny(&consensusmodulev1.Module{
   }),
   },
   			{
       Name:   circuittypes.ModuleName,
       Config: appconfig.WrapAny(&circuitmodulev1.Module{
   }),
   },
   },
   }),
   		depinject.Supply(
   			// supply custom module basics
   			map[string]module.AppModuleBasic{
       genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),
   				govtypes.ModuleName: gov.NewAppModuleBasic(
   					[]govclient.ProposalHandler{
       paramsclient.ProposalHandler,
   },
   				),
   },
   		))
   )
   ```

### Complete `app_config.go`

```go expandable
package simapp

import (
    
	"time"
    "google.golang.org/protobuf/types/known/durationpb"

	runtimev1alpha1 "cosmossdk.io/api/cosmos/app/runtime/v1alpha1"
	appv1alpha1 "cosmossdk.io/api/cosmos/app/v1alpha1"
	authmodulev1 "cosmossdk.io/api/cosmos/auth/module/v1"
	authzmodulev1 "cosmossdk.io/api/cosmos/authz/module/v1"
	bankmodulev1 "cosmossdk.io/api/cosmos/bank/module/v1"
	circuitmodulev1 "cosmossdk.io/api/cosmos/circuit/module/v1"
	consensusmodulev1 "cosmossdk.io/api/cosmos/consensus/module/v1"
	crisismodulev1 "cosmossdk.io/api/cosmos/crisis/module/v1"
	distrmodulev1 "cosmossdk.io/api/cosmos/distribution/module/v1"
	evidencemodulev1 "cosmossdk.io/api/cosmos/evidence/module/v1"
	feegrantmodulev1 "cosmossdk.io/api/cosmos/feegrant/module/v1"
	genutilmodulev1 "cosmossdk.io/api/cosmos/genutil/module/v1"
	govmodulev1 "cosmossdk.io/api/cosmos/gov/module/v1"
	groupmodulev1 "cosmossdk.io/api/cosmos/group/module/v1"
	mintmodulev1 "cosmossdk.io/api/cosmos/mint/module/v1"
	nftmodulev1 "cosmossdk.io/api/cosmos/nft/module/v1"
	paramsmodulev1 "cosmossdk.io/api/cosmos/params/module/v1"
	slashingmodulev1 "cosmossdk.io/api/cosmos/slashing/module/v1"
	stakingmodulev1 "cosmossdk.io/api/cosmos/staking/module/v1"
	txconfigv1 "cosmossdk.io/api/cosmos/tx/config/v1"
	upgrademodulev1 "cosmossdk.io/api/cosmos/upgrade/module/v1"
	vestingmodulev1 "cosmossdk.io/api/cosmos/vesting/module/v1"
    "cosmossdk.io/depinject"

	_ "cosmossdk.io/x/circuit"                        // import for side-effects
	_ "cosmossdk.io/x/evidence"                       // import for side-effects
	_ "cosmossdk.io/x/feegrant/module"                // import for side-effects
	_ "cosmossdk.io/x/nft/module"                     // import for side-effects
	_ "cosmossdk.io/x/upgrade"                        // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/auth/tx/config" // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/auth/vesting"   // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/authz/module"   // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/bank"           // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/consensus"      // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/crisis"         // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/distribution"   // import for side-effects
	"github.com/cosmos/cosmos-sdk/x/genutil"
    "github.com/cosmos/cosmos-sdk/x/gov"
	_ "github.com/cosmos/cosmos-sdk/x/group/module" // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/mint"         // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/params"       // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/slashing"     // import for side-effects
	_ "github.com/cosmos/cosmos-sdk/x/staking"      // import for side-effects

	"cosmossdk.io/core/appconfig"
	circuittypes "cosmossdk.io/x/circuit/types"
	evidencetypes "cosmossdk.io/x/evidence/types"
    "cosmossdk.io/x/feegrant"
    "cosmossdk.io/x/nft"
	upgradetypes "cosmossdk.io/x/upgrade/types"
    "github.com/cosmos/cosmos-sdk/runtime"
    "github.com/cosmos/cosmos-sdk/types/module"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	vestingtypes "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
    "github.com/cosmos/cosmos-sdk/x/authz"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	consensustypes "github.com/cosmos/cosmos-sdk/x/consensus/types"
	crisistypes "github.com/cosmos/cosmos-sdk/x/crisis/types"
	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
	genutiltypes "github.com/cosmos/cosmos-sdk/x/genutil/types"
	govclient "github.com/cosmos/cosmos-sdk/x/gov/client"
	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
    "github.com/cosmos/cosmos-sdk/x/group"
	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
	paramsclient "github.com/cosmos/cosmos-sdk/x/params/client"
	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

var (
	// module account permissions
	moduleAccPerms = []*authmodulev1.ModuleAccountPermission{
		{
    Account: authtypes.FeeCollectorName
},
		{
    Account: distrtypes.ModuleName
},
		{
    Account: minttypes.ModuleName,
    Permissions: []string{
    authtypes.Minter
}},
		{
    Account: stakingtypes.BondedPoolName,
    Permissions: []string{
    authtypes.Burner, stakingtypes.ModuleName
}},
		{
    Account: stakingtypes.NotBondedPoolName,
    Permissions: []string{
    authtypes.Burner, stakingtypes.ModuleName
}},
		{
    Account: govtypes.ModuleName,
    Permissions: []string{
    authtypes.Burner
}},
		{
    Account: nft.ModuleName
},
}

	// blocked account addresses
	blockAccAddrs = []string{
    authtypes.FeeCollectorName,
		distrtypes.ModuleName,
		minttypes.ModuleName,
		stakingtypes.BondedPoolName,
		stakingtypes.NotBondedPoolName,
		nft.ModuleName,
		// We allow the following module accounts to receive funds:
		// govtypes.ModuleName
}

	// application configuration (used by depinject)

AppConfig = depinject.Configs(appconfig.Compose(&appv1alpha1.Config{
    Modules: []*appv1alpha1.ModuleConfig{
			{
    Name: runtime.ModuleName,
    Config: appconfig.WrapAny(&runtimev1alpha1.Module{
    AppName: "SimApp",
					// During begin block slashing happens after distr.BeginBlocker so that
					// there is nothing left over in the validator fee pool, so as to keep the
					// CanWithdrawInvariant invariant.
					// NOTE: staking module is required if HistoricalEntries param > 0
					BeginBlockers: []string{
    upgradetypes.ModuleName,
						minttypes.ModuleName,
						distrtypes.ModuleName,
						slashingtypes.ModuleName,
						evidencetypes.ModuleName,
						stakingtypes.ModuleName,
						genutiltypes.ModuleName,
						authz.ModuleName,
},
    EndBlockers: []string{
    crisistypes.ModuleName,
						govtypes.ModuleName,
						stakingtypes.ModuleName,
						genutiltypes.ModuleName,
						feegrant.ModuleName,
						group.ModuleName,
},
    OverrideStoreKeys: []*runtimev1alpha1.StoreKeyConfig{
						{
    ModuleName: authtypes.ModuleName,
    KvStoreKey: "acc",
},
},
					// NOTE: The genutils module must occur after staking so that pools are
					// properly initialized with tokens from genesis accounts.
					// NOTE: The genutils module must also occur after auth so that it can access the params from auth.
					InitGenesis: []string{
    authtypes.ModuleName,
						banktypes.ModuleName,
						distrtypes.ModuleName,
						stakingtypes.ModuleName,
						slashingtypes.ModuleName,
						govtypes.ModuleName,
						minttypes.ModuleName,
						crisistypes.ModuleName,
						genutiltypes.ModuleName,
						evidencetypes.ModuleName,
						authz.ModuleName,
						feegrant.ModuleName,
						nft.ModuleName,
						group.ModuleName,
						paramstypes.ModuleName,
						upgradetypes.ModuleName,
						vestingtypes.ModuleName,
						consensustypes.ModuleName,
						circuittypes.ModuleName,
},
					// When ExportGenesis is not specified, the export genesis module order
					// is equal to the init genesis order
					// ExportGenesis: []string{
},
					// Uncomment if you want to set a custom migration order here.
					// OrderMigrations: []string{
},
}),
},
			{
    Name: authtypes.ModuleName,
    Config: appconfig.WrapAny(&authmodulev1.Module{
    Bech32Prefix:             "cosmos",
    ModuleAccountPermissions: moduleAccPerms,
					// By default modules authority is the governance module. This is configurable with the following:
					// Authority: "group", // A custom module authority can be set using a module name
					// Authority: "cosmos1cwwv22j5ca08ggdv9c2uky355k908694z577tv", // or a specific address
}),
},
			{
    Name:   vestingtypes.ModuleName,
    Config: appconfig.WrapAny(&vestingmodulev1.Module{
}),
},
			{
    Name: banktypes.ModuleName,
    Config: appconfig.WrapAny(&bankmodulev1.Module{
    BlockedModuleAccountsOverride: blockAccAddrs,
}),
},
			{
    Name:   stakingtypes.ModuleName,
    Config: appconfig.WrapAny(&stakingmodulev1.Module{
}),
},
			{
    Name:   slashingtypes.ModuleName,
    Config: appconfig.WrapAny(&slashingmodulev1.Module{
}),
},
			{
    Name:   paramstypes.ModuleName,
    Config: appconfig.WrapAny(&paramsmodulev1.Module{
}),
},
			{
    Name:   "tx",
    Config: appconfig.WrapAny(&txconfigv1.Config{
}),
},
			{
    Name:   genutiltypes.ModuleName,
    Config: appconfig.WrapAny(&genutilmodulev1.Module{
}),
},
			{
    Name:   authz.ModuleName,
    Config: appconfig.WrapAny(&authzmodulev1.Module{
}),
},
			{
    Name:   upgradetypes.ModuleName,
    Config: appconfig.WrapAny(&upgrademodulev1.Module{
}),
},
			{
    Name:   distrtypes.ModuleName,
    Config: appconfig.WrapAny(&distrmodulev1.Module{
}),
},
			{
    Name:   evidencetypes.ModuleName,
    Config: appconfig.WrapAny(&evidencemodulev1.Module{
}),
},
			{
    Name:   minttypes.ModuleName,
    Config: appconfig.WrapAny(&mintmodulev1.Module{
}),
},
			{
    Name: group.ModuleName,
    Config: appconfig.WrapAny(&groupmodulev1.Module{
    MaxExecutionPeriod: durationpb.New(time.Second * 1209600),
    MaxMetadataLen:     255,
}),
},
			{
    Name:   nft.ModuleName,
    Config: appconfig.WrapAny(&nftmodulev1.Module{
}),
},
			{
    Name:   feegrant.ModuleName,
    Config: appconfig.WrapAny(&feegrantmodulev1.Module{
}),
},
			{
    Name:   govtypes.ModuleName,
    Config: appconfig.WrapAny(&govmodulev1.Module{
}),
},
			{
    Name:   crisistypes.ModuleName,
    Config: appconfig.WrapAny(&crisismodulev1.Module{
}),
},
			{
    Name:   consensustypes.ModuleName,
    Config: appconfig.WrapAny(&consensusmodulev1.Module{
}),
},
			{
    Name:   circuittypes.ModuleName,
    Config: appconfig.WrapAny(&circuitmodulev1.Module{
}),
},
},
}),
		depinject.Supply(
			// supply custom module basics
			map[string]module.AppModuleBasic{
    genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),
				govtypes.ModuleName: gov.NewAppModuleBasic(
					[]govclient.ProposalHandler{
    paramsclient.ProposalHandler,
},
				),
},
		))
)
```

### Alternative formats

<Tip>
The example above shows how to create an `AppConfig` using Go. However, it is also possible to create an `AppConfig` using YAML, or JSON.\
The configuration can then be embed with `go:embed` and read with [`appconfig.LoadYAML`](https://pkg.go.dev/cosmossdk.io/core/appconfig#LoadYAML), or [`appconfig.LoadJSON`](https://pkg.go.dev/cosmossdk.io/core/appconfig#LoadJSON), in `app_v2.go`.

```go
//go:embed app_config.yaml
var (
    appConfigYaml []byte
    appConfig = appconfig.LoadYAML(appConfigYaml)
)
```

</Tip>

```yaml expandable
modules:
  - name: runtime
    config:
      "@type": cosmos.app.runtime.v1alpha1.Module
      app_name: SimApp
      begin_blockers: [staking, auth, bank]
      end_blockers: [bank, auth, staking]
      init_genesis: [bank, auth, staking]
  - name: auth
    config:
      "@type": cosmos.auth.module.v1.Module
      bech32_prefix: cosmos
  - name: bank
    config:
      "@type": cosmos.bank.module.v1.Module
  - name: staking
    config:
      "@type": cosmos.staking.module.v1.Module
  - name: tx
    config:
      "@type": cosmos.tx.module.v1.Module
```

A more complete example of `app.yaml` can be found [here](https://github.com/cosmos/cosmos-sdk/blob/91b1d83f1339e235a1dfa929ecc00084101a19e3/simapp/app.yaml).

## `app_v2.go`

`app_v2.go` is the place where `SimApp` is constructed. `depinject.Inject` facilitates that by automatically wiring the app modules and keepers, provided an application configuration `AppConfig` is provided. `SimApp` is constructed, when calling the injected `*runtime.AppBuilder`, with `appBuilder.Build(...)`.\
In short `depinject` and the [`runtime` package](https://pkg.go.dev/github.com/cosmos/cosmos-sdk/runtime) abstract the wiring of the app, and the `AppBuilder` is the place where the app is constructed. [`runtime`](https://pkg.go.dev/github.com/cosmos/cosmos-sdk/runtime) takes care of registering the codecs, KV store, subspaces and instantiating `baseapp`.

```go expandable
//go:build !app_v1

package simapp

import (
    
	"io"
    "os"
    "path/filepath"
    "cosmossdk.io/log"
	dbm "github.com/cosmos/cosmos-db"
    "cosmossdk.io/depinject"
	storetypes "cosmossdk.io/store/types"
	circuitkeeper "cosmossdk.io/x/circuit/keeper"
	evidencekeeper "cosmossdk.io/x/evidence/keeper"
	feegrantkeeper "cosmossdk.io/x/feegrant/keeper"
	nftkeeper "cosmossdk.io/x/nft/keeper"
	upgradekeeper "cosmossdk.io/x/upgrade/keeper"
    "github.com/cosmos/cosmos-sdk/baseapp"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/runtime"
    "github.com/cosmos/cosmos-sdk/server"
    "github.com/cosmos/cosmos-sdk/server/api"
    "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	testdata_pulsar "github.com/cosmos/cosmos-sdk/testutil/testdata/testpb"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/x/auth"
	authkeeper "github.com/cosmos/cosmos-sdk/x/auth/keeper"
	authsims "github.com/cosmos/cosmos-sdk/x/auth/simulation"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	authzkeeper "github.com/cosmos/cosmos-sdk/x/authz/keeper"
	bankkeeper "github.com/cosmos/cosmos-sdk/x/bank/keeper"
	consensuskeeper "github.com/cosmos/cosmos-sdk/x/consensus/keeper"
	crisiskeeper "github.com/cosmos/cosmos-sdk/x/crisis/keeper"
	distrkeeper "github.com/cosmos/cosmos-sdk/x/distribution/keeper"
	govkeeper "github.com/cosmos/cosmos-sdk/x/gov/keeper"
	groupkeeper "github.com/cosmos/cosmos-sdk/x/group/keeper"
	mintkeeper "github.com/cosmos/cosmos-sdk/x/mint/keeper"
	paramskeeper "github.com/cosmos/cosmos-sdk/x/params/keeper"
	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
	slashingkeeper "github.com/cosmos/cosmos-sdk/x/slashing/keeper"
	stakingkeeper "github.com/cosmos/cosmos-sdk/x/staking/keeper"
)

// DefaultNodeHome default home directories for the application daemon
var DefaultNodeHome string

var (
	_ runtime.AppI            = (*SimApp)(nil)
	_ servertypes.Application = (*SimApp)(nil)
)

// SimApp extends an ABCI application, but with most of its parameters exported.
// They are exported for convenience in creating helper functions, as object
// capabilities aren't needed for testing.
type SimApp struct {
	*runtime.App
	legacyAmino       *codec.LegacyAmino
	appCodec          codec.Codec
	txConfig          client.TxConfig
	interfaceRegistry codectypes.InterfaceRegistry

	// keepers
	AccountKeeper         authkeeper.AccountKeeper
	BankKeeper            bankkeeper.Keeper
	StakingKeeper         *stakingkeeper.Keeper
	SlashingKeeper        slashingkeeper.Keeper
	MintKeeper            mintkeeper.Keeper
	DistrKeeper           distrkeeper.Keeper
	GovKeeper             *govkeeper.Keeper
	CrisisKeeper          *crisiskeeper.Keeper
	UpgradeKeeper         *upgradekeeper.Keeper
	ParamsKeeper          paramskeeper.Keeper
	AuthzKeeper           authzkeeper.Keeper
	EvidenceKeeper        evidencekeeper.Keeper
	FeeGrantKeeper        feegrantkeeper.Keeper
	GroupKeeper           groupkeeper.Keeper
	NFTKeeper             nftkeeper.Keeper
	ConsensusParamsKeeper consensuskeeper.Keeper
	CircuitBreakerKeeper  circuitkeeper.Keeper

	// simulation manager
	sm *module.SimulationManager
}

func init() {
    userHomeDir, err := os.UserHomeDir()
    if err != nil {
    panic(err)
}

DefaultNodeHome = filepath.Join(userHomeDir, ".simapp")
}

// NewSimApp returns a reference to an initialized SimApp.
func NewSimApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	loadLatest bool,
	appOpts servertypes.AppOptions,
	baseAppOptions ...func(*baseapp.BaseApp),
) *SimApp {
    var (
		app        = &SimApp{
}

appBuilder *runtime.AppBuilder

		// merge the AppConfig and other configuration in one config
		appConfig = depinject.Configs(
			AppConfig,
			depinject.Supply(
				// supply the application options
				appOpts,
				// supply the logger
				logger,

				// ADVANCED CONFIGURATION

				//
				// AUTH
				//
				// For providing a custom function required in auth to generate custom account types
				// add it below. By default the auth module uses simulation.RandomGenesisAccounts.
				//
				// authtypes.RandomGenesisAccountsFn(simulation.RandomGenesisAccounts),

				// For providing a custom a base account type add it below.
				// By default the auth module uses authtypes.ProtoBaseAccount().
				//
				// func()

sdk.AccountI {
    return authtypes.ProtoBaseAccount()
},

				//
				// MINT
				//

				// For providing a custom inflation function for x/mint add here your
				// custom function that implements the minttypes.InflationCalculationFn
				// interface.
			),
		)
	)
    if err := depinject.Inject(appConfig,
		&appBuilder,
		&app.appCodec,
		&app.legacyAmino,
		&app.txConfig,
		&app.interfaceRegistry,
		&app.AccountKeeper,
		&app.BankKeeper,
		&app.StakingKeeper,
		&app.SlashingKeeper,
		&app.MintKeeper,
		&app.DistrKeeper,
		&app.GovKeeper,
		&app.CrisisKeeper,
		&app.UpgradeKeeper,
		&app.ParamsKeeper,
		&app.AuthzKeeper,
		&app.EvidenceKeeper,
		&app.FeeGrantKeeper,
		&app.GroupKeeper,
		&app.NFTKeeper,
		&app.ConsensusParamsKeeper,
		&app.CircuitBreakerKeeper,
	); err != nil {
    panic(err)
}

	// Below we could construct and set an application specific mempool and
	// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are
	// already set in the SDK's BaseApp, this shows an example of how to override
	// them.
	//
	// Example:
	//
	// app.App = appBuilder.Build(...)
	// nonceMempool := mempool.NewSenderNonceMempool()
	// abciPropHandler := NewDefaultProposalHandler(nonceMempool, app.App.BaseApp)
	//
	// app.App.BaseApp.SetMempool(nonceMempool)
	// app.App.BaseApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())
	// app.App.BaseApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())
	//
	// Alternatively, you can construct BaseApp options, append those to
	// baseAppOptions and pass them to the appBuilder.
	//
	// Example:
	//
	// prepareOpt = func(app *baseapp.BaseApp) {
	// 	abciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)
	// 	app.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())
	//
}
	// baseAppOptions = append(baseAppOptions, prepareOpt)

app.App = appBuilder.Build(db, traceStore, baseAppOptions...)

	// register streaming services
    if err := app.RegisterStreamingServices(appOpts, app.kvStoreKeys()); err != nil {
    panic(err)
}

	/****  Module Options ****/

	app.ModuleManager.RegisterInvariants(app.CrisisKeeper)

	// RegisterUpgradeHandlers is used for registering any on-chain upgrades.
	app.RegisterUpgradeHandlers()

	// add test gRPC service for testing gRPC queries in isolation
	testdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{
})

	// create the simulation manager and define the order of the modules for deterministic simulations
	//
	// NOTE: this is not required apps that don't use the simulator for fuzz testing
	// transactions
    overrideModules := map[string]module.AppModuleSimulation{
    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, app.GetSubspace(authtypes.ModuleName)),
}

app.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)

app.sm.RegisterStoreDecoders()

	// A custom InitChainer can be set if extra pre-init-genesis logic is required.
	// By default, when using app wiring enabled module, this is not required.
	// For instance, the upgrade module will set automatically the module version map in its init genesis thanks to app wiring.
	// However, when registering a module manually (i.e. that does not support app wiring), the module version map
	// must be set manually as follow. The upgrade module will de-duplicate the module version map.
	//
	// app.SetInitChainer(func(ctx sdk.Context, req abci.RequestInitChain)

abci.ResponseInitChain {
	// 	app.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())
	// 	return app.App.InitChainer(ctx, req)
	//
})
    if err := app.Load(loadLatest); err != nil {
    panic(err)
}

return app
}

// Name returns the name of the App
func (app *SimApp)

Name()

string {
    return app.BaseApp.Name()
}

// LegacyAmino returns SimApp's amino codec.
//
// NOTE: This is solely to be used for testing purposes as it may be desirable
// for modules to register their own custom testing types.
func (app *SimApp)

LegacyAmino() *codec.LegacyAmino {
    return app.legacyAmino
}

// AppCodec returns SimApp's app codec.
//
// NOTE: This is solely to be used for testing purposes as it may be desirable
// for modules to register their own custom testing types.
func (app *SimApp)

AppCodec()

codec.Codec {
    return app.appCodec
}

// InterfaceRegistry returns SimApp's InterfaceRegistry.
func (app *SimApp)

InterfaceRegistry()

codectypes.InterfaceRegistry {
    return app.interfaceRegistry
}

// TxConfig returns SimApp's TxConfig
func (app *SimApp)

TxConfig()

client.TxConfig {
    return app.txConfig
}

// GetKey returns the KVStoreKey for the provided store key.
//
// NOTE: This is solely to be used for testing purposes.
func (app *SimApp)

GetKey(storeKey string) *storetypes.KVStoreKey {
    sk := app.UnsafeFindStoreKey(storeKey)

kvStoreKey, ok := sk.(*storetypes.KVStoreKey)
    if !ok {
    return nil
}

return kvStoreKey
}

func (app *SimApp)

kvStoreKeys()

map[string]*storetypes.KVStoreKey {
    keys := make(map[string]*storetypes.KVStoreKey)
    for _, k := range app.GetStoreKeys() {
    if kv, ok := k.(*storetypes.KVStoreKey); ok {
    keys[kv.Name()] = kv
}
	
}

return keys
}

// GetSubspace returns a param subspace for a given module name.
//
// NOTE: This is solely to be used for testing purposes.
func (app *SimApp)

GetSubspace(moduleName string)

paramstypes.Subspace {
    subspace, _ := app.ParamsKeeper.GetSubspace(moduleName)

return subspace
}

// SimulationManager implements the SimulationApp interface
func (app *SimApp)

SimulationManager() *module.SimulationManager {
    return app.sm
}

// RegisterAPIRoutes registers all application module routes with the provided
// API server.
func (app *SimApp)

RegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {
    app.App.RegisterAPIRoutes(apiSvr, apiConfig)
	// register swagger API in app.go so that other applications can override easily
    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {
    panic(err)
}
}

// GetMaccPerms returns a copy of the module account permissions
//
// NOTE: This is solely to be used for testing purposes.
func GetMaccPerms()

map[string][]string {
    dup := make(map[string][]string)
    for _, perms := range moduleAccPerms {
    dup[perms.Account] = perms.Permissions
}

return dup
}

// BlockedAddresses returns all the app's blocked account addresses.
func BlockedAddresses()

map[string]bool {
    result := make(map[string]bool)
    if len(blockAccAddrs) > 0 {
    for _, addr := range blockAccAddrs {
    result[addr] = true
}
	
}

else {
    for addr := range GetMaccPerms() {
    result[addr] = true
}
	
}

return result
}
```

<Warning>
When using `depinject.Inject`, the injected types must be pointers.
</Warning>

### Advanced Configuration

In advanced cases, it is possible to inject extra (module) configuration in a way that is not (yet) supported by `AppConfig`.\
In this case, use `depinject.Configs` for combining the extra configuration and `AppConfig`, and `depinject.Supply` to providing that extra configuration.
More information on how work `depinject.Configs` and `depinject.Supply` can be found in the [`depinject` documentation](https://pkg.go.dev/cosmossdk.io/depinject).

```go expandable
//go:build !app_v1

package simapp

import (
    
	"io"
    "os"
    "path/filepath"
    "cosmossdk.io/log"
	dbm "github.com/cosmos/cosmos-db"
    "cosmossdk.io/depinject"
	storetypes "cosmossdk.io/store/types"
	circuitkeeper "cosmossdk.io/x/circuit/keeper"
	evidencekeeper "cosmossdk.io/x/evidence/keeper"
	feegrantkeeper "cosmossdk.io/x/feegrant/keeper"
	nftkeeper "cosmossdk.io/x/nft/keeper"
	upgradekeeper "cosmossdk.io/x/upgrade/keeper"
    "github.com/cosmos/cosmos-sdk/baseapp"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/runtime"
    "github.com/cosmos/cosmos-sdk/server"
    "github.com/cosmos/cosmos-sdk/server/api"
    "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	testdata_pulsar "github.com/cosmos/cosmos-sdk/testutil/testdata/testpb"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/x/auth"
	authkeeper "github.com/cosmos/cosmos-sdk/x/auth/keeper"
	authsims "github.com/cosmos/cosmos-sdk/x/auth/simulation"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	authzkeeper "github.com/cosmos/cosmos-sdk/x/authz/keeper"
	bankkeeper "github.com/cosmos/cosmos-sdk/x/bank/keeper"
	consensuskeeper "github.com/cosmos/cosmos-sdk/x/consensus/keeper"
	crisiskeeper "github.com/cosmos/cosmos-sdk/x/crisis/keeper"
	distrkeeper "github.com/cosmos/cosmos-sdk/x/distribution/keeper"
	govkeeper "github.com/cosmos/cosmos-sdk/x/gov/keeper"
	groupkeeper "github.com/cosmos/cosmos-sdk/x/group/keeper"
	mintkeeper "github.com/cosmos/cosmos-sdk/x/mint/keeper"
	paramskeeper "github.com/cosmos/cosmos-sdk/x/params/keeper"
	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
	slashingkeeper "github.com/cosmos/cosmos-sdk/x/slashing/keeper"
	stakingkeeper "github.com/cosmos/cosmos-sdk/x/staking/keeper"
)

// DefaultNodeHome default home directories for the application daemon
var DefaultNodeHome string

var (
	_ runtime.AppI            = (*SimApp)(nil)
	_ servertypes.Application = (*SimApp)(nil)
)

// SimApp extends an ABCI application, but with most of its parameters exported.
// They are exported for convenience in creating helper functions, as object
// capabilities aren't needed for testing.
type SimApp struct {
	*runtime.App
	legacyAmino       *codec.LegacyAmino
	appCodec          codec.Codec
	txConfig          client.TxConfig
	interfaceRegistry codectypes.InterfaceRegistry

	// keepers
	AccountKeeper         authkeeper.AccountKeeper
	BankKeeper            bankkeeper.Keeper
	StakingKeeper         *stakingkeeper.Keeper
	SlashingKeeper        slashingkeeper.Keeper
	MintKeeper            mintkeeper.Keeper
	DistrKeeper           distrkeeper.Keeper
	GovKeeper             *govkeeper.Keeper
	CrisisKeeper          *crisiskeeper.Keeper
	UpgradeKeeper         *upgradekeeper.Keeper
	ParamsKeeper          paramskeeper.Keeper
	AuthzKeeper           authzkeeper.Keeper
	EvidenceKeeper        evidencekeeper.Keeper
	FeeGrantKeeper        feegrantkeeper.Keeper
	GroupKeeper           groupkeeper.Keeper
	NFTKeeper             nftkeeper.Keeper
	ConsensusParamsKeeper consensuskeeper.Keeper
	CircuitBreakerKeeper  circuitkeeper.Keeper

	// simulation manager
	sm *module.SimulationManager
}

func init() {
    userHomeDir, err := os.UserHomeDir()
    if err != nil {
    panic(err)
}

DefaultNodeHome = filepath.Join(userHomeDir, ".simapp")
}

// NewSimApp returns a reference to an initialized SimApp.
func NewSimApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	loadLatest bool,
	appOpts servertypes.AppOptions,
	baseAppOptions ...func(*baseapp.BaseApp),
) *SimApp {
    var (
		app        = &SimApp{
}

appBuilder *runtime.AppBuilder

		// merge the AppConfig and other configuration in one config
		appConfig = depinject.Configs(
			AppConfig,
			depinject.Supply(
				// supply the application options
				appOpts,
				// supply the logger
				logger,

				// ADVANCED CONFIGURATION

				//
				// AUTH
				//
				// For providing a custom function required in auth to generate custom account types
				// add it below. By default the auth module uses simulation.RandomGenesisAccounts.
				//
				// authtypes.RandomGenesisAccountsFn(simulation.RandomGenesisAccounts),

				// For providing a custom a base account type add it below.
				// By default the auth module uses authtypes.ProtoBaseAccount().
				//
				// func()

sdk.AccountI {
    return authtypes.ProtoBaseAccount()
},

				//
				// MINT
				//

				// For providing a custom inflation function for x/mint add here your
				// custom function that implements the minttypes.InflationCalculationFn
				// interface.
			),
		)
	)
    if err := depinject.Inject(appConfig,
		&appBuilder,
		&app.appCodec,
		&app.legacyAmino,
		&app.txConfig,
		&app.interfaceRegistry,
		&app.AccountKeeper,
		&app.BankKeeper,
		&app.StakingKeeper,
		&app.SlashingKeeper,
		&app.MintKeeper,
		&app.DistrKeeper,
		&app.GovKeeper,
		&app.CrisisKeeper,
		&app.UpgradeKeeper,
		&app.ParamsKeeper,
		&app.AuthzKeeper,
		&app.EvidenceKeeper,
		&app.FeeGrantKeeper,
		&app.GroupKeeper,
		&app.NFTKeeper,
		&app.ConsensusParamsKeeper,
		&app.CircuitBreakerKeeper,
	); err != nil {
    panic(err)
}

	// Below we could construct and set an application specific mempool and
	// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are
	// already set in the SDK's BaseApp, this shows an example of how to override
	// them.
	//
	// Example:
	//
	// app.App = appBuilder.Build(...)
	// nonceMempool := mempool.NewSenderNonceMempool()
	// abciPropHandler := NewDefaultProposalHandler(nonceMempool, app.App.BaseApp)
	//
	// app.App.BaseApp.SetMempool(nonceMempool)
	// app.App.BaseApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())
	// app.App.BaseApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())
	//
	// Alternatively, you can construct BaseApp options, append those to
	// baseAppOptions and pass them to the appBuilder.
	//
	// Example:
	//
	// prepareOpt = func(app *baseapp.BaseApp) {
	// 	abciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)
	// 	app.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())
	//
}
	// baseAppOptions = append(baseAppOptions, prepareOpt)

app.App = appBuilder.Build(db, traceStore, baseAppOptions...)

	// register streaming services
    if err := app.RegisterStreamingServices(appOpts, app.kvStoreKeys()); err != nil {
    panic(err)
}

	/****  Module Options ****/

	app.ModuleManager.RegisterInvariants(app.CrisisKeeper)

	// RegisterUpgradeHandlers is used for registering any on-chain upgrades.
	app.RegisterUpgradeHandlers()

	// add test gRPC service for testing gRPC queries in isolation
	testdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{
})

	// create the simulation manager and define the order of the modules for deterministic simulations
	//
	// NOTE: this is not required apps that don't use the simulator for fuzz testing
	// transactions
    overrideModules := map[string]module.AppModuleSimulation{
    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, app.GetSubspace(authtypes.ModuleName)),
}

app.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)

app.sm.RegisterStoreDecoders()

	// A custom InitChainer can be set if extra pre-init-genesis logic is required.
	// By default, when using app wiring enabled module, this is not required.
	// For instance, the upgrade module will set automatically the module version map in its init genesis thanks to app wiring.
	// However, when registering a module manually (i.e. that does not support app wiring), the module version map
	// must be set manually as follow. The upgrade module will de-duplicate the module version map.
	//
	// app.SetInitChainer(func(ctx sdk.Context, req abci.RequestInitChain)

abci.ResponseInitChain {
	// 	app.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())
	// 	return app.App.InitChainer(ctx, req)
	//
})
    if err := app.Load(loadLatest); err != nil {
    panic(err)
}

return app
}

// Name returns the name of the App
func (app *SimApp)

Name()

string {
    return app.BaseApp.Name()
}

// LegacyAmino returns SimApp's amino codec.
//
// NOTE: This is solely to be used for testing purposes as it may be desirable
// for modules to register their own custom testing types.
func (app *SimApp)

LegacyAmino() *codec.LegacyAmino {
    return app.legacyAmino
}

// AppCodec returns SimApp's app codec.
//
// NOTE: This is solely to be used for testing purposes as it may be desirable
// for modules to register their own custom testing types.
func (app *SimApp)

AppCodec()

codec.Codec {
    return app.appCodec
}

// InterfaceRegistry returns SimApp's InterfaceRegistry.
func (app *SimApp)

InterfaceRegistry()

codectypes.InterfaceRegistry {
    return app.interfaceRegistry
}

// TxConfig returns SimApp's TxConfig
func (app *SimApp)

TxConfig()

client.TxConfig {
    return app.txConfig
}

// GetKey returns the KVStoreKey for the provided store key.
//
// NOTE: This is solely to be used for testing purposes.
func (app *SimApp)

GetKey(storeKey string) *storetypes.KVStoreKey {
    sk := app.UnsafeFindStoreKey(storeKey)

kvStoreKey, ok := sk.(*storetypes.KVStoreKey)
    if !ok {
    return nil
}

return kvStoreKey
}

func (app *SimApp)

kvStoreKeys()

map[string]*storetypes.KVStoreKey {
    keys := make(map[string]*storetypes.KVStoreKey)
    for _, k := range app.GetStoreKeys() {
    if kv, ok := k.(*storetypes.KVStoreKey); ok {
    keys[kv.Name()] = kv
}
	
}

return keys
}

// GetSubspace returns a param subspace for a given module name.
//
// NOTE: This is solely to be used for testing purposes.
func (app *SimApp)

GetSubspace(moduleName string)

paramstypes.Subspace {
    subspace, _ := app.ParamsKeeper.GetSubspace(moduleName)

return subspace
}

// SimulationManager implements the SimulationApp interface
func (app *SimApp)

SimulationManager() *module.SimulationManager {
    return app.sm
}

// RegisterAPIRoutes registers all application module routes with the provided
// API server.
func (app *SimApp)

RegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {
    app.App.RegisterAPIRoutes(apiSvr, apiConfig)
	// register swagger API in app.go so that other applications can override easily
    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {
    panic(err)
}
}

// GetMaccPerms returns a copy of the module account permissions
//
// NOTE: This is solely to be used for testing purposes.
func GetMaccPerms()

map[string][]string {
    dup := make(map[string][]string)
    for _, perms := range moduleAccPerms {
    dup[perms.Account] = perms.Permissions
}

return dup
}

// BlockedAddresses returns all the app's blocked account addresses.
func BlockedAddresses()

map[string]bool {
    result := make(map[string]bool)
    if len(blockAccAddrs) > 0 {
    for _, addr := range blockAccAddrs {
    result[addr] = true
}
	
}

else {
    for addr := range GetMaccPerms() {
    result[addr] = true
}
	
}

return result
}
```

### Registering non app wiring modules

It is possible to combine app wiring / depinject enabled modules with non app wiring modules.
To do so, use the `app.RegisterModules` method to register the modules on your app, as well as `app.RegisterStores` for registering the extra stores needed.

```go expandable
// ....
app.App = appBuilder.Build(db, traceStore, baseAppOptions...)

// register module manually
app.RegisterStores(storetypes.NewKVStoreKey(example.ModuleName))

app.ExampleKeeper = examplekeeper.NewKeeper(app.appCodec, app.AccountKeeper.AddressCodec(), runtime.NewKVStoreService(app.GetKey(example.ModuleName)), authtypes.NewModuleAddress(govtypes.ModuleName).String())
    exampleAppModule := examplemodule.NewAppModule(app.ExampleKeeper)
    if err := app.RegisterModules(&exampleAppModule); err != nil {
    panic(err)
}

// ....
```

<Warning>
When using AutoCLI and combining app wiring and non app wiring modules. The AutoCLI options should be manually constructed instead of injected.
Otherwise it will miss the non depinject modules and not register their CLI.
</Warning>

### Complete `app_v2.go`

<Tip>
Note that in the complete `SimApp` `app_v2.go` file, testing utilities are also defined, but they could as well be defined in a separate file.
</Tip>

```go expandable
//go:build !app_v1

package simapp

import (
    
	"io"
    "os"
    "path/filepath"
    "cosmossdk.io/log"
	dbm "github.com/cosmos/cosmos-db"
    "cosmossdk.io/depinject"
	storetypes "cosmossdk.io/store/types"
	circuitkeeper "cosmossdk.io/x/circuit/keeper"
	evidencekeeper "cosmossdk.io/x/evidence/keeper"
	feegrantkeeper "cosmossdk.io/x/feegrant/keeper"
	nftkeeper "cosmossdk.io/x/nft/keeper"
	upgradekeeper "cosmossdk.io/x/upgrade/keeper"
    "github.com/cosmos/cosmos-sdk/baseapp"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
    "github.com/cosmos/cosmos-sdk/runtime"
    "github.com/cosmos/cosmos-sdk/server"
    "github.com/cosmos/cosmos-sdk/server/api"
    "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	testdata_pulsar "github.com/cosmos/cosmos-sdk/testutil/testdata/testpb"
    "github.com/cosmos/cosmos-sdk/types/module"
    "github.com/cosmos/cosmos-sdk/x/auth"
	authkeeper "github.com/cosmos/cosmos-sdk/x/auth/keeper"
	authsims "github.com/cosmos/cosmos-sdk/x/auth/simulation"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	authzkeeper "github.com/cosmos/cosmos-sdk/x/authz/keeper"
	bankkeeper "github.com/cosmos/cosmos-sdk/x/bank/keeper"
	consensuskeeper "github.com/cosmos/cosmos-sdk/x/consensus/keeper"
	crisiskeeper "github.com/cosmos/cosmos-sdk/x/crisis/keeper"
	distrkeeper "github.com/cosmos/cosmos-sdk/x/distribution/keeper"
	govkeeper "github.com/cosmos/cosmos-sdk/x/gov/keeper"
	groupkeeper "github.com/cosmos/cosmos-sdk/x/group/keeper"
	mintkeeper "github.com/cosmos/cosmos-sdk/x/mint/keeper"
	paramskeeper "github.com/cosmos/cosmos-sdk/x/params/keeper"
	paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
	slashingkeeper "github.com/cosmos/cosmos-sdk/x/slashing/keeper"
	stakingkeeper "github.com/cosmos/cosmos-sdk/x/staking/keeper"
)

// DefaultNodeHome default home directories for the application daemon
var DefaultNodeHome string

var (
	_ runtime.AppI            = (*SimApp)(nil)
	_ servertypes.Application = (*SimApp)(nil)
)

// SimApp extends an ABCI application, but with most of its parameters exported.
// They are exported for convenience in creating helper functions, as object
// capabilities aren't needed for testing.
type SimApp struct {
	*runtime.App
	legacyAmino       *codec.LegacyAmino
	appCodec          codec.Codec
	txConfig          client.TxConfig
	interfaceRegistry codectypes.InterfaceRegistry

	// keepers
	AccountKeeper         authkeeper.AccountKeeper
	BankKeeper            bankkeeper.Keeper
	StakingKeeper         *stakingkeeper.Keeper
	SlashingKeeper        slashingkeeper.Keeper
	MintKeeper            mintkeeper.Keeper
	DistrKeeper           distrkeeper.Keeper
	GovKeeper             *govkeeper.Keeper
	CrisisKeeper          *crisiskeeper.Keeper
	UpgradeKeeper         *upgradekeeper.Keeper
	ParamsKeeper          paramskeeper.Keeper
	AuthzKeeper           authzkeeper.Keeper
	EvidenceKeeper        evidencekeeper.Keeper
	FeeGrantKeeper        feegrantkeeper.Keeper
	GroupKeeper           groupkeeper.Keeper
	NFTKeeper             nftkeeper.Keeper
	ConsensusParamsKeeper consensuskeeper.Keeper
	CircuitBreakerKeeper  circuitkeeper.Keeper

	// simulation manager
	sm *module.SimulationManager
}

func init() {
    userHomeDir, err := os.UserHomeDir()
    if err != nil {
    panic(err)
}

DefaultNodeHome = filepath.Join(userHomeDir, ".simapp")
}

// NewSimApp returns a reference to an initialized SimApp.
func NewSimApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	loadLatest bool,
	appOpts servertypes.AppOptions,
	baseAppOptions ...func(*baseapp.BaseApp),
) *SimApp {
    var (
		app        = &SimApp{
}

appBuilder *runtime.AppBuilder

		// merge the AppConfig and other configuration in one config
		appConfig = depinject.Configs(
			AppConfig,
			depinject.Supply(
				// supply the application options
				appOpts,
				// supply the logger
				logger,

				// ADVANCED CONFIGURATION

				//
				// AUTH
				//
				// For providing a custom function required in auth to generate custom account types
				// add it below. By default the auth module uses simulation.RandomGenesisAccounts.
				//
				// authtypes.RandomGenesisAccountsFn(simulation.RandomGenesisAccounts),

				// For providing a custom a base account type add it below.
				// By default the auth module uses authtypes.ProtoBaseAccount().
				//
				// func()

sdk.AccountI {
    return authtypes.ProtoBaseAccount()
},

				//
				// MINT
				//

				// For providing a custom inflation function for x/mint add here your
				// custom function that implements the minttypes.InflationCalculationFn
				// interface.
			),
		)
	)
    if err := depinject.Inject(appConfig,
		&appBuilder,
		&app.appCodec,
		&app.legacyAmino,
		&app.txConfig,
		&app.interfaceRegistry,
		&app.AccountKeeper,
		&app.BankKeeper,
		&app.StakingKeeper,
		&app.SlashingKeeper,
		&app.MintKeeper,
		&app.DistrKeeper,
		&app.GovKeeper,
		&app.CrisisKeeper,
		&app.UpgradeKeeper,
		&app.ParamsKeeper,
		&app.AuthzKeeper,
		&app.EvidenceKeeper,
		&app.FeeGrantKeeper,
		&app.GroupKeeper,
		&app.NFTKeeper,
		&app.ConsensusParamsKeeper,
		&app.CircuitBreakerKeeper,
	); err != nil {
    panic(err)
}

	// Below we could construct and set an application specific mempool and
	// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are
	// already set in the SDK's BaseApp, this shows an example of how to override
	// them.
	//
	// Example:
	//
	// app.App = appBuilder.Build(...)
	// nonceMempool := mempool.NewSenderNonceMempool()
	// abciPropHandler := NewDefaultProposalHandler(nonceMempool, app.App.BaseApp)
	//
	// app.App.BaseApp.SetMempool(nonceMempool)
	// app.App.BaseApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())
	// app.App.BaseApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())
	//
	// Alternatively, you can construct BaseApp options, append those to
	// baseAppOptions and pass them to the appBuilder.
	//
	// Example:
	//
	// prepareOpt = func(app *baseapp.BaseApp) {
	// 	abciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)
	// 	app.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())
	//
}
	// baseAppOptions = append(baseAppOptions, prepareOpt)

app.App = appBuilder.Build(db, traceStore, baseAppOptions...)

	// register streaming services
    if err := app.RegisterStreamingServices(appOpts, app.kvStoreKeys()); err != nil {
    panic(err)
}

	/****  Module Options ****/

	app.ModuleManager.RegisterInvariants(app.CrisisKeeper)

	// RegisterUpgradeHandlers is used for registering any on-chain upgrades.
	app.RegisterUpgradeHandlers()

	// add test gRPC service for testing gRPC queries in isolation
	testdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{
})

	// create the simulation manager and define the order of the modules for deterministic simulations
	//
	// NOTE: this is not required apps that don't use the simulator for fuzz testing
	// transactions
    overrideModules := map[string]module.AppModuleSimulation{
    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, app.GetSubspace(authtypes.ModuleName)),
}

app.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)

app.sm.RegisterStoreDecoders()

	// A custom InitChainer can be set if extra pre-init-genesis logic is required.
	// By default, when using app wiring enabled module, this is not required.
	// For instance, the upgrade module will set automatically the module version map in its init genesis thanks to app wiring.
	// However, when registering a module manually (i.e. that does not support app wiring), the module version map
	// must be set manually as follow. The upgrade module will de-duplicate the module version map.
	//
	// app.SetInitChainer(func(ctx sdk.Context, req abci.RequestInitChain)

abci.ResponseInitChain {
	// 	app.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())
	// 	return app.App.InitChainer(ctx, req)
	//
})
    if err := app.Load(loadLatest); err != nil {
    panic(err)
}

return app
}

// Name returns the name of the App
func (app *SimApp)

Name()

string {
    return app.BaseApp.Name()
}

// LegacyAmino returns SimApp's amino codec.
//
// NOTE: This is solely to be used for testing purposes as it may be desirable
// for modules to register their own custom testing types.
func (app *SimApp)

LegacyAmino() *codec.LegacyAmino {
    return app.legacyAmino
}

// AppCodec returns SimApp's app codec.
//
// NOTE: This is solely to be used for testing purposes as it may be desirable
// for modules to register their own custom testing types.
func (app *SimApp)

AppCodec()

codec.Codec {
    return app.appCodec
}

// InterfaceRegistry returns SimApp's InterfaceRegistry.
func (app *SimApp)

InterfaceRegistry()

codectypes.InterfaceRegistry {
    return app.interfaceRegistry
}

// TxConfig returns SimApp's TxConfig
func (app *SimApp)

TxConfig()

client.TxConfig {
    return app.txConfig
}

// GetKey returns the KVStoreKey for the provided store key.
//
// NOTE: This is solely to be used for testing purposes.
func (app *SimApp)

GetKey(storeKey string) *storetypes.KVStoreKey {
    sk := app.UnsafeFindStoreKey(storeKey)

kvStoreKey, ok := sk.(*storetypes.KVStoreKey)
    if !ok {
    return nil
}

return kvStoreKey
}

func (app *SimApp)

kvStoreKeys()

map[string]*storetypes.KVStoreKey {
    keys := make(map[string]*storetypes.KVStoreKey)
    for _, k := range app.GetStoreKeys() {
    if kv, ok := k.(*storetypes.KVStoreKey); ok {
    keys[kv.Name()] = kv
}
	
}

return keys
}

// GetSubspace returns a param subspace for a given module name.
//
// NOTE: This is solely to be used for testing purposes.
func (app *SimApp)

GetSubspace(moduleName string)

paramstypes.Subspace {
    subspace, _ := app.ParamsKeeper.GetSubspace(moduleName)

return subspace
}

// SimulationManager implements the SimulationApp interface
func (app *SimApp)

SimulationManager() *module.SimulationManager {
    return app.sm
}

// RegisterAPIRoutes registers all application module routes with the provided
// API server.
func (app *SimApp)

RegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {
    app.App.RegisterAPIRoutes(apiSvr, apiConfig)
	// register swagger API in app.go so that other applications can override easily
    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {
    panic(err)
}
}

// GetMaccPerms returns a copy of the module account permissions
//
// NOTE: This is solely to be used for testing purposes.
func GetMaccPerms()

map[string][]string {
    dup := make(map[string][]string)
    for _, perms := range moduleAccPerms {
    dup[perms.Account] = perms.Permissions
}

return dup
}

// BlockedAddresses returns all the app's blocked account addresses.
func BlockedAddresses()

map[string]bool {
    result := make(map[string]bool)
    if len(blockAccAddrs) > 0 {
    for _, addr := range blockAccAddrs {
    result[addr] = true
}
	
}

else {
    for addr := range GetMaccPerms() {
    result[addr] = true
}
	
}

return result
}
```
