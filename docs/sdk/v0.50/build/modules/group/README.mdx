---
title: '`x/group`'
description: The following documents specify the group module.
---

## Abstract

The following documents specify the group module.

This module allows the creation and management of on-chain multisig accounts and enables voting for message execution based on configurable decision policies.

## Contents

* [Concepts](#concepts)
  * [Group](#group)
  * [Group Policy](#group-policy)
  * [Decision Policy](#decision-policy)
  * [Proposal](#proposal)
  * [Pruning](#pruning)
* [State](#state)
  * [Group Table](#group-table)
  * [Group Member Table](#group-member-table)
  * [Group Policy Table](#group-policy-table)
  * [Proposal Table](#proposal-table)
  * [Vote Table](#vote-table)
* [Msg Service](#msg-service)
  * [Msg/CreateGroup](#msgcreategroup)
  * [Msg/UpdateGroupMembers](#msgupdategroupmembers)
  * [Msg/UpdateGroupAdmin](#msgupdategroupadmin)
  * [Msg/UpdateGroupMetadata](#msgupdategroupmetadata)
  * [Msg/CreateGroupPolicy](#msgcreategrouppolicy)
  * [Msg/CreateGroupWithPolicy](#msgcreategroupwithpolicy)
  * [Msg/UpdateGroupPolicyAdmin](#msgupdategrouppolicyadmin)
  * [Msg/UpdateGroupPolicyDecisionPolicy](#msgupdategrouppolicydecisionpolicy)
  * [Msg/UpdateGroupPolicyMetadata](#msgupdategrouppolicymetadata)
  * [Msg/SubmitProposal](#msgsubmitproposal)
  * [Msg/WithdrawProposal](#msgwithdrawproposal)
  * [Msg/Vote](#msgvote)
  * [Msg/Exec](#msgexec)
  * [Msg/LeaveGroup](#msgleavegroup)
* [Events](#events)
  * [EventCreateGroup](#eventcreategroup)
  * [EventUpdateGroup](#eventupdategroup)
  * [EventCreateGroupPolicy](#eventcreategrouppolicy)
  * [EventUpdateGroupPolicy](#eventupdategrouppolicy)
  * [EventCreateProposal](#eventcreateproposal)
  * [EventWithdrawProposal](#eventwithdrawproposal)
  * [EventVote](#eventvote)
  * [EventExec](#eventexec)
  * [EventLeaveGroup](#eventleavegroup)
  * [EventProposalPruned](#eventproposalpruned)
* [Client](#client)
  * [CLI](#cli)
  * [gRPC](#grpc)
  * [REST](#rest)
* [Metadata](#metadata)

## Concepts

### Group

A group is simply an aggregation of accounts with associated weights. It is not
an account and doesn't have a balance. It doesn't in and of itself have any
sort of voting or decision weight. It does have an "administrator" which has
the ability to add, remove and update members in the group. Note that a
group policy account could be an administrator of a group, and that the
administrator doesn't necessarily have to be a member of the group.

### Group Policy

A group policy is an account associated with a group and a decision policy.
Group policies are abstracted from groups because a single group may have
multiple decision policies for different types of actions. Managing group
membership separately from decision policies results in the least overhead
and keeps membership consistent across different policies. The pattern that
is recommended is to have a single master group policy for a given group,
and then to create separate group policies with different decision policies
and delegate the desired permissions from the master account to
those "sub-accounts" using the `x/authz` module.

### Decision Policy

A decision policy is the mechanism by which members of a group can vote on
proposals, as well as the rules that dictate whether a proposal should pass
or not based on its tally outcome.

All decision policies generally would have a mininum execution period and a
maximum voting window. The minimum execution period is the minimum amount of time
that must pass after submission in order for a proposal to potentially be executed, and it may
be set to 0. The maximum voting window is the maximum time after submission that a proposal may
be voted on before it is tallied.

The chain developer also defines an app-wide maximum execution period, which is
the maximum amount of time after a proposal's voting period end where users are
allowed to execute a proposal.

The current group module comes shipped with two decision policies: threshold
and percentage. Any chain developer can extend upon these two, by creating
custom decision policies, as long as they adhere to the `DecisionPolicy`
interface:

```go expandable
package group

import (
    
	"fmt"
    "time"
    "github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
    "github.com/cosmos/cosmos-sdk/x/group/errors"
    "github.com/cosmos/cosmos-sdk/x/group/internal/math"
    "github.com/cosmos/cosmos-sdk/x/group/internal/orm"
)

// DecisionPolicyResult is the result of whether a proposal passes or not a
// decision policy.
type DecisionPolicyResult struct {
	// Allow determines if the proposal is allowed to pass.
	Allow bool
	// Final determines if the tally result is final or not. If final, then
	// votes are pruned, and the tally result is saved in the proposal's
	// `FinalTallyResult` field.
	Final bool
}

// DecisionPolicy is the persistent set of rules to determine the result of election on a proposal.
type DecisionPolicy interface {
    codec.ProtoMarshaler

	// GetVotingPeriod returns the duration after proposal submission where
	// votes are accepted.
	GetVotingPeriod()

time.Duration
	// GetMinExecutionPeriod returns the minimum duration after submission
	// where we can execution a proposal. It can be set to 0 or to a value
	// lesser than VotingPeriod to allow TRY_EXEC.
	GetMinExecutionPeriod()

time.Duration
	// Allow defines policy-specific logic to allow a proposal to pass or not,
	// based on its tally result, the group's total power and the time since
	// the proposal was submitted.
	Allow(tallyResult TallyResult, totalPower string) (DecisionPolicyResult, error)

ValidateBasic()

error
	Validate(g GroupInfo, config Config)

error
}

// Implements DecisionPolicy Interface
var _ DecisionPolicy = &ThresholdDecisionPolicy{
}

// NewThresholdDecisionPolicy creates a threshold DecisionPolicy
func NewThresholdDecisionPolicy(threshold string, votingPeriod time.Duration, minExecutionPeriod time.Duration)

DecisionPolicy {
    return &ThresholdDecisionPolicy{
    threshold, &DecisionPolicyWindows{
    votingPeriod, minExecutionPeriod
}}
}

// GetVotingPeriod returns the voitng period of ThresholdDecisionPolicy
func (p ThresholdDecisionPolicy)

GetVotingPeriod()

time.Duration {
    return p.Windows.VotingPeriod
}

// GetMinExecutionPeriod returns the minimum execution period of ThresholdDecisionPolicy
func (p ThresholdDecisionPolicy)

GetMinExecutionPeriod()

time.Duration {
    return p.Windows.MinExecutionPeriod
}

// ValidateBasic does basic validation on ThresholdDecisionPolicy
func (p ThresholdDecisionPolicy)

ValidateBasic()

error {
    if _, err := math.NewPositiveDecFromString(p.Threshold); err != nil {
    return sdkerrors.Wrap(err, "threshold")
}
    if p.Windows == nil || p.Windows.VotingPeriod == 0 {
    return sdkerrors.Wrap(errors.ErrInvalid, "voting period cannot be zero")
}

return nil
}

// Allow allows a proposal to pass when the tally of yes votes equals or exceeds the threshold before the timeout.
func (p ThresholdDecisionPolicy)

Allow(tallyResult TallyResult, totalPower string) (DecisionPolicyResult, error) {
    threshold, err := math.NewPositiveDecFromString(p.Threshold)
    if err != nil {
    return DecisionPolicyResult{
}, sdkerrors.Wrap(err, "threshold")
}

yesCount, err := math.NewNonNegativeDecFromString(tallyResult.YesCount)
    if err != nil {
    return DecisionPolicyResult{
}, sdkerrors.Wrap(err, "yes count")
}

totalPowerDec, err := math.NewNonNegativeDecFromString(totalPower)
    if err != nil {
    return DecisionPolicyResult{
}, sdkerrors.Wrap(err, "total power")
}

	// the real threshold of the policy is `min(threshold,total_weight)`. If
	// the group member weights changes (member leaving, member weight update)
	// and the threshold doesn't, we can end up with threshold > total_weight.
	// In this case, as long as everyone votes yes (in which case
	// `yesCount`==`realThreshold`), then the proposal still passes.
    realThreshold := min(threshold, totalPowerDec)
    if yesCount.Cmp(realThreshold) >= 0 {
    return DecisionPolicyResult{
    Allow: true,
    Final: true
}, nil
}

totalCounts, err := tallyResult.TotalCounts()
    if err != nil {
    return DecisionPolicyResult{
}, err
}

undecided, err := math.SubNonNegative(totalPowerDec, totalCounts)
    if err != nil {
    return DecisionPolicyResult{
}, err
}
	// maxYesCount is the max potential number of yes count, i.e the current yes count
	// plus all undecided count (supposing they all vote yes).
	maxYesCount, err := yesCount.Add(undecided)
    if err != nil {
    return DecisionPolicyResult{
}, err
}
    if maxYesCount.Cmp(realThreshold) < 0 {
    return DecisionPolicyResult{
    Allow: false,
    Final: true
}, nil
}

return DecisionPolicyResult{
    Allow: false,
    Final: false
}, nil
}

func min(a, b math.Dec)

math.Dec {
    if a.Cmp(b) < 0 {
    return a
}

return b
}

// Validate validates the policy against the group. Note that the threshold
// can actually be greater than the group's total weight: in the Allow method
// we check the tally weight against `min(threshold,total_weight)`.
func (p *ThresholdDecisionPolicy)

Validate(g GroupInfo, config Config)

error {
	_, err := math.NewPositiveDecFromString(p.Threshold)
    if err != nil {
    return sdkerrors.Wrap(err, "threshold")
}
	_, err = math.NewNonNegativeDecFromString(g.TotalWeight)
    if err != nil {
    return sdkerrors.Wrap(err, "group total weight")
}
    if p.Windows.MinExecutionPeriod > p.Windows.VotingPeriod+config.MaxExecutionPeriod {
    return sdkerrors.Wrap(errors.ErrInvalid, "min_execution_period should be smaller than voting_period + max_execution_period")
}

return nil
}

// Implements DecisionPolicy Interface
var _ DecisionPolicy = &PercentageDecisionPolicy{
}

// NewPercentageDecisionPolicy creates a new percentage DecisionPolicy
func NewPercentageDecisionPolicy(percentage string, votingPeriod time.Duration, executionPeriod time.Duration)

DecisionPolicy {
    return &PercentageDecisionPolicy{
    percentage, &DecisionPolicyWindows{
    votingPeriod, executionPeriod
}}
}

// GetVotingPeriod returns the voitng period of PercentageDecisionPolicy
func (p PercentageDecisionPolicy)

GetVotingPeriod()

time.Duration {
    return p.Windows.VotingPeriod
}

// GetMinExecutionPeriod returns the minimum execution period of PercentageDecisionPolicy
func (p PercentageDecisionPolicy)

GetMinExecutionPeriod()

time.Duration {
    return p.Windows.MinExecutionPeriod
}

// ValidateBasic does basic validation on PercentageDecisionPolicy
func (p PercentageDecisionPolicy)

ValidateBasic()

error {
    percentage, err := math.NewPositiveDecFromString(p.Percentage)
    if err != nil {
    return sdkerrors.Wrap(err, "percentage threshold")
}
    if percentage.Cmp(math.NewDecFromInt64(1)) == 1 {
    return sdkerrors.Wrap(errors.ErrInvalid, "percentage must be > 0 and <= 1")
}
    if p.Windows == nil || p.Windows.VotingPeriod == 0 {
    return sdkerrors.Wrap(errors.ErrInvalid, "voting period cannot be 0")
}

return nil
}

// Validate validates the policy against the group.
func (p *PercentageDecisionPolicy)

Validate(g GroupInfo, config Config)

error {
    if p.Windows.MinExecutionPeriod > p.Windows.VotingPeriod+config.MaxExecutionPeriod {
    return sdkerrors.Wrap(errors.ErrInvalid, "min_execution_period should be smaller than voting_period + max_execution_period")
}

return nil
}

// Allow allows a proposal to pass when the tally of yes votes equals or exceeds the percentage threshold before the timeout.
func (p PercentageDecisionPolicy)

Allow(tally TallyResult, totalPower string) (DecisionPolicyResult, error) {
    percentage, err := math.NewPositiveDecFromString(p.Percentage)
    if err != nil {
    return DecisionPolicyResult{
}, sdkerrors.Wrap(err, "percentage")
}

yesCount, err := math.NewNonNegativeDecFromString(tally.YesCount)
    if err != nil {
    return DecisionPolicyResult{
}, sdkerrors.Wrap(err, "yes count")
}

totalPowerDec, err := math.NewNonNegativeDecFromString(totalPower)
    if err != nil {
    return DecisionPolicyResult{
}, sdkerrors.Wrap(err, "total power")
}

yesPercentage, err := yesCount.Quo(totalPowerDec)
    if err != nil {
    return DecisionPolicyResult{
}, err
}
    if yesPercentage.Cmp(percentage) >= 0 {
    return DecisionPolicyResult{
    Allow: true,
    Final: true
}, nil
}

totalCounts, err := tally.TotalCounts()
    if err != nil {
    return DecisionPolicyResult{
}, err
}

undecided, err := math.SubNonNegative(totalPowerDec, totalCounts)
    if err != nil {
    return DecisionPolicyResult{
}, err
}

sum, err := yesCount.Add(undecided)
    if err != nil {
    return DecisionPolicyResult{
}, err
}

sumPercentage, err := sum.Quo(totalPowerDec)
    if err != nil {
    return DecisionPolicyResult{
}, err
}
    if sumPercentage.Cmp(percentage) < 0 {
    return DecisionPolicyResult{
    Allow: false,
    Final: true
}, nil
}

return DecisionPolicyResult{
    Allow: false,
    Final: false
}, nil
}

var _ orm.Validateable = GroupPolicyInfo{
}

// NewGroupPolicyInfo creates a new GroupPolicyInfo instance
func NewGroupPolicyInfo(address sdk.AccAddress, group uint64, admin sdk.AccAddress, metadata string,
	version uint64, decisionPolicy DecisionPolicy, createdAt time.Time,
) (GroupPolicyInfo, error) {
    p := GroupPolicyInfo{
    Address:   address.String(),
    GroupId:   group,
    Admin:     admin.String(),
    Metadata:  metadata,
    Version:   version,
    CreatedAt: createdAt,
}
    err := p.SetDecisionPolicy(decisionPolicy)
    if err != nil {
    return GroupPolicyInfo{
}, err
}

return p, nil
}

// SetDecisionPolicy sets the decision policy for GroupPolicyInfo.
func (g *GroupPolicyInfo)

SetDecisionPolicy(decisionPolicy DecisionPolicy)

error {
    any, err := codectypes.NewAnyWithValue(decisionPolicy)
    if err != nil {
    return err
}

g.DecisionPolicy = any
	return nil
}

// GetDecisionPolicy gets the decision policy of GroupPolicyInfo
func (g GroupPolicyInfo)

GetDecisionPolicy() (DecisionPolicy, error) {
    decisionPolicy, ok := g.DecisionPolicy.GetCachedValue().(DecisionPolicy)
    if !ok {
    return nil, sdkerrors.ErrInvalidType.Wrapf("expected %T, got %T", (DecisionPolicy)(nil), g.DecisionPolicy.GetCachedValue())
}

return decisionPolicy, nil
}

// UnpackInterfaces implements UnpackInterfacesMessage.UnpackInterfaces
func (g GroupPolicyInfo)

UnpackInterfaces(unpacker codectypes.AnyUnpacker)

error {
    var decisionPolicy DecisionPolicy
	return unpacker.UnpackAny(g.DecisionPolicy, &decisionPolicy)
}

func (g GroupInfo)

PrimaryKeyFields() []interface{
} {
    return []interface{
}{
    g.Id
}
}

// ValidateBasic does basic validation on group info.
func (g GroupInfo)

ValidateBasic()

error {
    if g.Id == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "group's GroupId")
}

	_, err := sdk.AccAddressFromBech32(g.Admin)
    if err != nil {
    return sdkerrors.Wrap(err, "admin")
}
    if _, err := math.NewNonNegativeDecFromString(g.TotalWeight); err != nil {
    return sdkerrors.Wrap(err, "total weight")
}
    if g.Version == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "version")
}

return nil
}

func (g GroupPolicyInfo)

PrimaryKeyFields() []interface{
} {
    addr := sdk.MustAccAddressFromBech32(g.Address)

return []interface{
}{
    addr.Bytes()
}
}

func (g Proposal)

PrimaryKeyFields() []interface{
} {
    return []interface{
}{
    g.Id
}
}

// ValidateBasic does basic validation on group policy info.
func (g GroupPolicyInfo)

ValidateBasic()

error {
	_, err := sdk.AccAddressFromBech32(g.Admin)
    if err != nil {
    return sdkerrors.Wrap(err, "group policy admin")
}
	_, err = sdk.AccAddressFromBech32(g.Address)
    if err != nil {
    return sdkerrors.Wrap(err, "group policy account address")
}
    if g.GroupId == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "group policy's group id")
}
    if g.Version == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "group policy version")
}

policy, err := g.GetDecisionPolicy()
    if err != nil {
    return sdkerrors.Wrap(err, "group policy decision policy")
}
    if err := policy.ValidateBasic(); err != nil {
    return sdkerrors.Wrap(err, "group policy's decision policy")
}

return nil
}

func (g GroupMember)

PrimaryKeyFields() []interface{
} {
    addr := sdk.MustAccAddressFromBech32(g.Member.Address)

return []interface{
}{
    g.GroupId, addr.Bytes()
}
}

// ValidateBasic does basic validation on group member.
func (g GroupMember)

ValidateBasic()

error {
    if g.GroupId == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "group member's group id")
}
    err := MemberToMemberRequest(g.Member).ValidateBasic()
    if err != nil {
    return sdkerrors.Wrap(err, "group member")
}

return nil
}

// MemberToMemberRequest converts a `Member` (used for storage)
// to a `MemberRequest` (used in requests). The only difference
// between the two is that `MemberRequest` doesn't have any `AddedAt` field
// since it cannot be set as part of requests.
func MemberToMemberRequest(m *Member)

MemberRequest {
    return MemberRequest{
    Address:  m.Address,
    Weight:   m.Weight,
    Metadata: m.Metadata,
}
}

// ValidateBasic does basic validation on proposal.
func (g Proposal)

ValidateBasic()

error {
    if g.Id == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "proposal id")
}
	_, err := sdk.AccAddressFromBech32(g.GroupPolicyAddress)
    if err != nil {
    return sdkerrors.Wrap(err, "proposal group policy address")
}
    if g.GroupVersion == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "proposal group version")
}
    if g.GroupPolicyVersion == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "proposal group policy version")
}
	_, err = g.FinalTallyResult.GetYesCount()
    if err != nil {
    return sdkerrors.Wrap(err, "proposal FinalTallyResult yes count")
}
	_, err = g.FinalTallyResult.GetNoCount()
    if err != nil {
    return sdkerrors.Wrap(err, "proposal FinalTallyResult no count")
}
	_, err = g.FinalTallyResult.GetAbstainCount()
    if err != nil {
    return sdkerrors.Wrap(err, "proposal FinalTallyResult abstain count")
}
	_, err = g.FinalTallyResult.GetNoWithVetoCount()
    if err != nil {
    return sdkerrors.Wrap(err, "proposal FinalTallyResult veto count")
}

return nil
}

func (v Vote)

PrimaryKeyFields() []interface{
} {
    addr := sdk.MustAccAddressFromBech32(v.Voter)

return []interface{
}{
    v.ProposalId, addr.Bytes()
}
}

var _ orm.Validateable = Vote{
}

// ValidateBasic does basic validation on vote.
func (v Vote)

ValidateBasic()

error {
	_, err := sdk.AccAddressFromBech32(v.Voter)
    if err != nil {
    return sdkerrors.Wrap(err, "voter")
}
    if v.ProposalId == 0 {
    return sdkerrors.Wrap(errors.ErrEmpty, "voter ProposalId")
}
    if v.Option == VOTE_OPTION_UNSPECIFIED {
    return sdkerrors.Wrap(errors.ErrEmpty, "voter vote option")
}
    if _, ok := VoteOption_name[int32(v.Option)]; !ok {
    return sdkerrors.Wrap(errors.ErrInvalid, "vote option")
}

return nil
}

// UnpackInterfaces implements UnpackInterfacesMessage.UnpackInterfaces
func (q QueryGroupPoliciesByGroupResponse)

UnpackInterfaces(unpacker codectypes.AnyUnpacker)

error {
    return unpackGroupPolicies(unpacker, q.GroupPolicies)
}

// UnpackInterfaces implements UnpackInterfacesMessage.UnpackInterfaces
func (q QueryGroupPoliciesByAdminResponse)

UnpackInterfaces(unpacker codectypes.AnyUnpacker)

error {
    return unpackGroupPolicies(unpacker, q.GroupPolicies)
}

func unpackGroupPolicies(unpacker codectypes.AnyUnpacker, accs []*GroupPolicyInfo)

error {
    for _, g := range accs {
    err := g.UnpackInterfaces(unpacker)
    if err != nil {
    return err
}
	
}

return nil
}

type operation func(x, y math.Dec) (math.Dec, error)

func (t *TallyResult)

operation(vote Vote, weight string, op operation)

error {
    weightDec, err := math.NewPositiveDecFromString(weight)
    if err != nil {
    return err
}

yesCount, err := t.GetYesCount()
    if err != nil {
    return sdkerrors.Wrap(err, "yes count")
}

noCount, err := t.GetNoCount()
    if err != nil {
    return sdkerrors.Wrap(err, "no count")
}

abstainCount, err := t.GetAbstainCount()
    if err != nil {
    return sdkerrors.Wrap(err, "abstain count")
}

vetoCount, err := t.GetNoWithVetoCount()
    if err != nil {
    return sdkerrors.Wrap(err, "veto count")
}
    switch vote.Option {
    case VOTE_OPTION_YES:
		yesCount, err := op(yesCount, weightDec)
    if err != nil {
    return sdkerrors.Wrap(err, "yes count")
}

t.YesCount = yesCount.String()
    case VOTE_OPTION_NO:
		noCount, err := op(noCount, weightDec)
    if err != nil {
    return sdkerrors.Wrap(err, "no count")
}

t.NoCount = noCount.String()
    case VOTE_OPTION_ABSTAIN:
		abstainCount, err := op(abstainCount, weightDec)
    if err != nil {
    return sdkerrors.Wrap(err, "abstain count")
}

t.AbstainCount = abstainCount.String()
    case VOTE_OPTION_NO_WITH_VETO:
		vetoCount, err := op(vetoCount, weightDec)
    if err != nil {
    return sdkerrors.Wrap(err, "veto count")
}

t.NoWithVetoCount = vetoCount.String()

default:
		return sdkerrors.Wrapf(errors.ErrInvalid, "unknown vote option %s", vote.Option.String())
}

return nil
}

// GetYesCount returns the number of yes counts from tally result.
func (t TallyResult)

GetYesCount() (math.Dec, error) {
    yesCount, err := math.NewNonNegativeDecFromString(t.YesCount)
    if err != nil {
    return math.Dec{
}, err
}

return yesCount, nil
}

// GetNoCount returns the number of no counts from tally result.
func (t TallyResult)

GetNoCount() (math.Dec, error) {
    noCount, err := math.NewNonNegativeDecFromString(t.NoCount)
    if err != nil {
    return math.Dec{
}, err
}

return noCount, nil
}

// GetAbstainCount returns the number of abstain counts from tally result.
func (t TallyResult)

GetAbstainCount() (math.Dec, error) {
    abstainCount, err := math.NewNonNegativeDecFromString(t.AbstainCount)
    if err != nil {
    return math.Dec{
}, err
}

return abstainCount, nil
}

// GetNoWithVetoCount returns the number of no with veto counts from tally result.
func (t TallyResult)

GetNoWithVetoCount() (math.Dec, error) {
    vetoCount, err := math.NewNonNegativeDecFromString(t.NoWithVetoCount)
    if err != nil {
    return math.Dec{
}, err
}

return vetoCount, nil
}

func (t *TallyResult)

Add(vote Vote, weight string)

error {
    if err := t.operation(vote, weight, math.Add); err != nil {
    return err
}

return nil
}

// TotalCounts is the sum of all weights.
func (t TallyResult)

TotalCounts() (math.Dec, error) {
    yesCount, err := t.GetYesCount()
    if err != nil {
    return math.Dec{
}, sdkerrors.Wrap(err, "yes count")
}

noCount, err := t.GetNoCount()
    if err != nil {
    return math.Dec{
}, sdkerrors.Wrap(err, "no count")
}

abstainCount, err := t.GetAbstainCount()
    if err != nil {
    return math.Dec{
}, sdkerrors.Wrap(err, "abstain count")
}

vetoCount, err := t.GetNoWithVetoCount()
    if err != nil {
    return math.Dec{
}, sdkerrors.Wrap(err, "veto count")
}
    totalCounts := math.NewDecFromInt64(0)

totalCounts, err = totalCounts.Add(yesCount)
    if err != nil {
    return math.Dec{
}, err
}

totalCounts, err = totalCounts.Add(noCount)
    if err != nil {
    return math.Dec{
}, err
}

totalCounts, err = totalCounts.Add(abstainCount)
    if err != nil {
    return math.Dec{
}, err
}

totalCounts, err = totalCounts.Add(vetoCount)
    if err != nil {
    return math.Dec{
}, err
}

return totalCounts, nil
}

// DefaultTallyResult returns a TallyResult with all counts set to 0.
func DefaultTallyResult()

TallyResult {
    return TallyResult{
    YesCount:        "0",
    NoCount:         "0",
    NoWithVetoCount: "0",
    AbstainCount:    "0",
}
}

// VoteOptionFromString returns a VoteOption from a string. It returns an error
// if the string is invalid.
func VoteOptionFromString(str string) (VoteOption, error) {
    vo, ok := VoteOption_value[str]
    if !ok {
    return VOTE_OPTION_UNSPECIFIED, fmt.Errorf("'%s' is not a valid vote option", str)
}

return VoteOption(vo), nil
}
```

#### Threshold decision policy

A threshold decision policy defines a threshold of yes votes (based on a tally
of voter weights) that must be achieved in order for a proposal to pass. For
this decision policy, abstain and veto are simply treated as no's.

This decision policy also has a VotingPeriod window and a MinExecutionPeriod
window. The former defines the duration after proposal submission where members
are allowed to vote, after which tallying is performed. The latter specifies
the minimum duration after proposal submission where the proposal can be
executed. If set to 0, then the proposal is allowed to be executed immediately
on submission (using the `TRY_EXEC` option). Obviously, MinExecutionPeriod
cannot be greater than VotingPeriod+MaxExecutionPeriod (where MaxExecution is
the app-defined duration that specifies the window after voting ended where a
proposal can be executed).

#### Percentage decision policy

A percentage decision policy is similar to a threshold decision policy, except
that the threshold is not defined as a constant weight, but as a percentage.
It's more suited for groups where the group members' weights can be updated, as
the percentage threshold stays the same, and doesn't depend on how those member
weights get updated.

Same as the Threshold decision policy, the percentage decision policy has the
two VotingPeriod and MinExecutionPeriod parameters.

### Proposal

Any member(s) of a group can submit a proposal for a group policy account to decide upon.
A proposal consists of a set of messages that will be executed if the proposal
passes as well as any metadata associated with the proposal.

#### Voting

There are four choices to choose while voting - yes, no, abstain and veto. Not
all decision policies will take the four choices into account. Votes can contain some optional metadata.
In the current implementation, the voting window begins as soon as a proposal
is submitted, and the end is defined by the group policy's decision policy.

#### Withdrawing Proposals

Proposals can be withdrawn any time before the voting period end, either by the
admin of the group policy or by one of the proposers. Once withdrawn, it is
marked as `PROPOSAL_STATUS_WITHDRAWN`, and no more voting or execution is
allowed on it.

#### Aborted Proposals

If the group policy is updated during the voting period of the proposal, then
the proposal is marked as `PROPOSAL_STATUS_ABORTED`, and no more voting or
execution is allowed on it. This is because the group policy defines the rules
of proposal voting and execution, so if those rules change during the lifecycle
of a proposal, then the proposal should be marked as stale.

#### Tallying

Tallying is the counting of all votes on a proposal. It happens only once in
the lifecycle of a proposal, but can be triggered by two factors, whichever
happens first:

* either someone tries to execute the proposal (see next section), which can
  happen on a `Msg/Exec` transaction, or a `Msg/{SubmitProposal,Vote}`
  transaction with the `Exec` field set. When a proposal execution is attempted,
  a tally is done first to make sure the proposal passes.
* or on `EndBlock` when the proposal's voting period end just passed.

If the tally result passes the decision policy's rules, then the proposal is
marked as `PROPOSAL_STATUS_ACCEPTED`, or else it is marked as
`PROPOSAL_STATUS_REJECTED`. In any case, no more voting is allowed anymore, and the tally
result is persisted to state in the proposal's `FinalTallyResult`.

#### Executing Proposals

Proposals are executed only when the tallying is done, and the group account's
decision policy allows the proposal to pass based on the tally outcome. They
are marked by the status `PROPOSAL_STATUS_ACCEPTED`. Execution must happen
before a duration of `MaxExecutionPeriod` (set by the chain developer) after
each proposal's voting period end.

Proposals will not be automatically executed by the chain in this current design,
but rather a user must submit a `Msg/Exec` transaction to attempt to execute the
proposal based on the current votes and decision policy. Any user (not only the
group members) can execute proposals that have been accepted, and execution fees are
paid by the proposal executor.
It's also possible to try to execute a proposal immediately on creation or on
new votes using the `Exec` field of `Msg/SubmitProposal` and `Msg/Vote` requests.
In the former case, proposers signatures are considered as yes votes.
In these cases, if the proposal can't be executed (i.e. it didn't pass the
decision policy's rules), it will still be opened for new votes and
could be tallied and executed later on.

A successful proposal execution will have its `ExecutorResult` marked as
`PROPOSAL_EXECUTOR_RESULT_SUCCESS`. The proposal will be automatically pruned
after execution. On the other hand, a failed proposal execution will be marked
as `PROPOSAL_EXECUTOR_RESULT_FAILURE`. Such a proposal can be re-executed
multiple times, until it expires after `MaxExecutionPeriod` after voting period
end.

### Pruning

Proposals and votes are automatically pruned to avoid state bloat.

Votes are pruned:

* either after a successful tally, i.e. a tally whose result passes the decision
  policy's rules, which can be trigged by a `Msg/Exec` or a
  `Msg/{SubmitProposal,Vote}` with the `Exec` field set,
* or on `EndBlock` right after the proposal's voting period end. This applies to proposals with status `aborted` or `withdrawn` too.

whichever happens first.

Proposals are pruned:

* on `EndBlock` whose proposal status is `withdrawn` or `aborted` on proposal's voting period end before tallying,
* and either after a successful proposal execution,
* or on `EndBlock` right after the proposal's `voting_period_end` +
  `max_execution_period` (defined as an app-wide configuration) is passed,

whichever happens first.

## State

The `group` module uses the `orm` package which provides table storage with support for
primary keys and secondary indexes. `orm` also defines `Sequence` which is a persistent unique key generator based on a counter that can be used along with `Table`s.

Here's the list of tables and associated sequences and indexes stored as part of the `group` module.

### Group Table

The `groupTable` stores `GroupInfo`: `0x0 | BigEndian(GroupId) -> ProtocolBuffer(GroupInfo)`.

#### groupSeq

The value of `groupSeq` is incremented when creating a new group and corresponds to the new `GroupId`: `0x1 | 0x1 -> BigEndian`.

The second `0x1` corresponds to the ORM `sequenceStorageKey`.

#### groupByAdminIndex

`groupByAdminIndex` allows to retrieve groups by admin address:
`0x2 | len([]byte(group.Admin)) | []byte(group.Admin) | BigEndian(GroupId) -> []byte()`.

### Group Member Table

The `groupMemberTable` stores `GroupMember`s: `0x10 | BigEndian(GroupId) | []byte(member.Address) -> ProtocolBuffer(GroupMember)`.

The `groupMemberTable` is a primary key table and its `PrimaryKey` is given by
`BigEndian(GroupId) | []byte(member.Address)` which is used by the following indexes.

#### groupMemberByGroupIndex

`groupMemberByGroupIndex` allows to retrieve group members by group id:
`0x11 | BigEndian(GroupId) | PrimaryKey -> []byte()`.

#### groupMemberByMemberIndex

`groupMemberByMemberIndex` allows to retrieve group members by member address:
`0x12 | len([]byte(member.Address)) | []byte(member.Address) | PrimaryKey -> []byte()`.

### Group Policy Table

The `groupPolicyTable` stores `GroupPolicyInfo`: `0x20 | len([]byte(Address)) | []byte(Address) -> ProtocolBuffer(GroupPolicyInfo)`.

The `groupPolicyTable` is a primary key table and its `PrimaryKey` is given by
`len([]byte(Address)) | []byte(Address)` which is used by the following indexes.

#### groupPolicySeq

The value of `groupPolicySeq` is incremented when creating a new group policy and is used to generate the new group policy account `Address`:
`0x21 | 0x1 -> BigEndian`.

The second `0x1` corresponds to the ORM `sequenceStorageKey`.

#### groupPolicyByGroupIndex

`groupPolicyByGroupIndex` allows to retrieve group policies by group id:
`0x22 | BigEndian(GroupId) | PrimaryKey -> []byte()`.

#### groupPolicyByAdminIndex

`groupPolicyByAdminIndex` allows to retrieve group policies by admin address:
`0x23 | len([]byte(Address)) | []byte(Address) | PrimaryKey -> []byte()`.

### Proposal Table

The `proposalTable` stores `Proposal`s: `0x30 | BigEndian(ProposalId) -> ProtocolBuffer(Proposal)`.

#### proposalSeq

The value of `proposalSeq` is incremented when creating a new proposal and corresponds to the new `ProposalId`: `0x31 | 0x1 -> BigEndian`.

The second `0x1` corresponds to the ORM `sequenceStorageKey`.

#### proposalByGroupPolicyIndex

`proposalByGroupPolicyIndex` allows to retrieve proposals by group policy account address:
`0x32 | len([]byte(account.Address)) | []byte(account.Address) | BigEndian(ProposalId) -> []byte()`.

#### ProposalsByVotingPeriodEndIndex

`proposalsByVotingPeriodEndIndex` allows to retrieve proposals sorted by chronological `voting_period_end`:
`0x33 | sdk.FormatTimeBytes(proposal.VotingPeriodEnd) | BigEndian(ProposalId) -> []byte()`.

This index is used when tallying the proposal votes at the end of the voting period, and for pruning proposals at `VotingPeriodEnd + MaxExecutionPeriod`.

### Vote Table

The `voteTable` stores `Vote`s: `0x40 | BigEndian(ProposalId) | []byte(voter.Address) -> ProtocolBuffer(Vote)`.

The `voteTable` is a primary key table and its `PrimaryKey` is given by
`BigEndian(ProposalId) | []byte(voter.Address)` which is used by the following indexes.

#### voteByProposalIndex

`voteByProposalIndex` allows to retrieve votes by proposal id:
`0x41 | BigEndian(ProposalId) | PrimaryKey -> []byte()`.

#### voteByVoterIndex

`voteByVoterIndex` allows to retrieve votes by voter address:
`0x42 | len([]byte(voter.Address)) | []byte(voter.Address) | PrimaryKey -> []byte()`.

## Msg Service

### Msg/CreateGroup

A new group can be created with the `MsgCreateGroup`, which has an admin address, a list of members and some optional metadata.

The metadata has a maximum length that is chosen by the app developer, and
passed into the group keeper as a config.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if

* metadata length is greater than `MaxMetadataLen` config
* members are not correctly set (e.g. wrong address format, duplicates, or with 0 weight).

### Msg/UpdateGroupMembers

Group members can be updated with the `UpdateGroupMembers`.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

In the list of `MemberUpdates`, an existing member can be removed by setting its weight to 0.

It's expected to fail if:

* the signer is not the admin of the group.
* for any one of the associated group policies, if its decision policy's `Validate()` method fails against the updated group.

### Msg/UpdateGroupAdmin

The `UpdateGroupAdmin` can be used to update a group admin.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if the signer is not the admin of the group.

### Msg/UpdateGroupMetadata

The `UpdateGroupMetadata` can be used to update a group metadata.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* new metadata length is greater than `MaxMetadataLen` config.
* the signer is not the admin of the group.

### Msg/CreateGroupPolicy

A new group policy can be created with the `MsgCreateGroupPolicy`, which has an admin address, a group id, a decision policy and some optional metadata.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* the signer is not the admin of the group.
* metadata length is greater than `MaxMetadataLen` config.
* the decision policy's `Validate()` method doesn't pass against the group.

### Msg/CreateGroupWithPolicy

A new group with policy can be created with the `MsgCreateGroupWithPolicy`, which has an admin address, a list of members, a decision policy, a `group_policy_as_admin` field to optionally set group and group policy admin with group policy address and some optional metadata for group and group policy.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail for the same reasons as `Msg/CreateGroup` and `Msg/CreateGroupPolicy`.

### Msg/UpdateGroupPolicyAdmin

The `UpdateGroupPolicyAdmin` can be used to update a group policy admin.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if the signer is not the admin of the group policy.

### Msg/UpdateGroupPolicyDecisionPolicy

The `UpdateGroupPolicyDecisionPolicy` can be used to update a decision policy.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* the signer is not the admin of the group policy.
* the new decision policy's `Validate()` method doesn't pass against the group.

### Msg/UpdateGroupPolicyMetadata

The `UpdateGroupPolicyMetadata` can be used to update a group policy metadata.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* new metadata length is greater than `MaxMetadataLen` config.
* the signer is not the admin of the group.

### Msg/SubmitProposal

A new proposal can be created with the `MsgSubmitProposal`, which has a group policy account address, a list of proposers addresses, a list of messages to execute if the proposal is accepted and some optional metadata.
An optional `Exec` value can be provided to try to execute the proposal immediately after proposal creation. Proposers signatures are considered as yes votes in this case.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* metadata, title, or summary length is greater than `MaxMetadataLen` config.
* if any of the proposers is not a group member.

### Msg/WithdrawProposal

A proposal can be withdrawn using `MsgWithdrawProposal` which has an `address` (can be either a proposer or the group policy admin) and a `proposal_id` (which has to be withdrawn).

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* the signer is neither the group policy admin nor proposer of the proposal.
* the proposal is already closed or aborted.

### Msg/Vote

A new vote can be created with the `MsgVote`, given a proposal id, a voter address, a choice (yes, no, veto or abstain) and some optional metadata.
An optional `Exec` value can be provided to try to execute the proposal immediately after voting.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* metadata length is greater than `MaxMetadataLen` config.
* the proposal is not in voting period anymore.

### Msg/Exec

A proposal can be executed with the `MsgExec`.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

The messages that are part of this proposal won't be executed if:

* the proposal has not been accepted by the group policy.
* the proposal has already been successfully executed.

### Msg/LeaveGroup

The `MsgLeaveGroup` allows group member to leave a group.

```go expandable
// Since: cosmos-sdk 0.46
syntax = "proto3";

package cosmos.group.v1;

option go_package = "github.com/cosmos/cosmos-sdk/x/group";

import "gogoproto/gogo.proto";
import "cosmos_proto/cosmos.proto";
import "google/protobuf/any.proto";
import "cosmos/group/v1/types.proto";
import "cosmos/msg/v1/msg.proto";
import "amino/amino.proto";

// Msg is the cosmos.group.v1 Msg service.
service Msg {
    option (cosmos.msg.v1.service) = true;

  // CreateGroup creates a new group with an admin account address, a list of members and some optional metadata.
  rpc CreateGroup(MsgCreateGroup)

returns (MsgCreateGroupResponse);

  // UpdateGroupMembers updates the group members with given group id and admin address.
  rpc UpdateGroupMembers(MsgUpdateGroupMembers)

returns (MsgUpdateGroupMembersResponse);

  // UpdateGroupAdmin updates the group admin with given group id and previous admin address.
  rpc UpdateGroupAdmin(MsgUpdateGroupAdmin)

returns (MsgUpdateGroupAdminResponse);

  // UpdateGroupMetadata updates the group metadata with given group id and admin address.
  rpc UpdateGroupMetadata(MsgUpdateGroupMetadata)

returns (MsgUpdateGroupMetadataResponse);

  // CreateGroupPolicy creates a new group policy using given DecisionPolicy.
  rpc CreateGroupPolicy(MsgCreateGroupPolicy)

returns (MsgCreateGroupPolicyResponse);

  // CreateGroupWithPolicy creates a new group with policy.
  rpc CreateGroupWithPolicy(MsgCreateGroupWithPolicy)

returns (MsgCreateGroupWithPolicyResponse);

  // UpdateGroupPolicyAdmin updates a group policy admin.
  rpc UpdateGroupPolicyAdmin(MsgUpdateGroupPolicyAdmin)

returns (MsgUpdateGroupPolicyAdminResponse);

  // UpdateGroupPolicyDecisionPolicy allows a group policy's decision policy to be updated.
  rpc UpdateGroupPolicyDecisionPolicy(MsgUpdateGroupPolicyDecisionPolicy)

returns (MsgUpdateGroupPolicyDecisionPolicyResponse);

  // UpdateGroupPolicyMetadata updates a group policy metadata.
  rpc UpdateGroupPolicyMetadata(MsgUpdateGroupPolicyMetadata)

returns (MsgUpdateGroupPolicyMetadataResponse);

  // SubmitProposal submits a new proposal.
  rpc SubmitProposal(MsgSubmitProposal)

returns (MsgSubmitProposalResponse);

  // WithdrawProposal withdraws a proposal.
  rpc WithdrawProposal(MsgWithdrawProposal)

returns (MsgWithdrawProposalResponse);

  // Vote allows a voter to vote on a proposal.
  rpc Vote(MsgVote)

returns (MsgVoteResponse);

  // Exec executes a proposal.
  rpc Exec(MsgExec)

returns (MsgExecResponse);

  // LeaveGroup allows a group member to leave the group.
  rpc LeaveGroup(MsgLeaveGroup)

returns (MsgLeaveGroupResponse);
}

//
// Groups
//

// MsgCreateGroup is the Msg/CreateGroup request type.
message MsgCreateGroup {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroup";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // metadata is any arbitrary metadata to attached to the group.
  string metadata = 3;
}

// MsgCreateGroupResponse is the Msg/CreateGroup response type.
message MsgCreateGroupResponse {
  // group_id is the unique ID of the newly created group.
  uint64 group_id = 1;
}

// MsgUpdateGroupMembers is the Msg/UpdateGroupMembers request type.
message MsgUpdateGroupMembers {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMembers";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // member_updates is the list of members to update,
  // set weight to 0 to remove a member.
  repeated MemberRequest member_updates = 3 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];
}

// MsgUpdateGroupMembersResponse is the Msg/UpdateGroupMembers response type.
message MsgUpdateGroupMembersResponse {
}

// MsgUpdateGroupAdmin is the Msg/UpdateGroupAdmin request type.
message MsgUpdateGroupAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupAdmin";

  // admin is the current account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // new_admin is the group new admin account address.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupAdminResponse is the Msg/UpdateGroupAdmin response type.
message MsgUpdateGroupAdminResponse {
}

// MsgUpdateGroupMetadata is the Msg/UpdateGroupMetadata request type.
message MsgUpdateGroupMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is the updated group's metadata.
  string metadata = 3;
}

// MsgUpdateGroupMetadataResponse is the Msg/UpdateGroupMetadata response type.
message MsgUpdateGroupMetadataResponse {
}

//
// Group Policies
//

// MsgCreateGroupPolicy is the Msg/CreateGroupPolicy request type.
message MsgCreateGroupPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgCreateGroupPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;

  // metadata is any arbitrary metadata attached to the group policy.
  string metadata = 3;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 4 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupPolicyResponse is the Msg/CreateGroupPolicy response type.
message MsgCreateGroupPolicyResponse {
  // address is the account address of the newly created group policy.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdmin is the Msg/UpdateGroupPolicyAdmin request type.
message MsgUpdateGroupPolicyAdmin {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyAdmin";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of the group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // new_admin is the new group policy admin.
  string new_admin = 3 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyAdminResponse is the Msg/UpdateGroupPolicyAdmin response type.
message MsgUpdateGroupPolicyAdminResponse {
}

// MsgCreateGroupWithPolicy is the Msg/CreateGroupWithPolicy request type.
message MsgCreateGroupWithPolicy {
    option (cosmos.msg.v1.signer)      = "admin";
  option (amino.name)                = "cosmos-sdk/MsgCreateGroupWithPolicy";
  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group and group policy admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // members defines the group members.
  repeated MemberRequest members = 2 [(gogoproto.nullable) = false, (amino.dont_omitempty) = true];

  // group_metadata is any arbitrary metadata attached to the group.
  string group_metadata = 3;

  // group_policy_metadata is any arbitrary metadata attached to the group policy.
  string group_policy_metadata = 4;

  // group_policy_as_admin is a boolean field, if set to true, the group policy account address will be used as group
  // and group policy admin.
  bool group_policy_as_admin = 5;

  // decision_policy specifies the group policy's decision policy.
  google.protobuf.Any decision_policy = 6 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgCreateGroupWithPolicyResponse is the Msg/CreateGroupWithPolicy response type.
message MsgCreateGroupWithPolicyResponse {
  // group_id is the unique ID of the newly created group with policy.
  uint64 group_id = 1;

  // group_policy_address is the account address of the newly created group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgUpdateGroupPolicyDecisionPolicy is the Msg/UpdateGroupPolicyDecisionPolicy request type.
message MsgUpdateGroupPolicyDecisionPolicy {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupDecisionPolicy";

  option (gogoproto.goproto_getters) = false;

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // decision_policy is the updated group policy's decision policy.
  google.protobuf.Any decision_policy = 3 [(cosmos_proto.accepts_interface) = "cosmos.group.v1.DecisionPolicy"];
}

// MsgUpdateGroupPolicyDecisionPolicyResponse is the Msg/UpdateGroupPolicyDecisionPolicy response type.
message MsgUpdateGroupPolicyDecisionPolicyResponse {
}

// MsgUpdateGroupPolicyMetadata is the Msg/UpdateGroupPolicyMetadata request type.
message MsgUpdateGroupPolicyMetadata {
    option (cosmos.msg.v1.signer) = "admin";
  option (amino.name)           = "cosmos-sdk/MsgUpdateGroupPolicyMetadata";

  // admin is the account address of the group admin.
  string admin = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_policy_address is the account address of group policy.
  string group_policy_address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // metadata is the group policy metadata to be updated.
  string metadata = 3;
}

// MsgUpdateGroupPolicyMetadataResponse is the Msg/UpdateGroupPolicyMetadata response type.
message MsgUpdateGroupPolicyMetadataResponse {
}

//
// Proposals and Voting
//

// Exec defines modes of execution of a proposal on creation or on new vote.
enum Exec {
  // An empty value means that there should be a separate
  // MsgExec request for the proposal to execute.
  EXEC_UNSPECIFIED = 0;

  // Try to execute the proposal immediately.
  // If the proposal is not allowed per the DecisionPolicy,
  // the proposal will still be open and could
  // be executed at a later point.
  EXEC_TRY = 1;
}

// MsgSubmitProposal is the Msg/SubmitProposal request type.
message MsgSubmitProposal {
    option (cosmos.msg.v1.signer) = "proposers";
  option (amino.name)           = "cosmos-sdk/group/MsgSubmitProposal";

  option (gogoproto.goproto_getters) = false;

  // group_policy_address is the account address of group policy.
  string group_policy_address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // proposers are the account addresses of the proposers.
  // Proposers signatures will be counted as yes votes.
  repeated string proposers = 2;

  // metadata is any arbitrary metadata attached to the proposal.
  string metadata = 3;

  // messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  repeated google.protobuf.Any messages = 4;

  // exec defines the mode of execution of the proposal,
  // whether it should be executed immediately on creation or not.
  // If so, proposers signatures are considered as Yes votes.
  Exec exec = 5;

  // title is the title of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string title = 6;

  // summary is the summary of the proposal.
  //
  // Since: cosmos-sdk 0.47
  string summary = 7;
}

// MsgSubmitProposalResponse is the Msg/SubmitProposal response type.
message MsgSubmitProposalResponse {
  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;
}

// MsgWithdrawProposal is the Msg/WithdrawProposal request type.
message MsgWithdrawProposal {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgWithdrawProposal";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // address is the admin of the group policy or one of the proposer of the proposal.
  string address = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgWithdrawProposalResponse is the Msg/WithdrawProposal response type.
message MsgWithdrawProposalResponse {
}

// MsgVote is the Msg/Vote request type.
message MsgVote {
    option (cosmos.msg.v1.signer) = "voter";
  option (amino.name)           = "cosmos-sdk/group/MsgVote";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // voter is the voter account address.
  string voter = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // option is the voter's choice on the proposal.
  VoteOption option = 3;

  // metadata is any arbitrary metadata attached to the vote.
  string metadata = 4;

  // exec defines whether the proposal should be executed
  // immediately after voting or not.
  Exec exec = 5;
}

// MsgVoteResponse is the Msg/Vote response type.
message MsgVoteResponse {
}

// MsgExec is the Msg/Exec request type.
message MsgExec {
    option (cosmos.msg.v1.signer) = "signer";
  option (amino.name)           = "cosmos-sdk/group/MsgExec";

  // proposal is the unique ID of the proposal.
  uint64 proposal_id = 1;

  // executor is the account address used to execute the proposal.
  string executor = 2 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// MsgExecResponse is the Msg/Exec request type.
message MsgExecResponse {
  // result is the final result of the proposal execution.
  ProposalExecutorResult result = 2;
}

// MsgLeaveGroup is the Msg/LeaveGroup request type.
message MsgLeaveGroup {
    option (cosmos.msg.v1.signer) = "address";
  option (amino.name)           = "cosmos-sdk/group/MsgLeaveGroup";

  // address is the account address of the group member.
  string address = 1 [(cosmos_proto.scalar) = "cosmos.AddressString"];

  // group_id is the unique ID of the group.
  uint64 group_id = 2;
}

// MsgLeaveGroupResponse is the Msg/LeaveGroup response type.
message MsgLeaveGroupResponse {
}
```

It's expected to fail if:

* the group member is not part of the group.
* for any one of the associated group policies, if its decision policy's `Validate()` method fails against the updated group.

## Events

The group module emits the following events:

### EventCreateGroup

| Type                             | Attribute Key | Attribute Value                  |
| -------------------------------- | ------------- | -------------------------------- |
| message                          | action        | /cosmos.group.v1.Msg/CreateGroup |
| cosmos.group.v1.EventCreateGroup | group\_id     | `{groupId}`                        |

### EventUpdateGroup

| Type                             | Attribute Key | Attribute Value                                            |
| -------------------------------- | ------------- | ---------------------------------------------------------- |
| message                          | action        | `/cosmos.group.v1.Msg/UpdateGroup{Admin\|Metadata\|Members}` |
| cosmos.group.v1.EventUpdateGroup | group\_id     | `{groupId}`                                                  |

### EventCreateGroupPolicy

| Type                                   | Attribute Key | Attribute Value                        |
| -------------------------------------- | ------------- | -------------------------------------- |
| message                                | action        | /cosmos.group.v1.Msg/CreateGroupPolicy |
| cosmos.group.v1.EventCreateGroupPolicy | address       | `{groupPolicyAddress}`                   |

### EventUpdateGroupPolicy

| Type                                   | Attribute Key | Attribute Value                                                         |
| -------------------------------------- | ------------- | ----------------------------------------------------------------------- |
| message                                | action        | `/cosmos.group.v1.Msg/UpdateGroupPolicy{Admin\|Metadata\|DecisionPolicy}` |
| cosmos.group.v1.EventUpdateGroupPolicy | address       | `{groupPolicyAddress}`                                                    |

### EventCreateProposal

| Type                                | Attribute Key | Attribute Value                     |
| ----------------------------------- | ------------- | ----------------------------------- |
| message                             | action        | /cosmos.group.v1.Msg/CreateProposal |
| cosmos.group.v1.EventCreateProposal | proposal\_id  | `{proposalId}`                        |

### EventWithdrawProposal

| Type                                  | Attribute Key | Attribute Value                       |
| ------------------------------------- | ------------- | ------------------------------------- |
| message                               | action        | /cosmos.group.v1.Msg/WithdrawProposal |
| cosmos.group.v1.EventWithdrawProposal | proposal\_id  | `{proposalId}`                          |

### EventVote

| Type                      | Attribute Key | Attribute Value           |
| ------------------------- | ------------- | ------------------------- |
| message                   | action        | /cosmos.group.v1.Msg/Vote |
| cosmos.group.v1.EventVote | proposal\_id  | `{proposalId}`              |

## EventExec

| Type                      | Attribute Key | Attribute Value           |
| ------------------------- | ------------- | ------------------------- |
| message                   | action        | /cosmos.group.v1.Msg/Exec |
| cosmos.group.v1.EventExec | proposal\_id  | `{proposalId}`              |
| cosmos.group.v1.EventExec | logs          | `{logs\_string}`            |

### EventLeaveGroup

| Type                            | Attribute Key | Attribute Value                 |
| ------------------------------- | ------------- | ------------------------------- |
| message                         | action        | /cosmos.group.v1.Msg/LeaveGroup |
| cosmos.group.v1.EventLeaveGroup | proposal\_id  | `{proposalId}`                    |
| cosmos.group.v1.EventLeaveGroup | address       | `{address}`                       |

### EventProposalPruned

| Type                                | Attribute Key | Attribute Value                 |
| ----------------------------------- | ------------- | ------------------------------- |
| message                             | action        | /cosmos.group.v1.Msg/LeaveGroup |
| cosmos.group.v1.EventProposalPruned | proposal\_id  | `{proposalId}`                    |
| cosmos.group.v1.EventProposalPruned | status        | `{ProposalStatus}`                |
| cosmos.group.v1.EventProposalPruned | tally\_result | `{TallyResult}`                   |

## Client

### CLI

A user can query and interact with the `group` module using the CLI.

#### Query

The `query` commands allow users to query `group` state.

```bash
simd query group --help
```

##### group-info

The `group-info` command allows users to query for group info by given group id.

```bash
simd query group group-info [id] [flags]
```

Example:

```bash
simd query group group-info 1
```

Example Output:

```bash
admin: cosmos1..
group_id: "1"
metadata: AQ==
total_weight: "3"
version: "1"
```

##### group-policy-info

The `group-policy-info` command allows users to query for group policy info by account address of group policy .

```bash
simd query group group-policy-info [group-policy-account] [flags]
```

Example:

```bash
simd query group group-policy-info cosmos1..
```

Example Output:

```bash expandable
address: cosmos1..
admin: cosmos1..
decision_policy:
  '@type': /cosmos.group.v1.ThresholdDecisionPolicy
  threshold: "1"
  windows:
      min_execution_period: 0s
      voting_period: 432000s
group_id: "1"
metadata: AQ==
version: "1"
```

##### group-members

The `group-members` command allows users to query for group members by group id with pagination flags.

```bash
simd query group group-members [id] [flags]
```

Example:

```bash
simd query group group-members 1
```

Example Output:

```bash expandable
members:
- group_id: "1"
  member:
    address: cosmos1..
    metadata: AQ==
    weight: "2"
- group_id: "1"
  member:
    address: cosmos1..
    metadata: AQ==
    weight: "1"
pagination:
  next_key: null
  total: "2"
```

##### groups-by-admin

The `groups-by-admin` command allows users to query for groups by admin account address with pagination flags.

```bash
simd query group groups-by-admin [admin] [flags]
```

Example:

```bash
simd query group groups-by-admin cosmos1..
```

Example Output:

```bash expandable
groups:
- admin: cosmos1..
  group_id: "1"
  metadata: AQ==
  total_weight: "3"
  version: "1"
- admin: cosmos1..
  group_id: "2"
  metadata: AQ==
  total_weight: "3"
  version: "1"
pagination:
  next_key: null
  total: "2"
```

##### group-policies-by-group

The `group-policies-by-group` command allows users to query for group policies by group id with pagination flags.

```bash
simd query group group-policies-by-group [group-id] [flags]
```

Example:

```bash
simd query group group-policies-by-group 1
```

Example Output:

```bash expandable
group_policies:
- address: cosmos1..
  admin: cosmos1..
  decision_policy:
    '@type': /cosmos.group.v1.ThresholdDecisionPolicy
    threshold: "1"
    windows:
      min_execution_period: 0s
      voting_period: 432000s
  group_id: "1"
  metadata: AQ==
  version: "1"
- address: cosmos1..
  admin: cosmos1..
  decision_policy:
    '@type': /cosmos.group.v1.ThresholdDecisionPolicy
    threshold: "1"
    windows:
      min_execution_period: 0s
      voting_period: 432000s
  group_id: "1"
  metadata: AQ==
  version: "1"
pagination:
  next_key: null
  total: "2"
```

##### group-policies-by-admin

The `group-policies-by-admin` command allows users to query for group policies by admin account address with pagination flags.

```bash
simd query group group-policies-by-admin [admin] [flags]
```

Example:

```bash
simd query group group-policies-by-admin cosmos1..
```

Example Output:

```bash expandable
group_policies:
- address: cosmos1..
  admin: cosmos1..
  decision_policy:
    '@type': /cosmos.group.v1.ThresholdDecisionPolicy
    threshold: "1"
    windows:
      min_execution_period: 0s
      voting_period: 432000s
  group_id: "1"
  metadata: AQ==
  version: "1"
- address: cosmos1..
  admin: cosmos1..
  decision_policy:
    '@type': /cosmos.group.v1.ThresholdDecisionPolicy
    threshold: "1"
    windows:
      min_execution_period: 0s
      voting_period: 432000s
  group_id: "1"
  metadata: AQ==
  version: "1"
pagination:
  next_key: null
  total: "2"
```

##### proposal

The `proposal` command allows users to query for proposal by id.

```bash
simd query group proposal [id] [flags]
```

Example:

```bash
simd query group proposal 1
```

Example Output:

```bash expandable
proposal:
  address: cosmos1..
  executor_result: EXECUTOR_RESULT_NOT_RUN
  group_policy_version: "1"
  group_version: "1"
  metadata: AQ==
  msgs:
  - '@type': /cosmos.bank.v1beta1.MsgSend
    amount:
    - amount: "100000000"
      denom: stake
    from_address: cosmos1..
    to_address: cosmos1..
  proposal_id: "1"
  proposers:
  - cosmos1..
  result: RESULT_UNFINALIZED
  status: STATUS_SUBMITTED
  submitted_at: "2021-12-17T07:06:26.310638964Z"
  windows:
    min_execution_period: 0s
    voting_period: 432000s
  vote_state:
    abstain_count: "0"
    no_count: "0"
    veto_count: "0"
    yes_count: "0"
  summary: "Summary"
  title: "Title"
```

##### proposals-by-group-policy

The `proposals-by-group-policy` command allows users to query for proposals by account address of group policy with pagination flags.

```bash
simd query group proposals-by-group-policy [group-policy-account] [flags]
```

Example:

```bash
simd query group proposals-by-group-policy cosmos1..
```

Example Output:

```bash expandable
pagination:
  next_key: null
  total: "1"
proposals:
- address: cosmos1..
  executor_result: EXECUTOR_RESULT_NOT_RUN
  group_policy_version: "1"
  group_version: "1"
  metadata: AQ==
  msgs:
  - '@type': /cosmos.bank.v1beta1.MsgSend
    amount:
    - amount: "100000000"
      denom: stake
    from_address: cosmos1..
    to_address: cosmos1..
  proposal_id: "1"
  proposers:
  - cosmos1..
  result: RESULT_UNFINALIZED
  status: STATUS_SUBMITTED
  submitted_at: "2021-12-17T07:06:26.310638964Z"
  windows:
    min_execution_period: 0s
    voting_period: 432000s
  vote_state:
    abstain_count: "0"
    no_count: "0"
    veto_count: "0"
    yes_count: "0"
  summary: "Summary"
  title: "Title"
```

##### vote

The `vote` command allows users to query for vote by proposal id and voter account address.

```bash
simd query group vote [proposal-id] [voter] [flags]
```

Example:

```bash
simd query group vote 1 cosmos1..
```

Example Output:

```bash
vote:
  choice: CHOICE_YES
  metadata: AQ==
  proposal_id: "1"
  submitted_at: "2021-12-17T08:05:02.490164009Z"
  voter: cosmos1..
```

##### votes-by-proposal

The `votes-by-proposal` command allows users to query for votes by proposal id with pagination flags.

```bash
simd query group votes-by-proposal [proposal-id] [flags]
```

Example:

```bash
simd query group votes-by-proposal 1
```

Example Output:

```bash
pagination:
  next_key: null
  total: "1"
votes:
- choice: CHOICE_YES
  metadata: AQ==
  proposal_id: "1"
  submitted_at: "2021-12-17T08:05:02.490164009Z"
  voter: cosmos1..
```

##### votes-by-voter

The `votes-by-voter` command allows users to query for votes by voter account address with pagination flags.

```bash
simd query group votes-by-voter [voter] [flags]
```

Example:

```bash
simd query group votes-by-voter cosmos1..
```

Example Output:

```bash
pagination:
  next_key: null
  total: "1"
votes:
- choice: CHOICE_YES
  metadata: AQ==
  proposal_id: "1"
  submitted_at: "2021-12-17T08:05:02.490164009Z"
  voter: cosmos1..
```

### Transactions

The `tx` commands allow users to interact with the `group` module.

```bash
simd tx group --help
```

#### create-group

The `create-group` command allows users to create a group which is an aggregation of member accounts with associated weights and
an administrator account.

```bash
simd tx group create-group [admin] [metadata] [members-json-file]
```

Example:

```bash
simd tx group create-group cosmos1.. "AQ==" members.json
```

#### update-group-admin

The `update-group-admin` command allows users to update a group's admin.

```bash
simd tx group update-group-admin [admin] [group-id] [new-admin] [flags]
```

Example:

```bash
simd tx group update-group-admin cosmos1.. 1 cosmos1..
```

#### update-group-members

The `update-group-members` command allows users to update a group's members.

```bash
simd tx group update-group-members [admin] [group-id] [members-json-file] [flags]
```

Example:

```bash
simd tx group update-group-members cosmos1.. 1 members.json
```

#### update-group-metadata

The `update-group-metadata` command allows users to update a group's metadata.

```bash
simd tx group update-group-metadata [admin] [group-id] [metadata] [flags]
```

Example:

```bash
simd tx group update-group-metadata cosmos1.. 1 "AQ=="
```

#### create-group-policy

The `create-group-policy` command allows users to create a group policy which is an account associated with a group and a decision policy.

```bash
simd tx group create-group-policy [admin] [group-id] [metadata] [decision-policy] [flags]
```

Example:

```bash
simd tx group create-group-policy cosmos1.. 1 "AQ==" '{"@type":"/cosmos.group.v1.ThresholdDecisionPolicy", "threshold":"1", "windows": {"voting_period": "120h", "min_execution_period": "0s"}}'
```

#### create-group-with-policy

The `create-group-with-policy` command allows users to create a group which is an aggregation of member accounts with associated weights and an administrator account with decision policy. If the `--group-policy-as-admin` flag is set to `true`, the group policy address becomes the group and group policy admin.

```bash
simd tx group create-group-with-policy [admin] [group-metadata] [group-policy-metadata] [members-json-file] [decision-policy] [flags]
```

Example:

```bash
simd tx group create-group-with-policy cosmos1.. "AQ==" "AQ==" members.json '{"@type":"/cosmos.group.v1.ThresholdDecisionPolicy", "threshold":"1", "windows": {"voting_period": "120h", "min_execution_period": "0s"}}'
```

#### update-group-policy-admin

The `update-group-policy-admin` command allows users to update a group policy admin.

```bash
simd tx group update-group-policy-admin [admin] [group-policy-account] [new-admin] [flags]
```

Example:

```bash
simd tx group update-group-policy-admin cosmos1.. cosmos1.. cosmos1..
```

#### update-group-policy-metadata

The `update-group-policy-metadata` command allows users to update a group policy metadata.

```bash
simd tx group update-group-policy-metadata [admin] [group-policy-account] [new-metadata] [flags]
```

Example:

```bash
simd tx group update-group-policy-metadata cosmos1.. cosmos1.. "AQ=="
```

#### update-group-policy-decision-policy

The `update-group-policy-decision-policy` command allows users to update a group policy's decision policy.

```bash
simd  tx group update-group-policy-decision-policy [admin] [group-policy-account] [decision-policy] [flags]
```

Example:

```bash
simd tx group update-group-policy-decision-policy cosmos1.. cosmos1.. '{"@type":"/cosmos.group.v1.ThresholdDecisionPolicy", "threshold":"2", "windows": {"voting_period": "120h", "min_execution_period": "0s"}}'
```

#### submit-proposal

The `submit-proposal` command allows users to submit a new proposal.

```bash
simd tx group submit-proposal [group-policy-account] [proposer[,proposer]*] [msg_tx_json_file] [metadata] [flags]
```

Example:

```bash
simd tx group submit-proposal cosmos1.. cosmos1.. msg_tx.json "AQ=="
```

#### withdraw-proposal

The `withdraw-proposal` command allows users to withdraw a proposal.

```bash
simd tx group withdraw-proposal [proposal-id] [group-policy-admin-or-proposer]
```

Example:

```bash
simd tx group withdraw-proposal 1 cosmos1..
```

#### vote

The `vote` command allows users to vote on a proposal.

```bash
simd tx group vote proposal-id] [voter] [choice] [metadata] [flags]
```

Example:

```bash
simd tx group vote 1 cosmos1.. CHOICE_YES "AQ=="
```

#### exec

The `exec` command allows users to execute a proposal.

```bash
simd tx group exec [proposal-id] [flags]
```

Example:

```bash
simd tx group exec 1
```

#### leave-group

The `leave-group` command allows group member to leave the group.

```bash
simd tx group leave-group [member-address] [group-id]
```

Example:

```bash
simd tx group leave-group cosmos1... 1
```

### gRPC

A user can query the `group` module using gRPC endpoints.

#### GroupInfo

The `GroupInfo` endpoint allows users to query for group info by given group id.

```bash
cosmos.group.v1.Query/GroupInfo
```

Example:

```bash
grpcurl -plaintext \
    -d '{"group_id":1}' localhost:9090 cosmos.group.v1.Query/GroupInfo
```

Example Output:

```bash
{
  "info": {
    "groupId": "1",
    "admin": "cosmos1..",
    "metadata": "AQ==",
    "version": "1",
    "totalWeight": "3"
  }
}
```

#### GroupPolicyInfo

The `GroupPolicyInfo` endpoint allows users to query for group policy info by account address of group policy.

```bash
cosmos.group.v1.Query/GroupPolicyInfo
```

Example:

```bash
grpcurl -plaintext \
    -d '{"address":"cosmos1.."}'  localhost:9090 cosmos.group.v1.Query/GroupPolicyInfo
```

Example Output:

```bash
{
  "info": {
    "address": "cosmos1..",
    "groupId": "1",
    "admin": "cosmos1..",
    "version": "1",
    "decisionPolicy": {"@type":"/cosmos.group.v1.ThresholdDecisionPolicy","threshold":"1","windows": {"voting_period": "120h", "min_execution_period": "0s"}},
  }
}
```

#### GroupMembers

The `GroupMembers` endpoint allows users to query for group members by group id with pagination flags.

```bash
cosmos.group.v1.Query/GroupMembers
```

Example:

```bash
grpcurl -plaintext \
    -d '{"group_id":"1"}'  localhost:9090 cosmos.group.v1.Query/GroupMembers
```

Example Output:

```bash expandable
{
  "members": [
    {
      "groupId": "1",
      "member": {
        "address": "cosmos1..",
        "weight": "1"
      }
    },
    {
      "groupId": "1",
      "member": {
        "address": "cosmos1..",
        "weight": "2"
      }
    }
  ],
  "pagination": {
    "total": "2"
  }
}
```

#### GroupsByAdmin

The `GroupsByAdmin` endpoint allows users to query for groups by admin account address with pagination flags.

```bash
cosmos.group.v1.Query/GroupsByAdmin
```

Example:

```bash
grpcurl -plaintext \
    -d '{"admin":"cosmos1.."}'  localhost:9090 cosmos.group.v1.Query/GroupsByAdmin
```

Example Output:

```bash expandable
{
  "groups": [
    {
      "groupId": "1",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "totalWeight": "3"
    },
    {
      "groupId": "2",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "totalWeight": "3"
    }
  ],
  "pagination": {
    "total": "2"
  }
}
```

#### GroupPoliciesByGroup

The `GroupPoliciesByGroup` endpoint allows users to query for group policies by group id with pagination flags.

```bash
cosmos.group.v1.Query/GroupPoliciesByGroup
```

Example:

```bash
grpcurl -plaintext \
    -d '{"group_id":"1"}'  localhost:9090 cosmos.group.v1.Query/GroupPoliciesByGroup
```

Example Output:

```bash expandable
{
  "GroupPolicies": [
    {
      "address": "cosmos1..",
      "groupId": "1",
      "admin": "cosmos1..",
      "version": "1",
      "decisionPolicy": {"@type":"/cosmos.group.v1.ThresholdDecisionPolicy","threshold":"1","windows":{"voting_period": "120h", "min_execution_period": "0s"}},
    },
    {
      "address": "cosmos1..",
      "groupId": "1",
      "admin": "cosmos1..",
      "version": "1",
      "decisionPolicy": {"@type":"/cosmos.group.v1.ThresholdDecisionPolicy","threshold":"1","windows":{"voting_period": "120h", "min_execution_period": "0s"}},
    }
  ],
  "pagination": {
    "total": "2"
  }
}
```

#### GroupPoliciesByAdmin

The `GroupPoliciesByAdmin` endpoint allows users to query for group policies by admin account address with pagination flags.

```bash
cosmos.group.v1.Query/GroupPoliciesByAdmin
```

Example:

```bash
grpcurl -plaintext \
    -d '{"admin":"cosmos1.."}'  localhost:9090 cosmos.group.v1.Query/GroupPoliciesByAdmin
```

Example Output:

```bash expandable
{
  "GroupPolicies": [
    {
      "address": "cosmos1..",
      "groupId": "1",
      "admin": "cosmos1..",
      "version": "1",
      "decisionPolicy": {"@type":"/cosmos.group.v1.ThresholdDecisionPolicy","threshold":"1","windows":{"voting_period": "120h", "min_execution_period": "0s"}},
    },
    {
      "address": "cosmos1..",
      "groupId": "1",
      "admin": "cosmos1..",
      "version": "1",
      "decisionPolicy": {"@type":"/cosmos.group.v1.ThresholdDecisionPolicy","threshold":"1","windows":{"voting_period": "120h", "min_execution_period": "0s"}},
    }
  ],
  "pagination": {
    "total": "2"
  }
}
```

#### Proposal

The `Proposal` endpoint allows users to query for proposal by id.

```bash
cosmos.group.v1.Query/Proposal
```

Example:

```bash
grpcurl -plaintext \
    -d '{"proposal_id":"1"}'  localhost:9090 cosmos.group.v1.Query/Proposal
```

Example Output:

```bash expandable
{
  "proposal": {
    "proposalId": "1",
    "address": "cosmos1..",
    "proposers": [
      "cosmos1.."
    ],
    "submittedAt": "2021-12-17T07:06:26.310638964Z",
    "groupVersion": "1",
    "GroupPolicyVersion": "1",
    "status": "STATUS_SUBMITTED",
    "result": "RESULT_UNFINALIZED",
    "voteState": {
      "yesCount": "0",
      "noCount": "0",
      "abstainCount": "0",
      "vetoCount": "0"
    },
    "windows": {
      "min_execution_period": "0s",
      "voting_period": "432000s"
    },
    "executorResult": "EXECUTOR_RESULT_NOT_RUN",
    "messages": [
      {"@type":"/cosmos.bank.v1beta1.MsgSend","amount":[{"denom":"stake","amount":"100000000"}],"fromAddress":"cosmos1..","toAddress":"cosmos1.."}
    ],
    "title": "Title",
    "summary": "Summary",
  }
}
```

#### ProposalsByGroupPolicy

The `ProposalsByGroupPolicy` endpoint allows users to query for proposals by account address of group policy with pagination flags.

```bash
cosmos.group.v1.Query/ProposalsByGroupPolicy
```

Example:

```bash
grpcurl -plaintext \
    -d '{"address":"cosmos1.."}'  localhost:9090 cosmos.group.v1.Query/ProposalsByGroupPolicy
```

Example Output:

```bash expandable
{
  "proposals": [
    {
      "proposalId": "1",
      "address": "cosmos1..",
      "proposers": [
        "cosmos1.."
      ],
      "submittedAt": "2021-12-17T08:03:27.099649352Z",
      "groupVersion": "1",
      "GroupPolicyVersion": "1",
      "status": "STATUS_CLOSED",
      "result": "RESULT_ACCEPTED",
      "voteState": {
        "yesCount": "1",
        "noCount": "0",
        "abstainCount": "0",
        "vetoCount": "0"
      },
      "windows": {
        "min_execution_period": "0s",
        "voting_period": "432000s"
      },
      "executorResult": "EXECUTOR_RESULT_NOT_RUN",
      "messages": [
        {"@type":"/cosmos.bank.v1beta1.MsgSend","amount":[{"denom":"stake","amount":"100000000"}],"fromAddress":"cosmos1..","toAddress":"cosmos1.."}
      ],
      "title": "Title",
      "summary": "Summary",
    }
  ],
  "pagination": {
    "total": "1"
  }
}
```

#### VoteByProposalVoter

The `VoteByProposalVoter` endpoint allows users to query for vote by proposal id and voter account address.

```bash
cosmos.group.v1.Query/VoteByProposalVoter
```

Example:

```bash
grpcurl -plaintext \
    -d '{"proposal_id":"1","voter":"cosmos1.."}'  localhost:9090 cosmos.group.v1.Query/VoteByProposalVoter
```

Example Output:

```bash
{
  "vote": {
    "proposalId": "1",
    "voter": "cosmos1..",
    "choice": "CHOICE_YES",
    "submittedAt": "2021-12-17T08:05:02.490164009Z"
  }
}
```

#### VotesByProposal

The `VotesByProposal` endpoint allows users to query for votes by proposal id with pagination flags.

```bash
cosmos.group.v1.Query/VotesByProposal
```

Example:

```bash
grpcurl -plaintext \
    -d '{"proposal_id":"1"}'  localhost:9090 cosmos.group.v1.Query/VotesByProposal
```

Example Output:

```bash expandable
{
  "votes": [
    {
      "proposalId": "1",
      "voter": "cosmos1..",
      "choice": "CHOICE_YES",
      "submittedAt": "2021-12-17T08:05:02.490164009Z"
    }
  ],
  "pagination": {
    "total": "1"
  }
}
```

#### VotesByVoter

The `VotesByVoter` endpoint allows users to query for votes by voter account address with pagination flags.

```bash
cosmos.group.v1.Query/VotesByVoter
```

Example:

```bash
grpcurl -plaintext \
    -d '{"voter":"cosmos1.."}'  localhost:9090 cosmos.group.v1.Query/VotesByVoter
```

Example Output:

```bash expandable
{
  "votes": [
    {
      "proposalId": "1",
      "voter": "cosmos1..",
      "choice": "CHOICE_YES",
      "submittedAt": "2021-12-17T08:05:02.490164009Z"
    }
  ],
  "pagination": {
    "total": "1"
  }
}
```

### REST

A user can query the `group` module using REST endpoints.

#### GroupInfo

The `GroupInfo` endpoint allows users to query for group info by given group id.

```bash
/cosmos/group/v1/group_info/{group_id}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/group_info/1
```

Example Output:

```bash
{
  "info": {
    "id": "1",
    "admin": "cosmos1..",
    "metadata": "AQ==",
    "version": "1",
    "total_weight": "3"
  }
}
```

#### GroupPolicyInfo

The `GroupPolicyInfo` endpoint allows users to query for group policy info by account address of group policy.

```bash
/cosmos/group/v1/group_policy_info/{address}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/group_policy_info/cosmos1..
```

Example Output:

```bash expandable
{
  "info": {
    "address": "cosmos1..",
    "group_id": "1",
    "admin": "cosmos1..",
    "metadata": "AQ==",
    "version": "1",
    "decision_policy": {
      "@type": "/cosmos.group.v1.ThresholdDecisionPolicy",
      "threshold": "1",
      "windows": {
        "voting_period": "120h",
        "min_execution_period": "0s"
      }
    },
  }
}
```

#### GroupMembers

The `GroupMembers` endpoint allows users to query for group members by group id with pagination flags.

```bash
/cosmos/group/v1/group_members/{group_id}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/group_members/1
```

Example Output:

```bash expandable
{
  "members": [
    {
      "group_id": "1",
      "member": {
        "address": "cosmos1..",
        "weight": "1",
        "metadata": "AQ=="
      }
    },
    {
      "group_id": "1",
      "member": {
        "address": "cosmos1..",
        "weight": "2",
        "metadata": "AQ=="
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "2"
  }
}
```

#### GroupsByAdmin

The `GroupsByAdmin` endpoint allows users to query for groups by admin account address with pagination flags.

```bash
/cosmos/group/v1/groups_by_admin/{admin}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/groups_by_admin/cosmos1..
```

Example Output:

```bash expandable
{
  "groups": [
    {
      "id": "1",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "total_weight": "3"
    },
    {
      "id": "2",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "total_weight": "3"
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "2"
  }
}
```

#### GroupPoliciesByGroup

The `GroupPoliciesByGroup` endpoint allows users to query for group policies by group id with pagination flags.

```bash
/cosmos/group/v1/group_policies_by_group/{group_id}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/group_policies_by_group/1
```

Example Output:

```bash expandable
{
  "group_policies": [
    {
      "address": "cosmos1..",
      "group_id": "1",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "decision_policy": {
        "@type": "/cosmos.group.v1.ThresholdDecisionPolicy",
        "threshold": "1",
        "windows": {
          "voting_period": "120h",
          "min_execution_period": "0s"
      }
      },
    },
    {
      "address": "cosmos1..",
      "group_id": "1",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "decision_policy": {
        "@type": "/cosmos.group.v1.ThresholdDecisionPolicy",
        "threshold": "1",
        "windows": {
          "voting_period": "120h",
          "min_execution_period": "0s"
      }
      },
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "2"
  }
}
```

#### GroupPoliciesByAdmin

The `GroupPoliciesByAdmin` endpoint allows users to query for group policies by admin account address with pagination flags.

```bash
/cosmos/group/v1/group_policies_by_admin/{admin}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/group_policies_by_admin/cosmos1..
```

Example Output:

```bash expandable
{
  "group_policies": [
    {
      "address": "cosmos1..",
      "group_id": "1",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "decision_policy": {
        "@type": "/cosmos.group.v1.ThresholdDecisionPolicy",
        "threshold": "1",
        "windows": {
          "voting_period": "120h",
          "min_execution_period": "0s"
      } 
      },
    },
    {
      "address": "cosmos1..",
      "group_id": "1",
      "admin": "cosmos1..",
      "metadata": "AQ==",
      "version": "1",
      "decision_policy": {
        "@type": "/cosmos.group.v1.ThresholdDecisionPolicy",
        "threshold": "1",
        "windows": {
          "voting_period": "120h",
          "min_execution_period": "0s"
      }
      },
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "2"
  }
```

#### Proposal

The `Proposal` endpoint allows users to query for proposal by id.

```bash
/cosmos/group/v1/proposal/{proposal_id}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/proposal/1
```

Example Output:

```bash expandable
{
  "proposal": {
    "proposal_id": "1",
    "address": "cosmos1..",
    "metadata": "AQ==",
    "proposers": [
      "cosmos1.."
    ],
    "submitted_at": "2021-12-17T07:06:26.310638964Z",
    "group_version": "1",
    "group_policy_version": "1",
    "status": "STATUS_SUBMITTED",
    "result": "RESULT_UNFINALIZED",
    "vote_state": {
      "yes_count": "0",
      "no_count": "0",
      "abstain_count": "0",
      "veto_count": "0"
    },
    "windows": {
      "min_execution_period": "0s",
      "voting_period": "432000s"
    },
    "executor_result": "EXECUTOR_RESULT_NOT_RUN",
    "messages": [
      {
        "@type": "/cosmos.bank.v1beta1.MsgSend",
        "from_address": "cosmos1..",
        "to_address": "cosmos1..",
        "amount": [
          {
            "denom": "stake",
            "amount": "100000000"
          }
        ]
      }
    ],
    "title": "Title",
    "summary": "Summary",
  }
}
```

#### ProposalsByGroupPolicy

The `ProposalsByGroupPolicy` endpoint allows users to query for proposals by account address of group policy with pagination flags.

```bash
/cosmos/group/v1/proposals_by_group_policy/{address}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/proposals_by_group_policy/cosmos1..
```

Example Output:

```bash expandable
{
  "proposals": [
    {
      "id": "1",
      "group_policy_address": "cosmos1..",
      "metadata": "AQ==",
      "proposers": [
        "cosmos1.."
      ],
      "submit_time": "2021-12-17T08:03:27.099649352Z",
      "group_version": "1",
      "group_policy_version": "1",
      "status": "STATUS_CLOSED",
      "result": "RESULT_ACCEPTED",
      "vote_state": {
        "yes_count": "1",
        "no_count": "0",
        "abstain_count": "0",
        "veto_count": "0"
      },
      "windows": {
        "min_execution_period": "0s",
        "voting_period": "432000s"
      },
      "executor_result": "EXECUTOR_RESULT_NOT_RUN",
      "messages": [
        {
          "@type": "/cosmos.bank.v1beta1.MsgSend",
          "from_address": "cosmos1..",
          "to_address": "cosmos1..",
          "amount": [
            {
              "denom": "stake",
              "amount": "100000000"
            }
          ]
        }
      ]
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "1"
  }
}
```

#### VoteByProposalVoter

The `VoteByProposalVoter` endpoint allows users to query for vote by proposal id and voter account address.

```bash
/cosmos/group/v1/vote_by_proposal_voter/{proposal_id}/{voter}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1beta1/vote_by_proposal_voter/1/cosmos1..
```

Example Output:

```bash
{
  "vote": {
    "proposal_id": "1",
    "voter": "cosmos1..",
    "choice": "CHOICE_YES",
    "metadata": "AQ==",
    "submitted_at": "2021-12-17T08:05:02.490164009Z"
  }
}
```

#### VotesByProposal

The `VotesByProposal` endpoint allows users to query for votes by proposal id with pagination flags.

```bash
/cosmos/group/v1/votes_by_proposal/{proposal_id}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/votes_by_proposal/1
```

Example Output:

```bash expandable
{
  "votes": [
    {
      "proposal_id": "1",
      "voter": "cosmos1..",
      "option": "CHOICE_YES",
      "metadata": "AQ==",
      "submit_time": "2021-12-17T08:05:02.490164009Z"
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "1"
  }
}
```

#### VotesByVoter

The `VotesByVoter` endpoint allows users to query for votes by voter account address with pagination flags.

```bash
/cosmos/group/v1/votes_by_voter/{voter}
```

Example:

```bash
curl localhost:1317/cosmos/group/v1/votes_by_voter/cosmos1..
```

Example Output:

```bash expandable
{
  "votes": [
    {
      "proposal_id": "1",
      "voter": "cosmos1..",
      "choice": "CHOICE_YES",
      "metadata": "AQ==",
      "submitted_at": "2021-12-17T08:05:02.490164009Z"
    }
  ],
  "pagination": {
    "next_key": null,
    "total": "1"
  }
}
```

## Metadata

The group module has four locations for metadata where users can provide further context about the on-chain actions they are taking. By default all metadata fields have a 255 character length field where metadata can be stored in json format, either on-chain or off-chain depending on the amount of data required. Here we provide a recommendation for the json structure and where the data should be stored. There are two important factors in making these recommendations. First, that the group and gov modules are consistent with one another, note the number of proposals made by all groups may be quite large. Second, that client applications such as block explorers and governance interfaces have confidence in the consistency of metadata structure across chains.

### Proposal

Location: off-chain as json object stored on IPFS (mirrors [gov proposal](/docs/sdk/v0.50/gov/README#metadata))

```json
{
  "title": "",
  "authors": [""],
  "summary": "",
  "details": "",
  "proposal_forum_url": "",
  "vote_option_context": "",
}
```

<Note>
The `authors` field is an array of strings, this is to allow for multiple authors to be listed in the metadata.
In v0.46, the `authors` field is a comma-separated string. Frontends are encouraged to support both formats for backwards compatibility.
</Note>

### Vote

Location: on-chain as json within 255 character limit (mirrors [gov vote](/docs/sdk/v0.50/gov/README#metadata))

```json
{
  "justification": "",
}
```

### Group

Location: off-chain as json object stored on IPFS

```json
{
  "name": "",
  "description": "",
  "group_website_url": "",
  "group_forum_url": "",
}
```

### Decision policy

Location: on-chain as json within 255 character limit

```json
{
  "name": "",
  "description": "",
}
```
