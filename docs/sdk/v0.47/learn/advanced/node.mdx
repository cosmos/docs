---
title: Node Client (Daemon)
---

<Note>
**Synopsis**
The main endpoint of a Cosmos SDK application is the daemon client, otherwise known as the full-node client. The full-node runs the state-machine, starting from a genesis file. It connects to peers running the same client in order to receive and relay transactions, block proposals and signatures. The full-node is constituted of the application, defined with the Cosmos SDK, and of a consensus engine connected to the application via the ABCI.
</Note>

<Note>

### Pre-requisite Readings

* [Anatomy of an SDK application](/docs/sdk/v0.47/beginner/overview-app)

</Note>

## `main` function

The full-node client of any Cosmos SDK application is built by running a `main` function. The client is generally named by appending the `-d` suffix to the application name (e.g. `appd` for an application named `app`), and the `main` function is defined in a `./appd/cmd/main.go` file. Running this function creates an executable `appd` that comes with a set of commands. For an app named `app`, the main command is [`appd start`](#start-command), which starts the full-node.

In general, developers will implement the `main.go` function with the following structure:

* First, an [`encodingCodec`](encoding) is instantiated for the application.
* Then, the `config` is retrieved and config parameters are set. This mainly involves setting the Bech32 prefixes for [addresses](/docs/sdk/v0.47/beginner/accounts#addresses).

```go expandable
package types

import (
    
	"context"
    "fmt"
    "sync"
    "github.com/cosmos/cosmos-sdk/version"
)

// DefaultKeyringServiceName defines a default service name for the keyring.
const DefaultKeyringServiceName = "cosmos"

// Config is the structure that holds the SDK configuration parameters.
// This could be used to initialize certain configuration parameters for the SDK.
type Config struct {
    fullFundraiserPath  string
	bech32AddressPrefix map[string]string
	txEncoder           TxEncoder
	addressVerifier     func([]byte)

error
	mtx                 sync.RWMutex

	// SLIP-44 related
	purpose  uint32
	coinType uint32

	sealed   bool
	sealedch chan struct{
}
}

// cosmos-sdk wide global singleton
var (
	sdkConfig  *Config
	initConfig sync.Once
)

// New returns a new Config with default values.
func NewConfig() *Config {
    return &Config{
    sealedch: make(chan struct{
}),
		bech32AddressPrefix: map[string]string{
			"account_addr":   Bech32PrefixAccAddr,
			"validator_addr": Bech32PrefixValAddr,
			"consensus_addr": Bech32PrefixConsAddr,
			"account_pub":    Bech32PrefixAccPub,
			"validator_pub":  Bech32PrefixValPub,
			"consensus_pub":  Bech32PrefixConsPub,
},
		fullFundraiserPath: FullFundraiserPath,

		purpose:   Purpose,
		coinType:  CoinType,
		txEncoder: nil,
}
}

// GetConfig returns the config instance for the SDK.
func GetConfig() *Config {
    initConfig.Do(func() {
    sdkConfig = NewConfig()
})

return sdkConfig
}

// GetSealedConfig returns the config instance for the SDK if/once it is sealed.
func GetSealedConfig(ctx context.Context) (*Config, error) {
    config := GetConfig()

select {
    case <-config.sealedch:
		return config, nil
    case <-ctx.Done():
		return nil, ctx.Err()
}
}

func (config *Config)

assertNotSealed() {
    config.mtx.Lock()

defer config.mtx.Unlock()
    if config.sealed {
    panic("Config is sealed")
}
}

// SetBech32PrefixForAccount builds the Config with Bech32 addressPrefix and publKeyPrefix for accounts
// and returns the config instance
func (config *Config)

SetBech32PrefixForAccount(addressPrefix, pubKeyPrefix string) {
    config.assertNotSealed()

config.bech32AddressPrefix["account_addr"] = addressPrefix
	config.bech32AddressPrefix["account_pub"] = pubKeyPrefix
}

// SetBech32PrefixForValidator builds the Config with Bech32 addressPrefix and publKeyPrefix for validators
//
//	and returns the config instance
func (config *Config)

SetBech32PrefixForValidator(addressPrefix, pubKeyPrefix string) {
    config.assertNotSealed()

config.bech32AddressPrefix["validator_addr"] = addressPrefix
	config.bech32AddressPrefix["validator_pub"] = pubKeyPrefix
}

// SetBech32PrefixForConsensusNode builds the Config with Bech32 addressPrefix and publKeyPrefix for consensus nodes
// and returns the config instance
func (config *Config)

SetBech32PrefixForConsensusNode(addressPrefix, pubKeyPrefix string) {
    config.assertNotSealed()

config.bech32AddressPrefix["consensus_addr"] = addressPrefix
	config.bech32AddressPrefix["consensus_pub"] = pubKeyPrefix
}

// SetTxEncoder builds the Config with TxEncoder used to marshal StdTx to bytes
func (config *Config)

SetTxEncoder(encoder TxEncoder) {
    config.assertNotSealed()

config.txEncoder = encoder
}

// SetAddressVerifier builds the Config with the provided function for verifying that addresses
// have the correct format
func (config *Config)

SetAddressVerifier(addressVerifier func([]byte)

error) {
    config.assertNotSealed()

config.addressVerifier = addressVerifier
}

// Set the FullFundraiserPath (BIP44Prefix)

on the config.
//
// Deprecated: This method is supported for backward compatibility only and will be removed in a future release. Use SetPurpose and SetCoinType instead.
func (config *Config)

SetFullFundraiserPath(fullFundraiserPath string) {
    config.assertNotSealed()

config.fullFundraiserPath = fullFundraiserPath
}

// Set the BIP-0044 Purpose code on the config
func (config *Config)

SetPurpose(purpose uint32) {
    config.assertNotSealed()

config.purpose = purpose
}

// Set the BIP-0044 CoinType code on the config
func (config *Config)

SetCoinType(coinType uint32) {
    config.assertNotSealed()

config.coinType = coinType
}

// Seal seals the config such that the config state could not be modified further
func (config *Config)

Seal() *Config {
    config.mtx.Lock()
    if config.sealed {
    config.mtx.Unlock()

return config
}

	// signal sealed after state exposed/unlocked
	config.sealed = true
	config.mtx.Unlock()

close(config.sealedch)

return config
}

// GetBech32AccountAddrPrefix returns the Bech32 prefix for account address
func (config *Config)

GetBech32AccountAddrPrefix()

string {
    return config.bech32AddressPrefix["account_addr"]
}

// GetBech32ValidatorAddrPrefix returns the Bech32 prefix for validator address
func (config *Config)

GetBech32ValidatorAddrPrefix()

string {
    return config.bech32AddressPrefix["validator_addr"]
}

// GetBech32ConsensusAddrPrefix returns the Bech32 prefix for consensus node address
func (config *Config)

GetBech32ConsensusAddrPrefix()

string {
    return config.bech32AddressPrefix["consensus_addr"]
}

// GetBech32AccountPubPrefix returns the Bech32 prefix for account public key
func (config *Config)

GetBech32AccountPubPrefix()

string {
    return config.bech32AddressPrefix["account_pub"]
}

// GetBech32ValidatorPubPrefix returns the Bech32 prefix for validator public key
func (config *Config)

GetBech32ValidatorPubPrefix()

string {
    return config.bech32AddressPrefix["validator_pub"]
}

// GetBech32ConsensusPubPrefix returns the Bech32 prefix for consensus node public key
func (config *Config)

GetBech32ConsensusPubPrefix()

string {
    return config.bech32AddressPrefix["consensus_pub"]
}

// GetTxEncoder return function to encode transactions
func (config *Config)

GetTxEncoder()

TxEncoder {
    return config.txEncoder
}

// GetAddressVerifier returns the function to verify that addresses have the correct format
func (config *Config)

GetAddressVerifier()

func([]byte)

error {
    return config.addressVerifier
}

// GetPurpose returns the BIP-0044 Purpose code on the config.
func (config *Config)

GetPurpose()

uint32 {
    return config.purpose
}

// GetCoinType returns the BIP-0044 CoinType code on the config.
func (config *Config)

GetCoinType()

uint32 {
    return config.coinType
}

// GetFullFundraiserPath returns the BIP44Prefix.
//
// Deprecated: This method is supported for backward compatibility only and will be removed in a future release. Use GetFullBIP44Path instead.
func (config *Config)

GetFullFundraiserPath()

string {
    return config.fullFundraiserPath
}

// GetFullBIP44Path returns the BIP44Prefix.
func (config *Config)

GetFullBIP44Path()

string {
    return fmt.Sprintf("m/%d'/%d'/0'/0/0", config.purpose, config.coinType)
}

func KeyringServiceName()

string {
    if len(version.Name) == 0 {
    return DefaultKeyringServiceName
}

return version.Name
}
```

* Using [cobra](https://github.com/spf13/cobra), the root command of the full-node client is created. After that, all the custom commands of the application are added using the `AddCommand()` method of `rootCmd`.
* Add default server commands to `rootCmd` using the `server.AddCommands()` method. These commands are separated from the ones added above since they are standard and defined at Cosmos SDK level. They should be shared by all Cosmos SDK-based applications. They include the most important command: the [`start` command](#start-command).
* Prepare and execute the `executor`.

```go expandable
package cli

import (
    
	"fmt"
    "os"
    "path/filepath"
    "runtime"
    "strings"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
)

const (
	HomeFlag     = "home"
	TraceFlag    = "trace"
	OutputFlag   = "output"
	EncodingFlag = "encoding"
)

// Executable is the minimal interface to *corba.Command, so we can
// wrap if desired before the test
type Executable interface {
    Execute()

error
}

// PrepareBaseCmd is meant for CometBFT and other servers
func PrepareBaseCmd(cmd *cobra.Command, envPrefix, defaultHome string)

Executor {
    cobra.OnInitialize(func() {
    initEnv(envPrefix)
})

cmd.PersistentFlags().StringP(HomeFlag, "", defaultHome, "directory for config and data")

cmd.PersistentFlags().Bool(TraceFlag, false, "print out full stack trace on errors")

cmd.PersistentPreRunE = concatCobraCmdFuncs(bindFlagsLoadViper, cmd.PersistentPreRunE)

return Executor{
    cmd, os.Exit
}
}

// PrepareMainCmd is meant for client side libs that want some more flags
//
// This adds --encoding (hex, btc, base64)

and --output (text, json)

to
// the command.  These only really make sense in interactive commands.
func PrepareMainCmd(cmd *cobra.Command, envPrefix, defaultHome string)

Executor {
    cmd.PersistentFlags().StringP(EncodingFlag, "e", "hex", "Binary encoding (hex|b64|btc)")

cmd.PersistentFlags().StringP(OutputFlag, "o", "text", "Output format (text|json)")

cmd.PersistentPreRunE = concatCobraCmdFuncs(validateOutput, cmd.PersistentPreRunE)

return PrepareBaseCmd(cmd, envPrefix, defaultHome)
}

// initEnv sets to use ENV variables if set.
func initEnv(prefix string) {
    copyEnvVars(prefix)

	// env variables with TM prefix (eg. TM_ROOT)

viper.SetEnvPrefix(prefix)

viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_", "-", "_"))

viper.AutomaticEnv()
}

// This copies all variables like TMROOT to TM_ROOT,
// so we can support both formats for the user
func copyEnvVars(prefix string) {
    prefix = strings.ToUpper(prefix)
    ps := prefix + "_"
    for _, e := range os.Environ() {
    kv := strings.SplitN(e, "=", 2)
    if len(kv) == 2 {
    k, v := kv[0], kv[1]
    if strings.HasPrefix(k, prefix) && !strings.HasPrefix(k, ps) {
    k2 := strings.Replace(k, prefix, ps, 1)

os.Setenv(k2, v)
}
	
}
	
}
}

// Executor wraps the cobra Command with a nicer Execute method
type Executor struct {
	*cobra.Command
	Exit func(int) // this is os.Exit by default, override in tests
}

type ExitCoder interface {
    ExitCode()

int
}

// execute adds all child commands to the root command sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func (e Executor)

Execute()

error {
    e.SilenceUsage = true
	e.SilenceErrors = true
    err := e.Command.Execute()
    if err != nil {
    if viper.GetBool(TraceFlag) {
    const size = 64 << 10
    buf := make([]byte, size)

buf = buf[:runtime.Stack(buf, false)]
			fmt.Fprintf(os.Stderr, "ERROR: %v\n%s\n", err, buf)
}

else {
    fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
}

		// return error code 1 by default, can override it with a special error type
    exitCode := 1
    if ec, ok := err.(ExitCoder); ok {
    exitCode = ec.ExitCode()
}

e.Exit(exitCode)
}

return err
}

type cobraCmdFunc func(cmd *cobra.Command, args []string)

error

// Returns a single function that calls each argument function in sequence
// RunE, PreRunE, PersistentPreRunE, etc. all have this same signature
func concatCobraCmdFuncs(fs ...cobraCmdFunc)

cobraCmdFunc {
    return func(cmd *cobra.Command, args []string)

error {
    for _, f := range fs {
    if f != nil {
    if err := f(cmd, args); err != nil {
    return err
}
	
}
	
}

return nil
}
}

// Bind all flags and read the config into viper
func bindFlagsLoadViper(cmd *cobra.Command, args []string)

error {
	// cmd.Flags()

includes flags from this command and all persistent flags from the parent
    if err := viper.BindPFlags(cmd.Flags()); err != nil {
    return err
}
    homeDir := viper.GetString(HomeFlag)

viper.Set(HomeFlag, homeDir)

viper.SetConfigName("config")                         // name of config file (without extension)

viper.AddConfigPath(homeDir)                          // search root directory
	viper.AddConfigPath(filepath.Join(homeDir, "config")) // search root directory /config

	// If a config file is found, read it in.
    if err := viper.ReadInConfig(); err == nil {
		// stderr, so if we redirect output to json file, this doesn't appear
		// fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
}

else if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
		// ignore not found error, return other errors
		return err
}

return nil
}

func validateOutput(cmd *cobra.Command, args []string)

error {
	// validate output format
    output := viper.GetString(OutputFlag)
    switch output {
    case "text", "json":
	default:
		return fmt.Errorf("unsupported output format: %s", output)
}

return nil
}
```

See an example of `main` function from the `simapp` application, the Cosmos SDK's application for demo purposes:

```go expandable
package main

import (
    
	"os"
    "cosmossdk.io/simapp"
    "cosmossdk.io/simapp/simd/cmd"
    "github.com/cosmos/cosmos-sdk/server"
	svrcmd "github.com/cosmos/cosmos-sdk/server/cmd"
)

func main() {
    rootCmd := cmd.NewRootCmd()
    if err := svrcmd.Execute(rootCmd, "", simapp.DefaultNodeHome); err != nil {
    switch e := err.(type) {
    case server.ErrorCode:
			os.Exit(e.Code)

default:
			os.Exit(1)
}
	
}
}
```

## `start` command

The `start` command is defined in the `/server` folder of the Cosmos SDK. It is added to the root command of the full-node client in the [`main` function](#main-function) and called by the end-user to start their node:

```bash
# For an example app named "app", the following command starts the full-node.
appd start

# Using the Cosmos SDK's own simapp, the following commands start the simapp node.
simd start
```

As a reminder, the full-node is composed of three conceptual layers: the networking layer, the consensus layer and the application layer. The first two are generally bundled together in an entity called the consensus engine (CometBFT by default), while the third is the state-machine defined with the help of the Cosmos SDK. Currently, the Cosmos SDK uses CometBFT as the default consensus engine, meaning the start command is implemented to boot up a CometBFT node.

The flow of the `start` command is pretty straightforward. First, it retrieves the `config` from the `context` in order to open the `db` (a [`leveldb`](https://github.com/syndtr/goleveldb) instance by default). This `db` contains the latest known state of the application (empty if the application is started from the first time.

With the `db`, the `start` command creates a new instance of the application using an `appCreator` function:

```go expandable
package server

// DONTCOVER

import (
    
	"errors"
    "fmt"
    "net"
    "net/http"
    "os"
    "runtime/pprof"
    "time"
    "github.com/spf13/cobra"
    "github.com/tendermint/tendermint/abci/server"
	tcmd "github.com/tendermint/tendermint/cmd/tendermint/commands"
    "github.com/tendermint/tendermint/node"
    "github.com/tendermint/tendermint/p2p"
	pvm "github.com/tendermint/tendermint/privval"
    "github.com/tendermint/tendermint/proxy"
    "github.com/tendermint/tendermint/rpc/client/local"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "cosmossdk.io/tools/rosetta"
	crgserver "cosmossdk.io/tools/rosetta/lib/server"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/codec"
    "github.com/cosmos/cosmos-sdk/server/api"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servergrpc "github.com/cosmos/cosmos-sdk/server/grpc"
    "github.com/cosmos/cosmos-sdk/server/types"
	pruningtypes "github.com/cosmos/cosmos-sdk/store/pruning/types"
    "github.com/cosmos/cosmos-sdk/telemetry"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/mempool"
)

const (
	// Tendermint full-node start flags
	flagWithTendermint     = "with-tendermint"
	flagAddress            = "address"
	flagTransport          = "transport"
	flagTraceStore         = "trace-store"
	flagCPUProfile         = "cpu-profile"
	FlagMinGasPrices       = "minimum-gas-prices"
	FlagHaltHeight         = "halt-height"
	FlagHaltTime           = "halt-time"
	FlagInterBlockCache    = "inter-block-cache"
	FlagUnsafeSkipUpgrades = "unsafe-skip-upgrades"
	FlagTrace              = "trace"
	FlagInvCheckPeriod     = "inv-check-period"

	FlagPruning             = "pruning"
	FlagPruningKeepRecent   = "pruning-keep-recent"
	FlagPruningInterval     = "pruning-interval"
	FlagIndexEvents         = "index-events"
	FlagMinRetainBlocks     = "min-retain-blocks"
	FlagIAVLCacheSize       = "iavl-cache-size"
	FlagDisableIAVLFastNode = "iavl-disable-fastnode"

	// state sync-related flags
	FlagStateSyncSnapshotInterval   = "state-sync.snapshot-interval"
	FlagStateSyncSnapshotKeepRecent = "state-sync.snapshot-keep-recent"

	// api-related flags
	FlagAPIEnable             = "api.enable"
	FlagAPISwagger            = "api.swagger"
	FlagAPIAddress            = "api.address"
	FlagAPIMaxOpenConnections = "api.max-open-connections"
	FlagRPCReadTimeout        = "api.rpc-read-timeout"
	FlagRPCWriteTimeout       = "api.rpc-write-timeout"
	FlagRPCMaxBodyBytes       = "api.rpc-max-body-bytes"
	FlagAPIEnableUnsafeCORS   = "api.enabled-unsafe-cors"

	// gRPC-related flags
	flagGRPCOnly       = "grpc-only"
	flagGRPCEnable     = "grpc.enable"
	flagGRPCAddress    = "grpc.address"
	flagGRPCWebEnable  = "grpc-web.enable"
	flagGRPCWebAddress = "grpc-web.address"

	// mempool flags
	FlagMempoolMaxTxs = "mempool.max-txs"
)

// StartCmd runs the service passed in, either stand-alone or in-process with
// Tendermint.
func StartCmd(appCreator types.AppCreator, defaultNodeHome string) *cobra.Command {
    cmd := &cobra.Command{
    Use:   "start",
    Short: "Run the full node",
    Long: `Run the full node application with Tendermint in or out of process. By
default, the application will run with Tendermint in process.

Pruning options can be provided via the '--pruning' flag or alternatively with '--pruning-keep-recent', and
'pruning-interval' together.

For '--pruning' the options are as follows:

default: the last 362880 states are kept, pruning at 10 block intervals
nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)

everything: 2 latest states will be kept; pruning at 10 block intervals.
custom: allow pruning options to be manually specified through 'pruning-keep-recent', and 'pruning-interval'

Node halting configurations exist in the form of two flags: '--halt-height' and '--halt-time'. During
the ABCI Commit phase, the node will check if the current block height is greater than or equal to
the halt-height or if the current block time is greater than or equal to the halt-time. If so, the
node will attempt to gracefully shutdown and the block will not be committed. In addition, the node
will not be able to commit subsequent blocks.

For profiling and benchmarking purposes, CPU profiling can be enabled via the '--cpu-profile' flag
which accepts a path for the resulting pprof file.

The node may be started in a 'query only' mode where only the gRPC and JSON HTTP
API services are enabled via the 'grpc-only' flag. In this mode, Tendermint is
bypassed and can be used when legacy queries are needed after an on-chain upgrade
is performed. Note, when enabled, gRPC will also be automatically enabled.
`,
    PreRunE: func(cmd *cobra.Command, _ []string)

error {
    serverCtx := GetServerContextFromCmd(cmd)

			// Bind flags to the Context's Viper so the app construction can set
			// options accordingly.
    if err := serverCtx.Viper.BindPFlags(cmd.Flags()); err != nil {
    return err
}

			_, err := GetPruningOptionsFromFlags(serverCtx.Viper)

return err
},
    RunE: func(cmd *cobra.Command, _ []string)

error {
    serverCtx := GetServerContextFromCmd(cmd)

clientCtx, err := client.GetClientQueryContext(cmd)
    if err != nil {
    return err
}

withTM, _ := cmd.Flags().GetBool(flagWithTendermint)
    if !withTM {
    serverCtx.Logger.Info("starting ABCI without Tendermint")

return startStandAlone(serverCtx, appCreator)
}

			// amino is needed here for backwards compatibility of REST routes
			err = startInProcess(serverCtx, clientCtx, appCreator)

errCode, ok := err.(ErrorCode)
    if !ok {
    return err
}

serverCtx.Logger.Debug(fmt.Sprintf("received quit signal: %d", errCode.Code))

return nil
},
}

cmd.Flags().String(flags.FlagHome, defaultNodeHome, "The application home directory")

cmd.Flags().Bool(flagWithTendermint, true, "Run abci app embedded in-process with tendermint")

cmd.Flags().String(flagAddress, "tcp://0.0.0.0:26658", "Listen address")

cmd.Flags().String(flagTransport, "socket", "Transport protocol: socket, grpc")

cmd.Flags().String(flagTraceStore, "", "Enable KVStore tracing to an output file")

cmd.Flags().String(FlagMinGasPrices, "", "Minimum gas prices to accept for transactions; Any fee in a tx must meet this minimum (e.g. 0.01photino;0.0001stake)")

cmd.Flags().IntSlice(FlagUnsafeSkipUpgrades, []int{
}, "Skip a set of upgrade heights to continue the old binary")

cmd.Flags().Uint64(FlagHaltHeight, 0, "Block height at which to gracefully halt the chain and shutdown the node")

cmd.Flags().Uint64(FlagHaltTime, 0, "Minimum block time (in Unix seconds)

at which to gracefully halt the chain and shutdown the node")

cmd.Flags().Bool(FlagInterBlockCache, true, "Enable inter-block caching")

cmd.Flags().String(flagCPUProfile, "", "Enable CPU profiling and write to the provided file")

cmd.Flags().Bool(FlagTrace, false, "Provide full stack traces for errors in ABCI Log")

cmd.Flags().String(FlagPruning, pruningtypes.PruningOptionDefault, "Pruning strategy (default|nothing|everything|custom)")

cmd.Flags().Uint64(FlagPruningKeepRecent, 0, "Number of recent heights to keep on disk (ignored if pruning is not 'custom')")

cmd.Flags().Uint64(FlagPruningInterval, 0, "Height interval at which pruned heights are removed from disk (ignored if pruning is not 'custom')")

cmd.Flags().Uint(FlagInvCheckPeriod, 0, "Assert registered invariants every N blocks")

cmd.Flags().Uint64(FlagMinRetainBlocks, 0, "Minimum block height offset during ABCI commit to prune Tendermint blocks")

cmd.Flags().Bool(FlagAPIEnable, false, "Define if the API server should be enabled")

cmd.Flags().Bool(FlagAPISwagger, false, "Define if swagger documentation should automatically be registered (Note: the API must also be enabled)")

cmd.Flags().String(FlagAPIAddress, serverconfig.DefaultAPIAddress, "the API server address to listen on")

cmd.Flags().Uint(FlagAPIMaxOpenConnections, 1000, "Define the number of maximum open connections")

cmd.Flags().Uint(FlagRPCReadTimeout, 10, "Define the Tendermint RPC read timeout (in seconds)")

cmd.Flags().Uint(FlagRPCWriteTimeout, 0, "Define the Tendermint RPC write timeout (in seconds)")

cmd.Flags().Uint(FlagRPCMaxBodyBytes, 1000000, "Define the Tendermint maximum response body (in bytes)")

cmd.Flags().Bool(FlagAPIEnableUnsafeCORS, false, "Define if CORS should be enabled (unsafe - use it at your own risk)")

cmd.Flags().Bool(flagGRPCOnly, false, "Start the node in gRPC query only mode (no Tendermint process is started)")

cmd.Flags().Bool(flagGRPCEnable, true, "Define if the gRPC server should be enabled")

cmd.Flags().String(flagGRPCAddress, serverconfig.DefaultGRPCAddress, "the gRPC server address to listen on")

cmd.Flags().Bool(flagGRPCWebEnable, true, "Define if the gRPC-Web server should be enabled. (Note: gRPC must also be enabled)")

cmd.Flags().String(flagGRPCWebAddress, serverconfig.DefaultGRPCWebAddress, "The gRPC-Web server address to listen on")

cmd.Flags().Uint64(FlagStateSyncSnapshotInterval, 0, "State sync snapshot interval")

cmd.Flags().Uint32(FlagStateSyncSnapshotKeepRecent, 2, "State sync snapshot to keep")

cmd.Flags().Bool(FlagDisableIAVLFastNode, false, "Disable fast node for IAVL tree")

cmd.Flags().Int(FlagMempoolMaxTxs, mempool.DefaultMaxTx, "Sets MaxTx value for the app-side mempool")

	// add support for all Tendermint-specific command line options
	tcmd.AddNodeFlags(cmd)

return cmd
}

func startStandAlone(ctx *Context, appCreator types.AppCreator)

error {
    addr := ctx.Viper.GetString(flagAddress)
    transport := ctx.Viper.GetString(flagTransport)
    home := ctx.Viper.GetString(flags.FlagHome)

db, err := openDB(home, GetAppDBBackend(ctx.Viper))
    if err != nil {
    return err
}
    traceWriterFile := ctx.Viper.GetString(flagTraceStore)

traceWriter, err := openTraceWriter(traceWriterFile)
    if err != nil {
    return err
}
    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)

config, err := serverconfig.GetConfig(ctx.Viper)
    if err != nil {
    return err
}

	_, err = startTelemetry(config)
    if err != nil {
    return err
}

svr, err := server.NewServer(addr, transport, app)
    if err != nil {
    return fmt.Errorf("error creating listener: %v", err)
}

svr.SetLogger(ctx.Logger.With("module", "abci-server"))

err = svr.Start()
    if err != nil {
    fmt.Println(err.Error())

os.Exit(1)
}

defer func() {
    if err = svr.Stop(); err != nil {
    fmt.Println(err.Error())

os.Exit(1)
}
	
}()

	// Wait for SIGINT or SIGTERM signal
	return WaitForQuitSignals()
}

func startInProcess(ctx *Context, clientCtx client.Context, appCreator types.AppCreator)

error {
    cfg := ctx.Config
    home := cfg.RootDir
	var cpuProfileCleanup func()
    if cpuProfile := ctx.Viper.GetString(flagCPUProfile); cpuProfile != "" {
    f, err := os.Create(cpuProfile)
    if err != nil {
    return err
}

ctx.Logger.Info("starting CPU profiler", "profile", cpuProfile)
    if err := pprof.StartCPUProfile(f); err != nil {
    return err
}

cpuProfileCleanup = func() {
    ctx.Logger.Info("stopping CPU profiler", "profile", cpuProfile)

pprof.StopCPUProfile()
    if err := f.Close(); err != nil {
    ctx.Logger.Info("failed to close cpu-profile file", "profile", cpuProfile, "err", err.Error())
}
	
}
	
}

db, err := openDB(home, GetAppDBBackend(ctx.Viper))
    if err != nil {
    return err
}
    traceWriterFile := ctx.Viper.GetString(flagTraceStore)

traceWriter, err := openTraceWriter(traceWriterFile)
    if err != nil {
    return err
}

	// Clean up the traceWriter in the cpuProfileCleanup routine that is invoked
	// when the server is shutting down.
    fn := cpuProfileCleanup
	cpuProfileCleanup = func() {
    if fn != nil {
    fn()
}

		// if flagTraceStore is not used then traceWriter is nil
    if traceWriter != nil {
    if err = traceWriter.Close(); err != nil {
    ctx.Logger.Error("failed to close trace writer", "err", err)
}
	
}
	
}

config, err := serverconfig.GetConfig(ctx.Viper)
    if err != nil {
    return err
}
    if err := config.ValidateBasic(); err != nil {
    return err
}
    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)

nodeKey, err := p2p.LoadOrGenNodeKey(cfg.NodeKeyFile())
    if err != nil {
    return err
}
    genDocProvider := node.DefaultGenesisDocProviderFunc(cfg)

var (
		tmNode   *node.Node
		gRPCOnly = ctx.Viper.GetBool(flagGRPCOnly)
	)
    if gRPCOnly {
    ctx.Logger.Info("starting node in gRPC only mode; Tendermint is disabled")

config.GRPC.Enable = true
}

else {
    ctx.Logger.Info("starting node with ABCI Tendermint in-process")

tmNode, err = node.NewNode(
			cfg,
			pvm.LoadOrGenFilePV(cfg.PrivValidatorKeyFile(), cfg.PrivValidatorStateFile()),
			nodeKey,
			proxy.NewLocalClientCreator(app),
			genDocProvider,
			node.DefaultDBProvider,
			node.DefaultMetricsProvider(cfg.Instrumentation),
			ctx.Logger,
		)
    if err != nil {
    return err
}
    if err := tmNode.Start(); err != nil {
    return err
}
	
}

	// Add the tx service to the gRPC router. We only need to register this
	// service if API or gRPC is enabled, and avoid doing so in the general
	// case, because it spawns a new local tendermint RPC client.
    if (config.API.Enable || config.GRPC.Enable) && tmNode != nil {
		// re-assign for making the client available below
		// do not use := to avoid shadowing clientCtx
		clientCtx = clientCtx.WithClient(local.New(tmNode))

app.RegisterTxService(clientCtx)

app.RegisterTendermintService(clientCtx)

app.RegisterNodeService(clientCtx)
}

metrics, err := startTelemetry(config)
    if err != nil {
    return err
}

var apiSrv *api.Server
    if config.API.Enable {
    genDoc, err := genDocProvider()
    if err != nil {
    return err
}
    clientCtx := clientCtx.WithHomeDir(home).WithChainID(genDoc.ChainID)
    if config.GRPC.Enable {
			_, port, err := net.SplitHostPort(config.GRPC.Address)
    if err != nil {
    return err
}
    maxSendMsgSize := config.GRPC.MaxSendMsgSize
    if maxSendMsgSize == 0 {
    maxSendMsgSize = serverconfig.DefaultGRPCMaxSendMsgSize
}
    maxRecvMsgSize := config.GRPC.MaxRecvMsgSize
    if maxRecvMsgSize == 0 {
    maxRecvMsgSize = serverconfig.DefaultGRPCMaxRecvMsgSize
}
    grpcAddress := fmt.Sprintf("127.0.0.1:%s", port)

			// If grpc is enabled, configure grpc client for grpc gateway.
			grpcClient, err := grpc.Dial(
				grpcAddress,
				grpc.WithTransportCredentials(insecure.NewCredentials()),
				grpc.WithDefaultCallOptions(
					grpc.ForceCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),
					grpc.MaxCallRecvMsgSize(maxRecvMsgSize),
					grpc.MaxCallSendMsgSize(maxSendMsgSize),
				),
			)
    if err != nil {
    return err
}

clientCtx = clientCtx.WithGRPCClient(grpcClient)

ctx.Logger.Debug("grpc client assigned to client context", "target", grpcAddress)
}

apiSrv = api.New(clientCtx, ctx.Logger.With("module", "api-server"))

app.RegisterAPIRoutes(apiSrv, config.API)
    if config.Telemetry.Enabled {
    apiSrv.SetTelemetry(metrics)
}
    errCh := make(chan error)

go func() {
    if err := apiSrv.Start(config); err != nil {
    errCh <- err
}
	
}()

select {
    case err := <-errCh:
			return err
    case <-time.After(types.ServerStartTime): // assume server started successfully
}
	
}

var (
		grpcSrv    *grpc.Server
		grpcWebSrv *http.Server
	)
    if config.GRPC.Enable {
    grpcSrv, err = servergrpc.StartGRPCServer(clientCtx, app, config.GRPC)
    if err != nil {
    return err
}

defer grpcSrv.Stop()
    if config.GRPCWeb.Enable {
    grpcWebSrv, err = servergrpc.StartGRPCWeb(grpcSrv, config)
    if err != nil {
    ctx.Logger.Error("failed to start grpc-web http server: ", err)

return err
}

defer func() {
    if err := grpcWebSrv.Close(); err != nil {
    ctx.Logger.Error("failed to close grpc-web http server: ", err)
}
	
}()
}
	
}

	// At this point it is safe to block the process if we're in gRPC only mode as
	// we do not need to start Rosetta or handle any Tendermint related processes.
    if gRPCOnly {
		// wait for signal capture and gracefully return
		return WaitForQuitSignals()
}

var rosettaSrv crgserver.Server
    if config.Rosetta.Enable {
    offlineMode := config.Rosetta.Offline

		// If GRPC is not enabled rosetta cannot work in online mode, so we throw an error.
    if !config.GRPC.Enable && !offlineMode {
    return errors.New("'grpc' must be enable in online mode for Rosetta to work")
}

minGasPrices, err := sdk.ParseDecCoins(config.MinGasPrices)
    if err != nil {
    ctx.Logger.Error("failed to parse minimum-gas-prices: ", err)

return err
}
    conf := &rosetta.Config{
    Blockchain:          config.Rosetta.Blockchain,
    Network:             config.Rosetta.Network,
    TendermintRPC:       ctx.Config.RPC.ListenAddress,
    GRPCEndpoint:        config.GRPC.Address,
    Addr:                config.Rosetta.Address,
    Retries:             config.Rosetta.Retries,
    Offline:             offlineMode,
    GasToSuggest:        config.Rosetta.GasToSuggest,
    EnableFeeSuggestion: config.Rosetta.EnableFeeSuggestion,
    GasPrices:           minGasPrices.Sort(),
    Codec:               clientCtx.Codec.(*codec.ProtoCodec),
    InterfaceRegistry:   clientCtx.InterfaceRegistry,
}

rosettaSrv, err = rosetta.ServerFromConfig(conf)
    if err != nil {
    return err
}
    errCh := make(chan error)

go func() {
    if err := rosettaSrv.Start(); err != nil {
    errCh <- err
}
	
}()

select {
    case err := <-errCh:
			return err
    case <-time.After(types.ServerStartTime): // assume server started successfully
}
	
}

defer func() {
    if tmNode != nil && tmNode.IsRunning() {
			_ = tmNode.Stop()
}
    if cpuProfileCleanup != nil {
    cpuProfileCleanup()
}
    if apiSrv != nil {
			_ = apiSrv.Close()
}

ctx.Logger.Info("exiting...")
}()

	// wait for signal capture and gracefully return
	return WaitForQuitSignals()
}

func startTelemetry(cfg serverconfig.Config) (*telemetry.Metrics, error) {
    if !cfg.Telemetry.Enabled {
    return nil, nil
}

return telemetry.New(cfg.Telemetry)
}
```

Note that an `appCreator` is a function that fulfills the `AppCreator` signature:

```go expandable
package types

import (
    
	"encoding/json"
    "io"
    "time"
    "github.com/cosmos/gogoproto/grpc"
    "github.com/spf13/cobra"
	abci "github.com/tendermint/tendermint/abci/types"
    "github.com/tendermint/tendermint/libs/log"
	tmproto "github.com/tendermint/tendermint/proto/tendermint/types"
	tmtypes "github.com/tendermint/tendermint/types"
	dbm "github.com/tendermint/tm-db"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/server/api"
    "github.com/cosmos/cosmos-sdk/server/config"
	sdk "github.com/cosmos/cosmos-sdk/types"
)

// ServerStartTime defines the time duration that the server need to stay running after startup
// for the startup be considered successful
const ServerStartTime = 5 * time.Second

type (
	// AppOptions defines an interface that is passed into an application
	// constructor, typically used to set BaseApp options that are either supplied
	// via config file or through CLI arguments/flags. The underlying implementation
	// is defined by the server package and is typically implemented via a Viper
	// literal defined on the server Context. Note, casting Get calls may not yield
	// the expected types and could result in type assertion errors. It is recommend
	// to either use the cast package or perform manual conversion for safety.
	AppOptions interface {
    Get(string)

interface{
}
	
}

	// Application defines an application interface that wraps abci.Application.
	// The interface defines the necessary contracts to be implemented in order
	// to fully bootstrap and start an application.
	Application interface {
    abci.Application

		RegisterAPIRoutes(*api.Server, config.APIConfig)

		// RegisterGRPCServer registers gRPC services directly with the gRPC
		// server.
		RegisterGRPCServer(grpc.Server)

		// RegisterTxService registers the gRPC Query service for tx (such as tx
		// simulation, fetching txs by hash...).
		RegisterTxService(client.Context)

		// RegisterTendermintService registers the gRPC Query service for tendermint queries.
		RegisterTendermintService(client.Context)

		// RegisterNodeService registers the node gRPC Query service.
		RegisterNodeService(client.Context)

		// CommitMultiStore return the multistore instance
		CommitMultiStore()

sdk.CommitMultiStore
}

	// AppCreator is a function that allows us to lazily initialize an
	// application using various configurations.
	AppCreator func(log.Logger, dbm.DB, io.Writer, AppOptions)

Application

	// ModuleInitFlags takes a start command and adds modules specific init flags.
	ModuleInitFlags func(startCmd *cobra.Command)

	// ExportedApp represents an exported app state, along with
	// validators, consensus params and latest app height.
	ExportedApp struct {
		// AppState is the application state as JSON.
		AppState json.RawMessage
		// Validators is the exported validator set.
		Validators []tmtypes.GenesisValidator
		// Height is the app's latest block height.
		Height int64
		// ConsensusParams are the exported consensus params for ABCI.
		ConsensusParams *tmproto.ConsensusParams
}

	// AppExporter is a function that dumps all app state to
	// JSON-serializable structure and returns the current validator set.
	AppExporter func(log.Logger, dbm.DB, io.Writer, int64, bool, []string, AppOptions, []string) (ExportedApp, error)
)
```

In practice, the [constructor of the application](/docs/sdk/v0.47/beginner/overview-app#constructor-function) is passed as the `appCreator`.

```go expandable
package cmd

import (
    
	"errors"
    "io"
    "os"

	rosettaCmd "cosmossdk.io/tools/rosetta/cmd"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
	tmcfg "github.com/tendermint/tendermint/config"
    "github.com/tendermint/tendermint/libs/log"
	dbm "github.com/tendermint/tm-db"
    "cosmossdk.io/simapp"
    "cosmossdk.io/simapp/params"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/config"
    "github.com/cosmos/cosmos-sdk/client/debug"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/client/keys"
    "github.com/cosmos/cosmos-sdk/client/pruning"
    "github.com/cosmos/cosmos-sdk/client/rpc"
    "github.com/cosmos/cosmos-sdk/server"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servertypes "github.com/cosmos/cosmos-sdk/server/types"
	simtestutil "github.com/cosmos/cosmos-sdk/testutil/sims"
	sdk "github.com/cosmos/cosmos-sdk/types"
	authcmd "github.com/cosmos/cosmos-sdk/x/auth/client/cli"
    "github.com/cosmos/cosmos-sdk/x/auth/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
    "github.com/cosmos/cosmos-sdk/x/crisis"
	genutilcli "github.com/cosmos/cosmos-sdk/x/genutil/client/cli"
)

// NewRootCmd creates a new root command for simd. It is called once in the
// main function.
func NewRootCmd() *cobra.Command {
	// we "pre"-instantiate the application for getting the injected/configured encoding configuration
    tempApp := simapp.NewSimApp(log.NewNopLogger(), dbm.NewMemDB(), nil, true, simtestutil.NewAppOptionsWithFlagHome(simapp.DefaultNodeHome))
    encodingConfig := params.EncodingConfig{
    InterfaceRegistry: tempApp.InterfaceRegistry(),
    Codec:             tempApp.AppCodec(),
    TxConfig:          tempApp.TxConfig(),
    Amino:             tempApp.LegacyAmino(),
}
    initClientCtx := client.Context{
}.
		WithCodec(encodingConfig.Codec).
		WithInterfaceRegistry(encodingConfig.InterfaceRegistry).
		WithTxConfig(encodingConfig.TxConfig).
		WithLegacyAmino(encodingConfig.Amino).
		WithInput(os.Stdin).
		WithAccountRetriever(types.AccountRetriever{
}).
		WithHomeDir(simapp.DefaultNodeHome).
		WithViper("") // In simapp, we don't use any prefix for env variables.
    rootCmd := &cobra.Command{
    Use:   "simd",
    Short: "simulation app",
    PersistentPreRunE: func(cmd *cobra.Command, _ []string)

error {
			// set the default command outputs
			cmd.SetOut(cmd.OutOrStdout())

cmd.SetErr(cmd.ErrOrStderr())

initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())
    if err != nil {
    return err
}

initClientCtx, err = config.ReadFromClientConfig(initClientCtx)
    if err != nil {
    return err
}
    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {
    return err
}

customAppTemplate, customAppConfig := initAppConfig()
    customTMConfig := initTendermintConfig()

return server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customTMConfig)
},
}

initRootCmd(rootCmd, encodingConfig)

return rootCmd
}

// initTendermintConfig helps to override default Tendermint Config values.
// return tmcfg.DefaultConfig if no custom configuration is required for the application.
func initTendermintConfig() *tmcfg.Config {
    cfg := tmcfg.DefaultConfig()

	// these values put a higher strain on node memory
	// cfg.P2P.MaxNumInboundPeers = 100
	// cfg.P2P.MaxNumOutboundPeers = 40

	return cfg
}

// initAppConfig helps to override default appConfig template and configs.
// return "", nil if no custom configuration is required for the application.
func initAppConfig() (string, interface{
}) {
	// The following code snippet is just for reference.

	// WASMConfig defines configuration for the wasm module.
	type WASMConfig struct {
		// This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
		QueryGasLimit uint64 `mapstructure:"query_gas_limit"`

		// Address defines the gRPC-web server to listen on
		LruSize uint64 `mapstructure:"lru_size"`
}

type CustomAppConfig struct {
    serverconfig.Config

		WASM WASMConfig `mapstructure:"wasm"`
}

	// Optionally allow the chain developer to overwrite the SDK's default
	// server config.
    srvCfg := serverconfig.DefaultConfig()
	// The SDK's default minimum gas price is set to "" (empty value)

inside
	// app.toml. If left empty by validators, the node will halt on startup.
	// However, the chain developer can set a default app.toml value for their
	// validators here.
	//
	// In summary:
	// - if you leave srvCfg.MinGasPrices = "", all validators MUST tweak their
	//   own app.toml config,
	// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their
	//   own app.toml to override, or use this default value.
	//
	// In simapp, we set the min gas prices to 0.
	srvCfg.MinGasPrices = "0stake"
	// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default
    customAppConfig := CustomAppConfig{
    Config: *srvCfg,
    WASM: WASMConfig{
    LruSize:       1,
    QueryGasLimit: 300000,
},
}
    customAppTemplate := serverconfig.DefaultConfigTemplate + `
[wasm]
# This is the maximum sdk gas (wasm and storage)

that we allow for any x/wasm "smart" queries
query_gas_limit = 300000
# This is the number of wasm vm instances we keep cached in memory for speed-up
# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally
lru_size = 0`

	return customAppTemplate, customAppConfig
}

func initRootCmd(rootCmd *cobra.Command, encodingConfig params.EncodingConfig) {
    cfg := sdk.GetConfig()

cfg.Seal()

rootCmd.AddCommand(
		genutilcli.InitCmd(simapp.ModuleBasics, simapp.DefaultNodeHome),
		NewTestnetCmd(simapp.ModuleBasics, banktypes.GenesisBalancesIterator{
}),
		debug.Cmd(),
		config.Cmd(),
		pruning.PruningCmd(newApp),
	)

server.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)

	// add keybase, auxiliary RPC, query, genesis, and tx child commands
	rootCmd.AddCommand(
		rpc.StatusCommand(),
		genesisCommand(encodingConfig),
		queryCommand(),
		txCommand(),
		keys.Commands(simapp.DefaultNodeHome),
	)

	// add rosetta
	rootCmd.AddCommand(rosettaCmd.RosettaCommand(encodingConfig.InterfaceRegistry, encodingConfig.Codec))
}

func addModuleInitFlags(startCmd *cobra.Command) {
    crisis.AddModuleInitFlags(startCmd)
}

// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter
func genesisCommand(encodingConfig params.EncodingConfig, cmds ...*cobra.Command) *cobra.Command {
    cmd := genutilcli.GenesisCoreCommand(encodingConfig.TxConfig, simapp.ModuleBasics, simapp.DefaultNodeHome)
    for _, sub_cmd := range cmds {
    cmd.AddCommand(sub_cmd)
}

return cmd
}

func queryCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "query",
    Aliases:                    []string{"q"
},
    Short:                      "Querying subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetAccountCmd(),
		rpc.ValidatorCommand(),
		rpc.BlockCommand(),
		authcmd.QueryTxsByEventsCmd(),
		authcmd.QueryTxCmd(),
	)

simapp.ModuleBasics.AddQueryCommands(cmd)

return cmd
}

func txCommand() *cobra.Command {
    cmd := &cobra.Command{
    Use:                        "tx",
    Short:                      "Transactions subcommands",
    DisableFlagParsing:         false,
    SuggestionsMinimumDistance: 2,
    RunE:                       client.ValidateCmd,
}

cmd.AddCommand(
		authcmd.GetSignCommand(),
		authcmd.GetSignBatchCommand(),
		authcmd.GetMultiSignCommand(),
		authcmd.GetMultiSignBatchCmd(),
		authcmd.GetValidateSignaturesCommand(),
		authcmd.GetBroadcastCommand(),
		authcmd.GetEncodeCommand(),
		authcmd.GetDecodeCommand(),
		authcmd.GetAuxToFeeCommand(),
	)

simapp.ModuleBasics.AddTxCommands(cmd)

return cmd
}

// newApp creates the application
func newApp(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	appOpts servertypes.AppOptions,
)

servertypes.Application {
    baseappOptions := server.DefaultBaseappOptions(appOpts)

return simapp.NewSimApp(
		logger, db, traceStore, true,
		appOpts,
		baseappOptions...,
	)
}

// appExport creates a new simapp (optionally at a given height)

and exports state.
func appExport(
	logger log.Logger,
	db dbm.DB,
	traceStore io.Writer,
	height int64,
    forZeroHeight bool,
	jailAllowedAddrs []string,
	appOpts servertypes.AppOptions,
	modulesToExport []string,
) (servertypes.ExportedApp, error) {
    var simApp *simapp.SimApp

	// this check is necessary as we use the flag in x/upgrade.
	// we can exit more gracefully by checking the flag here.
	homePath, ok := appOpts.Get(flags.FlagHome).(string)
    if !ok || homePath == "" {
    return servertypes.ExportedApp{
}, errors.New("application home not set")
}

viperAppOpts, ok := appOpts.(*viper.Viper)
    if !ok {
    return servertypes.ExportedApp{
}, errors.New("appOpts is not viper.Viper")
}

	// overwrite the FlagInvCheckPeriod
	viperAppOpts.Set(server.FlagInvCheckPeriod, 1)

appOpts = viperAppOpts
    if height != -1 {
    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)
    if err := simApp.LoadHeight(height); err != nil {
    return servertypes.ExportedApp{
}, err
}
	
}

else {
    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)
}

return simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)
}
```

Then, the instance of `app` is used to instantiate a new CometBFT node:

```go expandable
package server

// DONTCOVER

import (
    
	"errors"
    "fmt"
    "net"
    "net/http"
    "os"
    "runtime/pprof"
    "time"
    "github.com/spf13/cobra"
    "github.com/tendermint/tendermint/abci/server"
	tcmd "github.com/tendermint/tendermint/cmd/tendermint/commands"
    "github.com/tendermint/tendermint/node"
    "github.com/tendermint/tendermint/p2p"
	pvm "github.com/tendermint/tendermint/privval"
    "github.com/tendermint/tendermint/proxy"
    "github.com/tendermint/tendermint/rpc/client/local"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "cosmossdk.io/tools/rosetta"
	crgserver "cosmossdk.io/tools/rosetta/lib/server"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/codec"
    "github.com/cosmos/cosmos-sdk/server/api"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servergrpc "github.com/cosmos/cosmos-sdk/server/grpc"
    "github.com/cosmos/cosmos-sdk/server/types"
	pruningtypes "github.com/cosmos/cosmos-sdk/store/pruning/types"
    "github.com/cosmos/cosmos-sdk/telemetry"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/mempool"
)

const (
	// Tendermint full-node start flags
	flagWithTendermint     = "with-tendermint"
	flagAddress            = "address"
	flagTransport          = "transport"
	flagTraceStore         = "trace-store"
	flagCPUProfile         = "cpu-profile"
	FlagMinGasPrices       = "minimum-gas-prices"
	FlagHaltHeight         = "halt-height"
	FlagHaltTime           = "halt-time"
	FlagInterBlockCache    = "inter-block-cache"
	FlagUnsafeSkipUpgrades = "unsafe-skip-upgrades"
	FlagTrace              = "trace"
	FlagInvCheckPeriod     = "inv-check-period"

	FlagPruning             = "pruning"
	FlagPruningKeepRecent   = "pruning-keep-recent"
	FlagPruningInterval     = "pruning-interval"
	FlagIndexEvents         = "index-events"
	FlagMinRetainBlocks     = "min-retain-blocks"
	FlagIAVLCacheSize       = "iavl-cache-size"
	FlagDisableIAVLFastNode = "iavl-disable-fastnode"

	// state sync-related flags
	FlagStateSyncSnapshotInterval   = "state-sync.snapshot-interval"
	FlagStateSyncSnapshotKeepRecent = "state-sync.snapshot-keep-recent"

	// api-related flags
	FlagAPIEnable             = "api.enable"
	FlagAPISwagger            = "api.swagger"
	FlagAPIAddress            = "api.address"
	FlagAPIMaxOpenConnections = "api.max-open-connections"
	FlagRPCReadTimeout        = "api.rpc-read-timeout"
	FlagRPCWriteTimeout       = "api.rpc-write-timeout"
	FlagRPCMaxBodyBytes       = "api.rpc-max-body-bytes"
	FlagAPIEnableUnsafeCORS   = "api.enabled-unsafe-cors"

	// gRPC-related flags
	flagGRPCOnly       = "grpc-only"
	flagGRPCEnable     = "grpc.enable"
	flagGRPCAddress    = "grpc.address"
	flagGRPCWebEnable  = "grpc-web.enable"
	flagGRPCWebAddress = "grpc-web.address"

	// mempool flags
	FlagMempoolMaxTxs = "mempool.max-txs"
)

// StartCmd runs the service passed in, either stand-alone or in-process with
// Tendermint.
func StartCmd(appCreator types.AppCreator, defaultNodeHome string) *cobra.Command {
    cmd := &cobra.Command{
    Use:   "start",
    Short: "Run the full node",
    Long: `Run the full node application with Tendermint in or out of process. By
default, the application will run with Tendermint in process.

Pruning options can be provided via the '--pruning' flag or alternatively with '--pruning-keep-recent', and
'pruning-interval' together.

For '--pruning' the options are as follows:

default: the last 362880 states are kept, pruning at 10 block intervals
nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)

everything: 2 latest states will be kept; pruning at 10 block intervals.
custom: allow pruning options to be manually specified through 'pruning-keep-recent', and 'pruning-interval'

Node halting configurations exist in the form of two flags: '--halt-height' and '--halt-time'. During
the ABCI Commit phase, the node will check if the current block height is greater than or equal to
the halt-height or if the current block time is greater than or equal to the halt-time. If so, the
node will attempt to gracefully shutdown and the block will not be committed. In addition, the node
will not be able to commit subsequent blocks.

For profiling and benchmarking purposes, CPU profiling can be enabled via the '--cpu-profile' flag
which accepts a path for the resulting pprof file.

The node may be started in a 'query only' mode where only the gRPC and JSON HTTP
API services are enabled via the 'grpc-only' flag. In this mode, Tendermint is
bypassed and can be used when legacy queries are needed after an on-chain upgrade
is performed. Note, when enabled, gRPC will also be automatically enabled.
`,
    PreRunE: func(cmd *cobra.Command, _ []string)

error {
    serverCtx := GetServerContextFromCmd(cmd)

			// Bind flags to the Context's Viper so the app construction can set
			// options accordingly.
    if err := serverCtx.Viper.BindPFlags(cmd.Flags()); err != nil {
    return err
}

			_, err := GetPruningOptionsFromFlags(serverCtx.Viper)

return err
},
    RunE: func(cmd *cobra.Command, _ []string)

error {
    serverCtx := GetServerContextFromCmd(cmd)

clientCtx, err := client.GetClientQueryContext(cmd)
    if err != nil {
    return err
}

withTM, _ := cmd.Flags().GetBool(flagWithTendermint)
    if !withTM {
    serverCtx.Logger.Info("starting ABCI without Tendermint")

return startStandAlone(serverCtx, appCreator)
}

			// amino is needed here for backwards compatibility of REST routes
			err = startInProcess(serverCtx, clientCtx, appCreator)

errCode, ok := err.(ErrorCode)
    if !ok {
    return err
}

serverCtx.Logger.Debug(fmt.Sprintf("received quit signal: %d", errCode.Code))

return nil
},
}

cmd.Flags().String(flags.FlagHome, defaultNodeHome, "The application home directory")

cmd.Flags().Bool(flagWithTendermint, true, "Run abci app embedded in-process with tendermint")

cmd.Flags().String(flagAddress, "tcp://0.0.0.0:26658", "Listen address")

cmd.Flags().String(flagTransport, "socket", "Transport protocol: socket, grpc")

cmd.Flags().String(flagTraceStore, "", "Enable KVStore tracing to an output file")

cmd.Flags().String(FlagMinGasPrices, "", "Minimum gas prices to accept for transactions; Any fee in a tx must meet this minimum (e.g. 0.01photino;0.0001stake)")

cmd.Flags().IntSlice(FlagUnsafeSkipUpgrades, []int{
}, "Skip a set of upgrade heights to continue the old binary")

cmd.Flags().Uint64(FlagHaltHeight, 0, "Block height at which to gracefully halt the chain and shutdown the node")

cmd.Flags().Uint64(FlagHaltTime, 0, "Minimum block time (in Unix seconds)

at which to gracefully halt the chain and shutdown the node")

cmd.Flags().Bool(FlagInterBlockCache, true, "Enable inter-block caching")

cmd.Flags().String(flagCPUProfile, "", "Enable CPU profiling and write to the provided file")

cmd.Flags().Bool(FlagTrace, false, "Provide full stack traces for errors in ABCI Log")

cmd.Flags().String(FlagPruning, pruningtypes.PruningOptionDefault, "Pruning strategy (default|nothing|everything|custom)")

cmd.Flags().Uint64(FlagPruningKeepRecent, 0, "Number of recent heights to keep on disk (ignored if pruning is not 'custom')")

cmd.Flags().Uint64(FlagPruningInterval, 0, "Height interval at which pruned heights are removed from disk (ignored if pruning is not 'custom')")

cmd.Flags().Uint(FlagInvCheckPeriod, 0, "Assert registered invariants every N blocks")

cmd.Flags().Uint64(FlagMinRetainBlocks, 0, "Minimum block height offset during ABCI commit to prune Tendermint blocks")

cmd.Flags().Bool(FlagAPIEnable, false, "Define if the API server should be enabled")

cmd.Flags().Bool(FlagAPISwagger, false, "Define if swagger documentation should automatically be registered (Note: the API must also be enabled)")

cmd.Flags().String(FlagAPIAddress, serverconfig.DefaultAPIAddress, "the API server address to listen on")

cmd.Flags().Uint(FlagAPIMaxOpenConnections, 1000, "Define the number of maximum open connections")

cmd.Flags().Uint(FlagRPCReadTimeout, 10, "Define the Tendermint RPC read timeout (in seconds)")

cmd.Flags().Uint(FlagRPCWriteTimeout, 0, "Define the Tendermint RPC write timeout (in seconds)")

cmd.Flags().Uint(FlagRPCMaxBodyBytes, 1000000, "Define the Tendermint maximum response body (in bytes)")

cmd.Flags().Bool(FlagAPIEnableUnsafeCORS, false, "Define if CORS should be enabled (unsafe - use it at your own risk)")

cmd.Flags().Bool(flagGRPCOnly, false, "Start the node in gRPC query only mode (no Tendermint process is started)")

cmd.Flags().Bool(flagGRPCEnable, true, "Define if the gRPC server should be enabled")

cmd.Flags().String(flagGRPCAddress, serverconfig.DefaultGRPCAddress, "the gRPC server address to listen on")

cmd.Flags().Bool(flagGRPCWebEnable, true, "Define if the gRPC-Web server should be enabled. (Note: gRPC must also be enabled)")

cmd.Flags().String(flagGRPCWebAddress, serverconfig.DefaultGRPCWebAddress, "The gRPC-Web server address to listen on")

cmd.Flags().Uint64(FlagStateSyncSnapshotInterval, 0, "State sync snapshot interval")

cmd.Flags().Uint32(FlagStateSyncSnapshotKeepRecent, 2, "State sync snapshot to keep")

cmd.Flags().Bool(FlagDisableIAVLFastNode, false, "Disable fast node for IAVL tree")

cmd.Flags().Int(FlagMempoolMaxTxs, mempool.DefaultMaxTx, "Sets MaxTx value for the app-side mempool")

	// add support for all Tendermint-specific command line options
	tcmd.AddNodeFlags(cmd)

return cmd
}

func startStandAlone(ctx *Context, appCreator types.AppCreator)

error {
    addr := ctx.Viper.GetString(flagAddress)
    transport := ctx.Viper.GetString(flagTransport)
    home := ctx.Viper.GetString(flags.FlagHome)

db, err := openDB(home, GetAppDBBackend(ctx.Viper))
    if err != nil {
    return err
}
    traceWriterFile := ctx.Viper.GetString(flagTraceStore)

traceWriter, err := openTraceWriter(traceWriterFile)
    if err != nil {
    return err
}
    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)

config, err := serverconfig.GetConfig(ctx.Viper)
    if err != nil {
    return err
}

	_, err = startTelemetry(config)
    if err != nil {
    return err
}

svr, err := server.NewServer(addr, transport, app)
    if err != nil {
    return fmt.Errorf("error creating listener: %v", err)
}

svr.SetLogger(ctx.Logger.With("module", "abci-server"))

err = svr.Start()
    if err != nil {
    fmt.Println(err.Error())

os.Exit(1)
}

defer func() {
    if err = svr.Stop(); err != nil {
    fmt.Println(err.Error())

os.Exit(1)
}
	
}()

	// Wait for SIGINT or SIGTERM signal
	return WaitForQuitSignals()
}

func startInProcess(ctx *Context, clientCtx client.Context, appCreator types.AppCreator)

error {
    cfg := ctx.Config
    home := cfg.RootDir
	var cpuProfileCleanup func()
    if cpuProfile := ctx.Viper.GetString(flagCPUProfile); cpuProfile != "" {
    f, err := os.Create(cpuProfile)
    if err != nil {
    return err
}

ctx.Logger.Info("starting CPU profiler", "profile", cpuProfile)
    if err := pprof.StartCPUProfile(f); err != nil {
    return err
}

cpuProfileCleanup = func() {
    ctx.Logger.Info("stopping CPU profiler", "profile", cpuProfile)

pprof.StopCPUProfile()
    if err := f.Close(); err != nil {
    ctx.Logger.Info("failed to close cpu-profile file", "profile", cpuProfile, "err", err.Error())
}
	
}
	
}

db, err := openDB(home, GetAppDBBackend(ctx.Viper))
    if err != nil {
    return err
}
    traceWriterFile := ctx.Viper.GetString(flagTraceStore)

traceWriter, err := openTraceWriter(traceWriterFile)
    if err != nil {
    return err
}

	// Clean up the traceWriter in the cpuProfileCleanup routine that is invoked
	// when the server is shutting down.
    fn := cpuProfileCleanup
	cpuProfileCleanup = func() {
    if fn != nil {
    fn()
}

		// if flagTraceStore is not used then traceWriter is nil
    if traceWriter != nil {
    if err = traceWriter.Close(); err != nil {
    ctx.Logger.Error("failed to close trace writer", "err", err)
}
	
}
	
}

config, err := serverconfig.GetConfig(ctx.Viper)
    if err != nil {
    return err
}
    if err := config.ValidateBasic(); err != nil {
    return err
}
    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)

nodeKey, err := p2p.LoadOrGenNodeKey(cfg.NodeKeyFile())
    if err != nil {
    return err
}
    genDocProvider := node.DefaultGenesisDocProviderFunc(cfg)

var (
		tmNode   *node.Node
		gRPCOnly = ctx.Viper.GetBool(flagGRPCOnly)
	)
    if gRPCOnly {
    ctx.Logger.Info("starting node in gRPC only mode; Tendermint is disabled")

config.GRPC.Enable = true
}

else {
    ctx.Logger.Info("starting node with ABCI Tendermint in-process")

tmNode, err = node.NewNode(
			cfg,
			pvm.LoadOrGenFilePV(cfg.PrivValidatorKeyFile(), cfg.PrivValidatorStateFile()),
			nodeKey,
			proxy.NewLocalClientCreator(app),
			genDocProvider,
			node.DefaultDBProvider,
			node.DefaultMetricsProvider(cfg.Instrumentation),
			ctx.Logger,
		)
    if err != nil {
    return err
}
    if err := tmNode.Start(); err != nil {
    return err
}
	
}

	// Add the tx service to the gRPC router. We only need to register this
	// service if API or gRPC is enabled, and avoid doing so in the general
	// case, because it spawns a new local tendermint RPC client.
    if (config.API.Enable || config.GRPC.Enable) && tmNode != nil {
		// re-assign for making the client available below
		// do not use := to avoid shadowing clientCtx
		clientCtx = clientCtx.WithClient(local.New(tmNode))

app.RegisterTxService(clientCtx)

app.RegisterTendermintService(clientCtx)

app.RegisterNodeService(clientCtx)
}

metrics, err := startTelemetry(config)
    if err != nil {
    return err
}

var apiSrv *api.Server
    if config.API.Enable {
    genDoc, err := genDocProvider()
    if err != nil {
    return err
}
    clientCtx := clientCtx.WithHomeDir(home).WithChainID(genDoc.ChainID)
    if config.GRPC.Enable {
			_, port, err := net.SplitHostPort(config.GRPC.Address)
    if err != nil {
    return err
}
    maxSendMsgSize := config.GRPC.MaxSendMsgSize
    if maxSendMsgSize == 0 {
    maxSendMsgSize = serverconfig.DefaultGRPCMaxSendMsgSize
}
    maxRecvMsgSize := config.GRPC.MaxRecvMsgSize
    if maxRecvMsgSize == 0 {
    maxRecvMsgSize = serverconfig.DefaultGRPCMaxRecvMsgSize
}
    grpcAddress := fmt.Sprintf("127.0.0.1:%s", port)

			// If grpc is enabled, configure grpc client for grpc gateway.
			grpcClient, err := grpc.Dial(
				grpcAddress,
				grpc.WithTransportCredentials(insecure.NewCredentials()),
				grpc.WithDefaultCallOptions(
					grpc.ForceCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),
					grpc.MaxCallRecvMsgSize(maxRecvMsgSize),
					grpc.MaxCallSendMsgSize(maxSendMsgSize),
				),
			)
    if err != nil {
    return err
}

clientCtx = clientCtx.WithGRPCClient(grpcClient)

ctx.Logger.Debug("grpc client assigned to client context", "target", grpcAddress)
}

apiSrv = api.New(clientCtx, ctx.Logger.With("module", "api-server"))

app.RegisterAPIRoutes(apiSrv, config.API)
    if config.Telemetry.Enabled {
    apiSrv.SetTelemetry(metrics)
}
    errCh := make(chan error)

go func() {
    if err := apiSrv.Start(config); err != nil {
    errCh <- err
}
	
}()

select {
    case err := <-errCh:
			return err
    case <-time.After(types.ServerStartTime): // assume server started successfully
}
	
}

var (
		grpcSrv    *grpc.Server
		grpcWebSrv *http.Server
	)
    if config.GRPC.Enable {
    grpcSrv, err = servergrpc.StartGRPCServer(clientCtx, app, config.GRPC)
    if err != nil {
    return err
}

defer grpcSrv.Stop()
    if config.GRPCWeb.Enable {
    grpcWebSrv, err = servergrpc.StartGRPCWeb(grpcSrv, config)
    if err != nil {
    ctx.Logger.Error("failed to start grpc-web http server: ", err)

return err
}

defer func() {
    if err := grpcWebSrv.Close(); err != nil {
    ctx.Logger.Error("failed to close grpc-web http server: ", err)
}
	
}()
}
	
}

	// At this point it is safe to block the process if we're in gRPC only mode as
	// we do not need to start Rosetta or handle any Tendermint related processes.
    if gRPCOnly {
		// wait for signal capture and gracefully return
		return WaitForQuitSignals()
}

var rosettaSrv crgserver.Server
    if config.Rosetta.Enable {
    offlineMode := config.Rosetta.Offline

		// If GRPC is not enabled rosetta cannot work in online mode, so we throw an error.
    if !config.GRPC.Enable && !offlineMode {
    return errors.New("'grpc' must be enable in online mode for Rosetta to work")
}

minGasPrices, err := sdk.ParseDecCoins(config.MinGasPrices)
    if err != nil {
    ctx.Logger.Error("failed to parse minimum-gas-prices: ", err)

return err
}
    conf := &rosetta.Config{
    Blockchain:          config.Rosetta.Blockchain,
    Network:             config.Rosetta.Network,
    TendermintRPC:       ctx.Config.RPC.ListenAddress,
    GRPCEndpoint:        config.GRPC.Address,
    Addr:                config.Rosetta.Address,
    Retries:             config.Rosetta.Retries,
    Offline:             offlineMode,
    GasToSuggest:        config.Rosetta.GasToSuggest,
    EnableFeeSuggestion: config.Rosetta.EnableFeeSuggestion,
    GasPrices:           minGasPrices.Sort(),
    Codec:               clientCtx.Codec.(*codec.ProtoCodec),
    InterfaceRegistry:   clientCtx.InterfaceRegistry,
}

rosettaSrv, err = rosetta.ServerFromConfig(conf)
    if err != nil {
    return err
}
    errCh := make(chan error)

go func() {
    if err := rosettaSrv.Start(); err != nil {
    errCh <- err
}
	
}()

select {
    case err := <-errCh:
			return err
    case <-time.After(types.ServerStartTime): // assume server started successfully
}
	
}

defer func() {
    if tmNode != nil && tmNode.IsRunning() {
			_ = tmNode.Stop()
}
    if cpuProfileCleanup != nil {
    cpuProfileCleanup()
}
    if apiSrv != nil {
			_ = apiSrv.Close()
}

ctx.Logger.Info("exiting...")
}()

	// wait for signal capture and gracefully return
	return WaitForQuitSignals()
}

func startTelemetry(cfg serverconfig.Config) (*telemetry.Metrics, error) {
    if !cfg.Telemetry.Enabled {
    return nil, nil
}

return telemetry.New(cfg.Telemetry)
}
```

The CometBFT node can be created with `app` because the latter satisfies the [`abci.Application` interface](https://github.com/cometbft/cometbft/blob/v0.37.0/abci/types/application.go#L9-L35) (given that `app` extends [`baseapp`](baseapp)). As part of the `node.New` method, CometBFT makes sure that the height of the application (i.e. number of blocks since genesis) is equal to the height of the CometBFT node. The difference between these two heights should always be negative or null. If it is strictly negative, `node.New` will replay blocks until the height of the application reaches the height of the CometBFT node. Finally, if the height of the application is `0`, the CometBFT node will call [`InitChain`](baseapp#initchain) on the application to initialize the state from the genesis file.

Once the CometBFT node is instantiated and in sync with the application, the node can be started:

```go expandable
package server

// DONTCOVER

import (
    
	"errors"
    "fmt"
    "net"
    "net/http"
    "os"
    "runtime/pprof"
    "time"
    "github.com/spf13/cobra"
    "github.com/tendermint/tendermint/abci/server"
	tcmd "github.com/tendermint/tendermint/cmd/tendermint/commands"
    "github.com/tendermint/tendermint/node"
    "github.com/tendermint/tendermint/p2p"
	pvm "github.com/tendermint/tendermint/privval"
    "github.com/tendermint/tendermint/proxy"
    "github.com/tendermint/tendermint/rpc/client/local"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "cosmossdk.io/tools/rosetta"
	crgserver "cosmossdk.io/tools/rosetta/lib/server"
    "github.com/cosmos/cosmos-sdk/client"
    "github.com/cosmos/cosmos-sdk/client/flags"
    "github.com/cosmos/cosmos-sdk/codec"
    "github.com/cosmos/cosmos-sdk/server/api"
	serverconfig "github.com/cosmos/cosmos-sdk/server/config"
	servergrpc "github.com/cosmos/cosmos-sdk/server/grpc"
    "github.com/cosmos/cosmos-sdk/server/types"
	pruningtypes "github.com/cosmos/cosmos-sdk/store/pruning/types"
    "github.com/cosmos/cosmos-sdk/telemetry"
	sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/cosmos/cosmos-sdk/types/mempool"
)

const (
	// Tendermint full-node start flags
	flagWithTendermint     = "with-tendermint"
	flagAddress            = "address"
	flagTransport          = "transport"
	flagTraceStore         = "trace-store"
	flagCPUProfile         = "cpu-profile"
	FlagMinGasPrices       = "minimum-gas-prices"
	FlagHaltHeight         = "halt-height"
	FlagHaltTime           = "halt-time"
	FlagInterBlockCache    = "inter-block-cache"
	FlagUnsafeSkipUpgrades = "unsafe-skip-upgrades"
	FlagTrace              = "trace"
	FlagInvCheckPeriod     = "inv-check-period"

	FlagPruning             = "pruning"
	FlagPruningKeepRecent   = "pruning-keep-recent"
	FlagPruningInterval     = "pruning-interval"
	FlagIndexEvents         = "index-events"
	FlagMinRetainBlocks     = "min-retain-blocks"
	FlagIAVLCacheSize       = "iavl-cache-size"
	FlagDisableIAVLFastNode = "iavl-disable-fastnode"

	// state sync-related flags
	FlagStateSyncSnapshotInterval   = "state-sync.snapshot-interval"
	FlagStateSyncSnapshotKeepRecent = "state-sync.snapshot-keep-recent"

	// api-related flags
	FlagAPIEnable             = "api.enable"
	FlagAPISwagger            = "api.swagger"
	FlagAPIAddress            = "api.address"
	FlagAPIMaxOpenConnections = "api.max-open-connections"
	FlagRPCReadTimeout        = "api.rpc-read-timeout"
	FlagRPCWriteTimeout       = "api.rpc-write-timeout"
	FlagRPCMaxBodyBytes       = "api.rpc-max-body-bytes"
	FlagAPIEnableUnsafeCORS   = "api.enabled-unsafe-cors"

	// gRPC-related flags
	flagGRPCOnly       = "grpc-only"
	flagGRPCEnable     = "grpc.enable"
	flagGRPCAddress    = "grpc.address"
	flagGRPCWebEnable  = "grpc-web.enable"
	flagGRPCWebAddress = "grpc-web.address"

	// mempool flags
	FlagMempoolMaxTxs = "mempool.max-txs"
)

// StartCmd runs the service passed in, either stand-alone or in-process with
// Tendermint.
func StartCmd(appCreator types.AppCreator, defaultNodeHome string) *cobra.Command {
    cmd := &cobra.Command{
    Use:   "start",
    Short: "Run the full node",
    Long: `Run the full node application with Tendermint in or out of process. By
default, the application will run with Tendermint in process.

Pruning options can be provided via the '--pruning' flag or alternatively with '--pruning-keep-recent', and
'pruning-interval' together.

For '--pruning' the options are as follows:

default: the last 362880 states are kept, pruning at 10 block intervals
nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)

everything: 2 latest states will be kept; pruning at 10 block intervals.
custom: allow pruning options to be manually specified through 'pruning-keep-recent', and 'pruning-interval'

Node halting configurations exist in the form of two flags: '--halt-height' and '--halt-time'. During
the ABCI Commit phase, the node will check if the current block height is greater than or equal to
the halt-height or if the current block time is greater than or equal to the halt-time. If so, the
node will attempt to gracefully shutdown and the block will not be committed. In addition, the node
will not be able to commit subsequent blocks.

For profiling and benchmarking purposes, CPU profiling can be enabled via the '--cpu-profile' flag
which accepts a path for the resulting pprof file.

The node may be started in a 'query only' mode where only the gRPC and JSON HTTP
API services are enabled via the 'grpc-only' flag. In this mode, Tendermint is
bypassed and can be used when legacy queries are needed after an on-chain upgrade
is performed. Note, when enabled, gRPC will also be automatically enabled.
`,
    PreRunE: func(cmd *cobra.Command, _ []string)

error {
    serverCtx := GetServerContextFromCmd(cmd)

			// Bind flags to the Context's Viper so the app construction can set
			// options accordingly.
    if err := serverCtx.Viper.BindPFlags(cmd.Flags()); err != nil {
    return err
}

			_, err := GetPruningOptionsFromFlags(serverCtx.Viper)

return err
},
    RunE: func(cmd *cobra.Command, _ []string)

error {
    serverCtx := GetServerContextFromCmd(cmd)

clientCtx, err := client.GetClientQueryContext(cmd)
    if err != nil {
    return err
}

withTM, _ := cmd.Flags().GetBool(flagWithTendermint)
    if !withTM {
    serverCtx.Logger.Info("starting ABCI without Tendermint")

return startStandAlone(serverCtx, appCreator)
}

			// amino is needed here for backwards compatibility of REST routes
			err = startInProcess(serverCtx, clientCtx, appCreator)

errCode, ok := err.(ErrorCode)
    if !ok {
    return err
}

serverCtx.Logger.Debug(fmt.Sprintf("received quit signal: %d", errCode.Code))

return nil
},
}

cmd.Flags().String(flags.FlagHome, defaultNodeHome, "The application home directory")

cmd.Flags().Bool(flagWithTendermint, true, "Run abci app embedded in-process with tendermint")

cmd.Flags().String(flagAddress, "tcp://0.0.0.0:26658", "Listen address")

cmd.Flags().String(flagTransport, "socket", "Transport protocol: socket, grpc")

cmd.Flags().String(flagTraceStore, "", "Enable KVStore tracing to an output file")

cmd.Flags().String(FlagMinGasPrices, "", "Minimum gas prices to accept for transactions; Any fee in a tx must meet this minimum (e.g. 0.01photino;0.0001stake)")

cmd.Flags().IntSlice(FlagUnsafeSkipUpgrades, []int{
}, "Skip a set of upgrade heights to continue the old binary")

cmd.Flags().Uint64(FlagHaltHeight, 0, "Block height at which to gracefully halt the chain and shutdown the node")

cmd.Flags().Uint64(FlagHaltTime, 0, "Minimum block time (in Unix seconds)

at which to gracefully halt the chain and shutdown the node")

cmd.Flags().Bool(FlagInterBlockCache, true, "Enable inter-block caching")

cmd.Flags().String(flagCPUProfile, "", "Enable CPU profiling and write to the provided file")

cmd.Flags().Bool(FlagTrace, false, "Provide full stack traces for errors in ABCI Log")

cmd.Flags().String(FlagPruning, pruningtypes.PruningOptionDefault, "Pruning strategy (default|nothing|everything|custom)")

cmd.Flags().Uint64(FlagPruningKeepRecent, 0, "Number of recent heights to keep on disk (ignored if pruning is not 'custom')")

cmd.Flags().Uint64(FlagPruningInterval, 0, "Height interval at which pruned heights are removed from disk (ignored if pruning is not 'custom')")

cmd.Flags().Uint(FlagInvCheckPeriod, 0, "Assert registered invariants every N blocks")

cmd.Flags().Uint64(FlagMinRetainBlocks, 0, "Minimum block height offset during ABCI commit to prune Tendermint blocks")

cmd.Flags().Bool(FlagAPIEnable, false, "Define if the API server should be enabled")

cmd.Flags().Bool(FlagAPISwagger, false, "Define if swagger documentation should automatically be registered (Note: the API must also be enabled)")

cmd.Flags().String(FlagAPIAddress, serverconfig.DefaultAPIAddress, "the API server address to listen on")

cmd.Flags().Uint(FlagAPIMaxOpenConnections, 1000, "Define the number of maximum open connections")

cmd.Flags().Uint(FlagRPCReadTimeout, 10, "Define the Tendermint RPC read timeout (in seconds)")

cmd.Flags().Uint(FlagRPCWriteTimeout, 0, "Define the Tendermint RPC write timeout (in seconds)")

cmd.Flags().Uint(FlagRPCMaxBodyBytes, 1000000, "Define the Tendermint maximum response body (in bytes)")

cmd.Flags().Bool(FlagAPIEnableUnsafeCORS, false, "Define if CORS should be enabled (unsafe - use it at your own risk)")

cmd.Flags().Bool(flagGRPCOnly, false, "Start the node in gRPC query only mode (no Tendermint process is started)")

cmd.Flags().Bool(flagGRPCEnable, true, "Define if the gRPC server should be enabled")

cmd.Flags().String(flagGRPCAddress, serverconfig.DefaultGRPCAddress, "the gRPC server address to listen on")

cmd.Flags().Bool(flagGRPCWebEnable, true, "Define if the gRPC-Web server should be enabled. (Note: gRPC must also be enabled)")

cmd.Flags().String(flagGRPCWebAddress, serverconfig.DefaultGRPCWebAddress, "The gRPC-Web server address to listen on")

cmd.Flags().Uint64(FlagStateSyncSnapshotInterval, 0, "State sync snapshot interval")

cmd.Flags().Uint32(FlagStateSyncSnapshotKeepRecent, 2, "State sync snapshot to keep")

cmd.Flags().Bool(FlagDisableIAVLFastNode, false, "Disable fast node for IAVL tree")

cmd.Flags().Int(FlagMempoolMaxTxs, mempool.DefaultMaxTx, "Sets MaxTx value for the app-side mempool")

	// add support for all Tendermint-specific command line options
	tcmd.AddNodeFlags(cmd)

return cmd
}

func startStandAlone(ctx *Context, appCreator types.AppCreator)

error {
    addr := ctx.Viper.GetString(flagAddress)
    transport := ctx.Viper.GetString(flagTransport)
    home := ctx.Viper.GetString(flags.FlagHome)

db, err := openDB(home, GetAppDBBackend(ctx.Viper))
    if err != nil {
    return err
}
    traceWriterFile := ctx.Viper.GetString(flagTraceStore)

traceWriter, err := openTraceWriter(traceWriterFile)
    if err != nil {
    return err
}
    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)

config, err := serverconfig.GetConfig(ctx.Viper)
    if err != nil {
    return err
}

	_, err = startTelemetry(config)
    if err != nil {
    return err
}

svr, err := server.NewServer(addr, transport, app)
    if err != nil {
    return fmt.Errorf("error creating listener: %v", err)
}

svr.SetLogger(ctx.Logger.With("module", "abci-server"))

err = svr.Start()
    if err != nil {
    fmt.Println(err.Error())

os.Exit(1)
}

defer func() {
    if err = svr.Stop(); err != nil {
    fmt.Println(err.Error())

os.Exit(1)
}
	
}()

	// Wait for SIGINT or SIGTERM signal
	return WaitForQuitSignals()
}

func startInProcess(ctx *Context, clientCtx client.Context, appCreator types.AppCreator)

error {
    cfg := ctx.Config
    home := cfg.RootDir
	var cpuProfileCleanup func()
    if cpuProfile := ctx.Viper.GetString(flagCPUProfile); cpuProfile != "" {
    f, err := os.Create(cpuProfile)
    if err != nil {
    return err
}

ctx.Logger.Info("starting CPU profiler", "profile", cpuProfile)
    if err := pprof.StartCPUProfile(f); err != nil {
    return err
}

cpuProfileCleanup = func() {
    ctx.Logger.Info("stopping CPU profiler", "profile", cpuProfile)

pprof.StopCPUProfile()
    if err := f.Close(); err != nil {
    ctx.Logger.Info("failed to close cpu-profile file", "profile", cpuProfile, "err", err.Error())
}
	
}
	
}

db, err := openDB(home, GetAppDBBackend(ctx.Viper))
    if err != nil {
    return err
}
    traceWriterFile := ctx.Viper.GetString(flagTraceStore)

traceWriter, err := openTraceWriter(traceWriterFile)
    if err != nil {
    return err
}

	// Clean up the traceWriter in the cpuProfileCleanup routine that is invoked
	// when the server is shutting down.
    fn := cpuProfileCleanup
	cpuProfileCleanup = func() {
    if fn != nil {
    fn()
}

		// if flagTraceStore is not used then traceWriter is nil
    if traceWriter != nil {
    if err = traceWriter.Close(); err != nil {
    ctx.Logger.Error("failed to close trace writer", "err", err)
}
	
}
	
}

config, err := serverconfig.GetConfig(ctx.Viper)
    if err != nil {
    return err
}
    if err := config.ValidateBasic(); err != nil {
    return err
}
    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)

nodeKey, err := p2p.LoadOrGenNodeKey(cfg.NodeKeyFile())
    if err != nil {
    return err
}
    genDocProvider := node.DefaultGenesisDocProviderFunc(cfg)

var (
		tmNode   *node.Node
		gRPCOnly = ctx.Viper.GetBool(flagGRPCOnly)
	)
    if gRPCOnly {
    ctx.Logger.Info("starting node in gRPC only mode; Tendermint is disabled")

config.GRPC.Enable = true
}

else {
    ctx.Logger.Info("starting node with ABCI Tendermint in-process")

tmNode, err = node.NewNode(
			cfg,
			pvm.LoadOrGenFilePV(cfg.PrivValidatorKeyFile(), cfg.PrivValidatorStateFile()),
			nodeKey,
			proxy.NewLocalClientCreator(app),
			genDocProvider,
			node.DefaultDBProvider,
			node.DefaultMetricsProvider(cfg.Instrumentation),
			ctx.Logger,
		)
    if err != nil {
    return err
}
    if err := tmNode.Start(); err != nil {
    return err
}
	
}

	// Add the tx service to the gRPC router. We only need to register this
	// service if API or gRPC is enabled, and avoid doing so in the general
	// case, because it spawns a new local tendermint RPC client.
    if (config.API.Enable || config.GRPC.Enable) && tmNode != nil {
		// re-assign for making the client available below
		// do not use := to avoid shadowing clientCtx
		clientCtx = clientCtx.WithClient(local.New(tmNode))

app.RegisterTxService(clientCtx)

app.RegisterTendermintService(clientCtx)

app.RegisterNodeService(clientCtx)
}

metrics, err := startTelemetry(config)
    if err != nil {
    return err
}

var apiSrv *api.Server
    if config.API.Enable {
    genDoc, err := genDocProvider()
    if err != nil {
    return err
}
    clientCtx := clientCtx.WithHomeDir(home).WithChainID(genDoc.ChainID)
    if config.GRPC.Enable {
			_, port, err := net.SplitHostPort(config.GRPC.Address)
    if err != nil {
    return err
}
    maxSendMsgSize := config.GRPC.MaxSendMsgSize
    if maxSendMsgSize == 0 {
    maxSendMsgSize = serverconfig.DefaultGRPCMaxSendMsgSize
}
    maxRecvMsgSize := config.GRPC.MaxRecvMsgSize
    if maxRecvMsgSize == 0 {
    maxRecvMsgSize = serverconfig.DefaultGRPCMaxRecvMsgSize
}
    grpcAddress := fmt.Sprintf("127.0.0.1:%s", port)

			// If grpc is enabled, configure grpc client for grpc gateway.
			grpcClient, err := grpc.Dial(
				grpcAddress,
				grpc.WithTransportCredentials(insecure.NewCredentials()),
				grpc.WithDefaultCallOptions(
					grpc.ForceCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),
					grpc.MaxCallRecvMsgSize(maxRecvMsgSize),
					grpc.MaxCallSendMsgSize(maxSendMsgSize),
				),
			)
    if err != nil {
    return err
}

clientCtx = clientCtx.WithGRPCClient(grpcClient)

ctx.Logger.Debug("grpc client assigned to client context", "target", grpcAddress)
}

apiSrv = api.New(clientCtx, ctx.Logger.With("module", "api-server"))

app.RegisterAPIRoutes(apiSrv, config.API)
    if config.Telemetry.Enabled {
    apiSrv.SetTelemetry(metrics)
}
    errCh := make(chan error)

go func() {
    if err := apiSrv.Start(config); err != nil {
    errCh <- err
}
	
}()

select {
    case err := <-errCh:
			return err
    case <-time.After(types.ServerStartTime): // assume server started successfully
}
	
}

var (
		grpcSrv    *grpc.Server
		grpcWebSrv *http.Server
	)
    if config.GRPC.Enable {
    grpcSrv, err = servergrpc.StartGRPCServer(clientCtx, app, config.GRPC)
    if err != nil {
    return err
}

defer grpcSrv.Stop()
    if config.GRPCWeb.Enable {
    grpcWebSrv, err = servergrpc.StartGRPCWeb(grpcSrv, config)
    if err != nil {
    ctx.Logger.Error("failed to start grpc-web http server: ", err)

return err
}

defer func() {
    if err := grpcWebSrv.Close(); err != nil {
    ctx.Logger.Error("failed to close grpc-web http server: ", err)
}
	
}()
}
	
}

	// At this point it is safe to block the process if we're in gRPC only mode as
	// we do not need to start Rosetta or handle any Tendermint related processes.
    if gRPCOnly {
		// wait for signal capture and gracefully return
		return WaitForQuitSignals()
}

var rosettaSrv crgserver.Server
    if config.Rosetta.Enable {
    offlineMode := config.Rosetta.Offline

		// If GRPC is not enabled rosetta cannot work in online mode, so we throw an error.
    if !config.GRPC.Enable && !offlineMode {
    return errors.New("'grpc' must be enable in online mode for Rosetta to work")
}

minGasPrices, err := sdk.ParseDecCoins(config.MinGasPrices)
    if err != nil {
    ctx.Logger.Error("failed to parse minimum-gas-prices: ", err)

return err
}
    conf := &rosetta.Config{
    Blockchain:          config.Rosetta.Blockchain,
    Network:             config.Rosetta.Network,
    TendermintRPC:       ctx.Config.RPC.ListenAddress,
    GRPCEndpoint:        config.GRPC.Address,
    Addr:                config.Rosetta.Address,
    Retries:             config.Rosetta.Retries,
    Offline:             offlineMode,
    GasToSuggest:        config.Rosetta.GasToSuggest,
    EnableFeeSuggestion: config.Rosetta.EnableFeeSuggestion,
    GasPrices:           minGasPrices.Sort(),
    Codec:               clientCtx.Codec.(*codec.ProtoCodec),
    InterfaceRegistry:   clientCtx.InterfaceRegistry,
}

rosettaSrv, err = rosetta.ServerFromConfig(conf)
    if err != nil {
    return err
}
    errCh := make(chan error)

go func() {
    if err := rosettaSrv.Start(); err != nil {
    errCh <- err
}
	
}()

select {
    case err := <-errCh:
			return err
    case <-time.After(types.ServerStartTime): // assume server started successfully
}
	
}

defer func() {
    if tmNode != nil && tmNode.IsRunning() {
			_ = tmNode.Stop()
}
    if cpuProfileCleanup != nil {
    cpuProfileCleanup()
}
    if apiSrv != nil {
			_ = apiSrv.Close()
}

ctx.Logger.Info("exiting...")
}()

	// wait for signal capture and gracefully return
	return WaitForQuitSignals()
}

func startTelemetry(cfg serverconfig.Config) (*telemetry.Metrics, error) {
    if !cfg.Telemetry.Enabled {
    return nil, nil
}

return telemetry.New(cfg.Telemetry)
}
```

Upon starting, the node will bootstrap its RPC and P2P server and start dialing peers. During handshake with its peers, if the node realizes they are ahead, it will query all the blocks sequentially in order to catch up. Then, it will wait for new block proposals and block signatures from validators in order to make progress.

## Other commands

To discover how to concretely run a node and interact with it, please refer to our [Running a Node, API and CLI](/docs/sdk/v0.47//user/run-node/run-node) guide.
