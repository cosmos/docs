---
title: '`Msg` Services'
---

<Note>
**Synopsis**
A Protobuf `Msg` service processes [messages](messages-and-queries#messages). Protobuf `Msg` services are specific to the module in which they are defined, and only process messages defined within the said module. They are called from `BaseApp` during [`DeliverTx`](/docs/sdk/v0.47//learn/advanced/baseapp#delivertx).
</Note>

<Note>

### Pre-requisite Readings

* [Module Manager](module-manager)
* [Messages and Queries](messages-and-queries)

</Note>

## Implementation of a module `Msg` service

Each module should define a Protobuf `Msg` service, which will be responsible for processing requests (implementing `sdk.Msg`) and returning responses.

As further described in [ADR 031](/docs/sdk/v0.47/architecture/adr-031-msg-service), this approach has the advantage of clearly specifying return types and generating server and client code.

Protobuf generates a `MsgServer` interface based on a definition of `Msg` service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each `sdk.Msg`. As an example, here is the generated `MsgServer` interface for `x/bank`, which exposes two `sdk.Msg`s:

```go expandable
// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/bank/v1beta1/tx.proto

package types

import (
    
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgSend represents a message to send coins from one account to another.
type MsgSend struct {
    FromAddress string                                   `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	ToAddress   string                                   `protobuf:"bytes,2,opt,name=to_address,json=toAddress,proto3" json:"to_address,omitempty"`
	Amount      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
}

func (m *MsgSend)

Reset() { *m = MsgSend{
} 
}

func (m *MsgSend)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgSend)

ProtoMessage() {
}

func (*MsgSend)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{0
}
}

func (m *MsgSend)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgSend)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgSend.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgSend)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgSend.Merge(m, src)
}

func (m *MsgSend)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgSend)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgSend.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSend proto.InternalMessageInfo

// MsgSendResponse defines the Msg/Send response type.
type MsgSendResponse struct {
}

func (m *MsgSendResponse)

Reset() { *m = MsgSendResponse{
} 
}

func (m *MsgSendResponse)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgSendResponse)

ProtoMessage() {
}

func (*MsgSendResponse)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{1
}
}

func (m *MsgSendResponse)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgSendResponse)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgSendResponse.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgSendResponse)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgSendResponse.Merge(m, src)
}

func (m *MsgSendResponse)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgSendResponse)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgSendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendResponse proto.InternalMessageInfo

// MsgMultiSend represents an arbitrary multi-in, multi-out send message.
type MsgMultiSend struct {
	// Inputs, despite being `repeated`, only allows one sender input. This is
	// checked in MsgMultiSend's ValidateBasic.
	Inputs  []Input  `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs"`
	Outputs []Output `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs"`
}

func (m *MsgMultiSend)

Reset() { *m = MsgMultiSend{
} 
}

func (m *MsgMultiSend)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgMultiSend)

ProtoMessage() {
}

func (*MsgMultiSend)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{2
}
}

func (m *MsgMultiSend)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgMultiSend)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgMultiSend.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgMultiSend)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgMultiSend.Merge(m, src)
}

func (m *MsgMultiSend)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgMultiSend)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgMultiSend.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMultiSend proto.InternalMessageInfo

func (m *MsgMultiSend)

GetInputs() []Input {
    if m != nil {
    return m.Inputs
}

return nil
}

func (m *MsgMultiSend)

GetOutputs() []Output {
    if m != nil {
    return m.Outputs
}

return nil
}

// MsgMultiSendResponse defines the Msg/MultiSend response type.
type MsgMultiSendResponse struct {
}

func (m *MsgMultiSendResponse)

Reset() { *m = MsgMultiSendResponse{
} 
}

func (m *MsgMultiSendResponse)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgMultiSendResponse)

ProtoMessage() {
}

func (*MsgMultiSendResponse)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{3
}
}

func (m *MsgMultiSendResponse)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgMultiSendResponse)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgMultiSendResponse.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgMultiSendResponse)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgMultiSendResponse.Merge(m, src)
}

func (m *MsgMultiSendResponse)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgMultiSendResponse)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgMultiSendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMultiSendResponse proto.InternalMessageInfo

// MsgUpdateParams is the Msg/UpdateParams request type.
//
// Since: cosmos-sdk 0.47
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the x/bank parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams)

Reset() { *m = MsgUpdateParams{
} 
}

func (m *MsgUpdateParams)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgUpdateParams)

ProtoMessage() {
}

func (*MsgUpdateParams)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{4
}
}

func (m *MsgUpdateParams)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgUpdateParams)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgUpdateParams)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}

func (m *MsgUpdateParams)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgUpdateParams)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams)

GetAuthority()

string {
    if m != nil {
    return m.Authority
}

return ""
}

func (m *MsgUpdateParams)

GetParams()

Params {
    if m != nil {
    return m.Params
}

return Params{
}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
//
// Since: cosmos-sdk 0.47
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse)

Reset() { *m = MsgUpdateParamsResponse{
} 
}

func (m *MsgUpdateParamsResponse)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgUpdateParamsResponse)

ProtoMessage() {
}

func (*MsgUpdateParamsResponse)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{5
}
}

func (m *MsgUpdateParamsResponse)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgUpdateParamsResponse)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgUpdateParamsResponse)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}

func (m *MsgUpdateParamsResponse)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgUpdateParamsResponse)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgSetSendEnabled is the Msg/SetSendEnabled request type.
//
// Only entries to add/update/delete need to be included.
// Existing SendEnabled entries that are not included in this
// message are left unchanged.
//
// Since: cosmos-sdk 0.47
type MsgSetSendEnabled struct {
    Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// send_enabled is the list of entries to add or update.
	SendEnabled []*SendEnabled `protobuf:"bytes,2,rep,name=send_enabled,json=sendEnabled,proto3" json:"send_enabled,omitempty"`
	// use_default_for is a list of denoms that should use the params.default_send_enabled value.
	// Denoms listed here will have their SendEnabled entries deleted.
	// If a denom is included that doesn't have a SendEnabled entry,
	// it will be ignored.
	UseDefaultFor []string `protobuf:"bytes,3,rep,name=use_default_for,json=useDefaultFor,proto3" json:"use_default_for,omitempty"`
}

func (m *MsgSetSendEnabled)

Reset() { *m = MsgSetSendEnabled{
} 
}

func (m *MsgSetSendEnabled)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgSetSendEnabled)

ProtoMessage() {
}

func (*MsgSetSendEnabled)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{6
}
}

func (m *MsgSetSendEnabled)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgSetSendEnabled)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgSetSendEnabled.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgSetSendEnabled)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgSetSendEnabled.Merge(m, src)
}

func (m *MsgSetSendEnabled)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgSetSendEnabled)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgSetSendEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetSendEnabled proto.InternalMessageInfo

func (m *MsgSetSendEnabled)

GetAuthority()

string {
    if m != nil {
    return m.Authority
}

return ""
}

func (m *MsgSetSendEnabled)

GetSendEnabled() []*SendEnabled {
    if m != nil {
    return m.SendEnabled
}

return nil
}

func (m *MsgSetSendEnabled)

GetUseDefaultFor() []string {
    if m != nil {
    return m.UseDefaultFor
}

return nil
}

// MsgSetSendEnabledResponse defines the Msg/SetSendEnabled response type.
//
// Since: cosmos-sdk 0.47
type MsgSetSendEnabledResponse struct {
}

func (m *MsgSetSendEnabledResponse)

Reset() { *m = MsgSetSendEnabledResponse{
} 
}

func (m *MsgSetSendEnabledResponse)

String()

string {
    return proto.CompactTextString(m)
}

func (*MsgSetSendEnabledResponse)

ProtoMessage() {
}

func (*MsgSetSendEnabledResponse)

Descriptor() ([]byte, []int) {
    return fileDescriptor_1d8cb1613481f5b7, []int{7
}
}

func (m *MsgSetSendEnabledResponse)

XXX_Unmarshal(b []byte)

error {
    return m.Unmarshal(b)
}

func (m *MsgSetSendEnabledResponse)

XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
    if deterministic {
    return xxx_messageInfo_MsgSetSendEnabledResponse.Marshal(b, m, deterministic)
}

else {
    b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
    if err != nil {
    return nil, err
}

return b[:n], nil
}
}

func (m *MsgSetSendEnabledResponse)

XXX_Merge(src proto.Message) {
    xxx_messageInfo_MsgSetSendEnabledResponse.Merge(m, src)
}

func (m *MsgSetSendEnabledResponse)

XXX_Size()

int {
    return m.Size()
}

func (m *MsgSetSendEnabledResponse)

XXX_DiscardUnknown() {
    xxx_messageInfo_MsgSetSendEnabledResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetSendEnabledResponse proto.InternalMessageInfo

func init() {
    proto.RegisterType((*MsgSend)(nil), "cosmos.bank.v1beta1.MsgSend")

proto.RegisterType((*MsgSendResponse)(nil), "cosmos.bank.v1beta1.MsgSendResponse")

proto.RegisterType((*MsgMultiSend)(nil), "cosmos.bank.v1beta1.MsgMultiSend")

proto.RegisterType((*MsgMultiSendResponse)(nil), "cosmos.bank.v1beta1.MsgMultiSendResponse")

proto.RegisterType((*MsgUpdateParams)(nil), "cosmos.bank.v1beta1.MsgUpdateParams")

proto.RegisterType((*MsgUpdateParamsResponse)(nil), "cosmos.bank.v1beta1.MsgUpdateParamsResponse")

proto.RegisterType((*MsgSetSendEnabled)(nil), "cosmos.bank.v1beta1.MsgSetSendEnabled")

proto.RegisterType((*MsgSetSendEnabledResponse)(nil), "cosmos.bank.v1beta1.MsgSetSendEnabledResponse")
}

func init() {
    proto.RegisterFile("cosmos/bank/v1beta1/tx.proto", fileDescriptor_1d8cb1613481f5b7)
}

var fileDescriptor_1d8cb1613481f5b7 = []byte{
	// 690 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x4f, 0xd4, 0x5e,
	0x14, 0x6d, 0x99, 0xdf, 0x6f, 0x48, 0x1f, 0xa3, 0x84, 0x4a, 0x84, 0x29, 0xa4, 0x03, 0x8d, 0x21,
	0x80, 0xd2, 0x0a, 0x7e, 0x25, 0x63, 0x34, 0x3a, 0xa8, 0x89, 0x26, 0x13, 0xcd, 0x10, 0x17, 0xba,
	0x99, 0xb4, 0xf4, 0xd1, 0x69, 0xa0, 0x7d, 0x4d, 0xdf, 0x2b, 0x81, 0x9d, 0xba, 0x32, 0xae, 0xdc,
	0xbb, 0x61, 0x69, 0x5c, 0xb1, 0x70, 0x69, 0xe2, 0x96, 0x25, 0x71, 0xe5, 0x4a, 0x0d, 0x2c, 0xd0,
	0xff, 0xc2, 0xbc, 0x8f, 0x96, 0xce, 0x30, 0xc3, 0x10, 0x37, 0xd3, 0xce, 0xbb, 0xe7, 0x9c, 0x7b,
	0xcf, 0xed, 0x69, 0xc1, 0xe4, 0x2a, 0xc2, 0x01, 0xc2, 0x96, 0x63, 0x87, 0xeb, 0xd6, 0xe6, 0xa2,
	0x03, 0x89, 0xbd, 0x68, 0x91, 0x2d, 0x33, 0x8a, 0x11, 0x41, 0xea, 0x05, 0x5e, 0x35, 0x69, 0xd5,
	0x14, 0x55, 0x6d, 0xd4, 0x43, 0x1e, 0x62, 0x75, 0x8b, 0xde, 0x71, 0xa8, 0xa6, 0x67, 0x42, 0x18,
	0x66, 0x42, 0xab, 0xc8, 0x0f, 0x4f, 0xd4, 0x73, 0x8d, 0x98, 0x2e, 0xaf, 0x97, 0x79, 0xbd, 0xc9,
	0x85, 0x45, 0x5f, 0x5e, 0x1a, 0x13, 0xd4, 0x00, 0x7b, 0xd6, 0xe6, 0x22, 0xbd, 0x88, 0xc2, 0x88,
	0x1d, 0xf8, 0x21, 0xb2, 0xd8, 0x2f, 0x3f, 0x32, 0x3e, 0x0c, 0x80, 0xc1, 0x3a, 0xf6, 0x56, 0x60,
	0xe8, 0xaa, 0xb7, 0x41, 0x69, 0x2d, 0x46, 0x41, 0xd3, 0x76, 0xdd, 0x18, 0x62, 0x3c, 0x2e, 0x4f,
	0xc9, 0xb3, 0x4a, 0x6d, 0xfc, 0xdb, 0xe7, 0x85, 0x51, 0xa1, 0x7f, 0x9f, 0x57, 0x56, 0x48, 0xec,
	0x87, 0x5e, 0x63, 0x88, 0xa2, 0xc5, 0x91, 0x7a, 0x0b, 0x00, 0x82, 0x32, 0xea, 0x40, 0x1f, 0xaa,
	0x42, 0x50, 0x4a, 0x6c, 0x81, 0xa2, 0x1d, 0xa0, 0x24, 0x24, 0xe3, 0x85, 0xa9, 0xc2, 0xec, 0xd0,
	0x52, 0xd9, 0xcc, 0x96, 0x88, 0x61, 0xba, 0x44, 0x73, 0x19, 0xf9, 0x61, 0xed, 0xc6, 0xde, 0x8f,
	0x8a, 0xf4, 0xe9, 0x67, 0x65, 0xd6, 0xf3, 0x49, 0x2b, 0x71, 0xcc, 0x55, 0x14, 0x08, 0xe7, 0xe2,
	0xb2, 0x80, 0xdd, 0x75, 0x8b, 0x6c, 0x47, 0x10, 0x33, 0x02, 0xfe, 0x78, 0xb4, 0x3b, 0x2f, 0x37,
	0x84, 0x7e, 0xf5, 0xea, 0xdb, 0x9d, 0x8a, 0xf4, 0x7b, 0xa7, 0x22, 0xbd, 0x39, 0xda, 0x9d, 0x6f,
	0xb3, 0xfa, 0xee, 0x68, 0x77, 0x5e, 0xcd, 0x49, 0x88, 0x8d, 0x18, 0x23, 0x60, 0x58, 0xdc, 0x36,
	0x20, 0x8e, 0x50, 0x88, 0xa1, 0xf1, 0x45, 0x06, 0xa5, 0x3a, 0xf6, 0xea, 0xc9, 0x06, 0xf1, 0xd9,
	0xd6, 0xee, 0x80, 0xa2, 0x1f, 0x46, 0x09, 0xa1, 0xfb, 0xa2, 0xf3, 0x6b, 0x66, 0x97, 0x10, 0x98,
	0x8f, 0x29, 0xa4, 0xa6, 0x50, 0x03, 0x62, 0x28, 0x4e, 0x52, 0xef, 0x81, 0x41, 0x94, 0x10, 0xc6,
	0x1f, 0x60, 0xfc, 0x89, 0xae, 0xfc, 0xa7, 0x0c, 0x93, 0x17, 0x48, 0x69, 0xd5, 0xcb, 0xa9, 0x25,
	0x21, 0x49, 0xcd, 0x8c, 0xb5, 0x9b, 0xc9, 0xa6, 0x35, 0x2e, 0x82, 0xd1, 0xfc, 0xff, 0xcc, 0xd6,
	0x57, 0x99, 0x59, 0x7d, 0x1e, 0xb9, 0x36, 0x81, 0xcf, 0xec, 0xd8, 0x0e, 0xb0, 0x7a, 0x13, 0x28,
	0x76, 0x42, 0x5a, 0x28, 0xf6, 0xc9, 0x76, 0xdf, 0x30, 0x1c, 0x43, 0xd5, 0xbb, 0xa0, 0x18, 0x31,
	0x05, 0x16, 0x83, 0x5e, 0x8e, 0x78, 0x93, 0xb6, 0x95, 0x70, 0x56, 0xf5, 0x3a, 0x35, 0x73, 0xac,
	0x47, 0xfd, 0x4c, 0xe7, 0xfc, 0x6c, 0xf1, 0x77, 0xa2, 0x63, 0x5a, 0xa3, 0x0c, 0xc6, 0x3a, 0x8e,
	0x32, 0x73, 0x7f, 0x64, 0x30, 0xc2, 0x9e, 0x23, 0xa1, 0x9e, 0x1f, 0x86, 0xb6, 0xb3, 0x01, 0xdd,
	0x7f, 0xb6, 0xb7, 0x0c, 0x4a, 0x18, 0x86, 0x6e, 0x13, 0x72, 0x1d, 0xf1, 0xd8, 0xa6, 0xba, 0x9a,
	0xcc, 0xf5, 0x6b, 0x0c, 0xe1, 0x5c, 0xf3, 0x19, 0x30, 0x9c, 0x60, 0xd8, 0x74, 0xe1, 0x9a, 0x9d,
	0x6c, 0x90, 0xe6, 0x1a, 0x8a, 0x59, 0xfc, 0x95, 0xc6, 0xb9, 0x04, 0xc3, 0x07, 0xfc, 0xf4, 0x11,
	0x8a, 0xab, 0xd6, 0xc9, 0x5d, 0x4c, 0x76, 0x06, 0x35, 0xef, 0xca, 0x98, 0x00, 0xe5, 0x13, 0x87,
	0xe9, 0x22, 0x96, 0x5e, 0x17, 0x40, 0xa1, 0x8e, 0x3d, 0xf5, 0x09, 0xf8, 0x8f, 0x65, 0x77, 0xb2,
	0xeb, 0xd0, 0x22, 0xf2, 0xda, 0xa5, 0xd3, 0xaa, 0xa9, 0xa6, 0xfa, 0x02, 0x28, 0xc7, 0x2f, 0xc3,
	0x74, 0x2f, 0x4a, 0x06, 0xd1, 0xe6, 0xfa, 0x42, 0x32, 0x69, 0x07, 0x94, 0xda, 0x02, 0xd9, 0x73,
	0xa0, 0x3c, 0x4a, 0xbb, 0x72, 0x16, 0x54, 0xd6, 0xa3, 0x05, 0xce, 0x77, 0xe4, 0x62, 0xa6, 0xb7,
	0xed, 0x3c, 0x4e, 0x33, 0xcf, 0x86, 0x4b, 0x3b, 0x69, 0xff, 0xbf, 0xa2, 0x29, 0xaf, 0x2d, 0xef,
	0x1d, 0xe8, 0xf2, 0xfe, 0x81, 0x2e, 0xff, 0x3a, 0xd0, 0xe5, 0xf7, 0x87, 0xba, 0xb4, 0x7f, 0xa8,
	0x4b, 0xdf, 0x0f, 0x75, 0xe9, 0xe5, 0xdc, 0xa9, 0x9f, 0x35, 0x11, 0x7b, 0xf6, 0x75, 0x73, 0x8a,
	0xec, 0xeb, 0x7d, 0xed, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2f, 0xe8, 0x90, 0x24, 0x8f, 0x06,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Send defines a method for sending coins from one account to another account.
	Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)
	// MultiSend defines a method for sending coins from some accounts to other accounts.
	MultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error)
	// UpdateParams defines a governance operation for updating the x/bank module parameters.
	// The authority is defined in the keeper.
	//
	// Since: cosmos-sdk 0.47
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// SetSendEnabled is a governance operation for setting the SendEnabled flag
	// on any number of Denoms. Only the entries to add or update should be
	// included. Entries that already exist in the store, but that aren't
	// included in this message, will be left unchanged.
	//
	// Since: cosmos-sdk 0.47
	SetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error)
}

type msgClient struct {
    cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn)

MsgClient {
    return &msgClient{
    cc
}
}

func (c *msgClient)

Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {
    out := new(MsgSendResponse)
    err := c.cc.Invoke(ctx, "/cosmos.bank.v1beta1.Msg/Send", in, out, opts...)
    if err != nil {
    return nil, err
}

return out, nil
}

func (c *msgClient)

MultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error) {
    out := new(MsgMultiSendResponse)
    err := c.cc.Invoke(ctx, "/cosmos.bank.v1beta1.Msg/MultiSend", in, out, opts...)
    if err != nil {
    return nil, err
}

return out, nil
}

func (c *msgClient)

UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
    out := new(MsgUpdateParamsResponse)
    err := c.cc.Invoke(ctx, "/cosmos.bank.v1beta1.Msg/UpdateParams", in, out, opts...)
    if err != nil {
    return nil, err
}

return out, nil
}

func (c *msgClient)

SetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error) {
    out := new(MsgSetSendEnabledResponse)
    err := c.cc.Invoke(ctx, "/cosmos.bank.v1beta1.Msg/SetSendEnabled", in, out, opts...)
    if err != nil {
    return nil, err
}

return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Send defines a method for sending coins from one account to another account.
	Send(context.Context, *MsgSend) (*MsgSendResponse, error)
	// MultiSend defines a method for sending coins from some accounts to other accounts.
	MultiSend(context.Context, *MsgMultiSend) (*MsgMultiSendResponse, error)
	// UpdateParams defines a governance operation for updating the x/bank module parameters.
	// The authority is defined in the keeper.
	//
	// Since: cosmos-sdk 0.47
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// SetSendEnabled is a governance operation for setting the SendEnabled flag
	// on any number of Denoms. Only the entries to add or update should be
	// included. Entries that already exist in the store, but that aren't
	// included in this message, will be left unchanged.
	//
	// Since: cosmos-sdk 0.47
	SetSendEnabled(context.Context, *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer)

Send(ctx context.Context, req *MsgSend) (*MsgSendResponse, error) {
    return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}

func (*UnimplementedMsgServer)

MultiSend(ctx context.Context, req *MsgMultiSend) (*MsgMultiSendResponse, error) {
    return nil, status.Errorf(codes.Unimplemented, "method MultiSend not implemented")
}

func (*UnimplementedMsgServer)

UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
    return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}

func (*UnimplementedMsgServer)

SetSendEnabled(ctx context.Context, req *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error) {
    return nil, status.Errorf(codes.Unimplemented, "method SetSendEnabled not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
    s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Send_Handler(srv interface{
}, ctx context.Context, dec func(interface{
})

error, interceptor grpc.UnaryServerInterceptor) (interface{
}, error) {
    in := new(MsgSend)
    if err := dec(in); err != nil {
    return nil, err
}
    if interceptor == nil {
    return srv.(MsgServer).Send(ctx, in)
}
    info := &grpc.UnaryServerInfo{
    Server:     srv,
    FullMethod: "/cosmos.bank.v1beta1.Msg/Send",
}
    handler := func(ctx context.Context, req interface{
}) (interface{
}, error) {
    return srv.(MsgServer).Send(ctx, req.(*MsgSend))
}

return interceptor(ctx, in, info, handler)
}

func _Msg_MultiSend_Handler(srv interface{
}, ctx context.Context, dec func(interface{
})

error, interceptor grpc.UnaryServerInterceptor) (interface{
}, error) {
    in := new(MsgMultiSend)
    if err := dec(in); err != nil {
    return nil, err
}
    if interceptor == nil {
    return srv.(MsgServer).MultiSend(ctx, in)
}
    info := &grpc.UnaryServerInfo{
    Server:     srv,
    FullMethod: "/cosmos.bank.v1beta1.Msg/MultiSend",
}
    handler := func(ctx context.Context, req interface{
}) (interface{
}, error) {
    return srv.(MsgServer).MultiSend(ctx, req.(*MsgMultiSend))
}

return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{
}, ctx context.Context, dec func(interface{
})

error, interceptor grpc.UnaryServerInterceptor) (interface{
}, error) {
    in := new(MsgUpdateParams)
    if err := dec(in); err != nil {
    return nil, err
}
    if interceptor == nil {
    return srv.(MsgServer).UpdateParams(ctx, in)
}
    info := &grpc.UnaryServerInfo{
    Server:     srv,
    FullMethod: "/cosmos.bank.v1beta1.Msg/UpdateParams",
}
    handler := func(ctx context.Context, req interface{
}) (interface{
}, error) {
    return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
}

return interceptor(ctx, in, info, handler)
}

func _Msg_SetSendEnabled_Handler(srv interface{
}, ctx context.Context, dec func(interface{
})

error, interceptor grpc.UnaryServerInterceptor) (interface{
}, error) {
    in := new(MsgSetSendEnabled)
    if err := dec(in); err != nil {
    return nil, err
}
    if interceptor == nil {
    return srv.(MsgServer).SetSendEnabled(ctx, in)
}
    info := &grpc.UnaryServerInfo{
    Server:     srv,
    FullMethod: "/cosmos.bank.v1beta1.Msg/SetSendEnabled",
}
    handler := func(ctx context.Context, req interface{
}) (interface{
}, error) {
    return srv.(MsgServer).SetSendEnabled(ctx, req.(*MsgSetSendEnabled))
}

return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
    ServiceName: "cosmos.bank.v1beta1.Msg",
    HandlerType: (*MsgServer)(nil),
    Methods: []grpc.MethodDesc{
		{
    MethodName: "Send",
    Handler:    _Msg_Send_Handler,
},
		{
    MethodName: "MultiSend",
    Handler:    _Msg_MultiSend_Handler,
},
		{
    MethodName: "UpdateParams",
    Handler:    _Msg_UpdateParams_Handler,
},
		{
    MethodName: "SetSendEnabled",
    Handler:    _Msg_SetSendEnabled_Handler,
},
},
    Streams:  []grpc.StreamDesc{
},
    Metadata: "cosmos/bank/v1beta1/tx.proto",
}

func (m *MsgSend)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgSend)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSend)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
    if len(m.Amount) > 0 {
    for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
    size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
    if err != nil {
    return 0, err
}

i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
}

i--
			dAtA[i] = 0x1a
}
	
}
    if len(m.ToAddress) > 0 {
    i -= len(m.ToAddress)

copy(dAtA[i:], m.ToAddress)

i = encodeVarintTx(dAtA, i, uint64(len(m.ToAddress)))

i--
		dAtA[i] = 0x12
}
    if len(m.FromAddress) > 0 {
    i -= len(m.FromAddress)

copy(dAtA[i:], m.FromAddress)

i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))

i--
		dAtA[i] = 0xa
}

return len(dAtA) - i, nil
}

func (m *MsgSendResponse)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgSendResponse)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendResponse)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgMultiSend)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgMultiSend)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMultiSend)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
    if len(m.Outputs) > 0 {
    for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
    size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
    if err != nil {
    return 0, err
}

i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
}

i--
			dAtA[i] = 0x12
}
	
}
    if len(m.Inputs) > 0 {
    for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
    size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
    if err != nil {
    return 0, err
}

i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
}

i--
			dAtA[i] = 0xa
}
	
}

return len(dAtA) - i, nil
}

func (m *MsgMultiSendResponse)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgMultiSendResponse)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMultiSendResponse)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgUpdateParams)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
    size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
    if err != nil {
    return 0, err
}

i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
}

i--
	dAtA[i] = 0x12
    if len(m.Authority) > 0 {
    i -= len(m.Authority)

copy(dAtA[i:], m.Authority)

i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))

i--
		dAtA[i] = 0xa
}

return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetSendEnabled)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgSetSendEnabled)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetSendEnabled)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
    if len(m.UseDefaultFor) > 0 {
    for iNdEx := len(m.UseDefaultFor) - 1; iNdEx >= 0; iNdEx-- {
    i -= len(m.UseDefaultFor[iNdEx])

copy(dAtA[i:], m.UseDefaultFor[iNdEx])

i = encodeVarintTx(dAtA, i, uint64(len(m.UseDefaultFor[iNdEx])))

i--
			dAtA[i] = 0x1a
}
	
}
    if len(m.SendEnabled) > 0 {
    for iNdEx := len(m.SendEnabled) - 1; iNdEx >= 0; iNdEx-- {
			{
    size, err := m.SendEnabled[iNdEx].MarshalToSizedBuffer(dAtA[:i])
    if err != nil {
    return 0, err
}

i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
}

i--
			dAtA[i] = 0x12
}
	
}
    if len(m.Authority) > 0 {
    i -= len(m.Authority)

copy(dAtA[i:], m.Authority)

i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))

i--
		dAtA[i] = 0xa
}

return len(dAtA) - i, nil
}

func (m *MsgSetSendEnabledResponse)

Marshal() (dAtA []byte, err error) {
    size := m.Size()

dAtA = make([]byte, size)

n, err := m.MarshalToSizedBuffer(dAtA[:size])
    if err != nil {
    return nil, err
}

return dAtA[:n], nil
}

func (m *MsgSetSendEnabledResponse)

MarshalTo(dAtA []byte) (int, error) {
    size := m.Size()

return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetSendEnabledResponse)

MarshalToSizedBuffer(dAtA []byte) (int, error) {
    i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64)

int {
    offset -= sovTx(v)
    base := offset
    for v >= 1<<7 {
    dAtA[offset] = uint8(v&0x7f | 0x80)

v >>= 7
		offset++
}

dAtA[offset] = uint8(v)

return base
}

func (m *MsgSend)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
	l = len(m.FromAddress)
    if l > 0 {
    n += 1 + l + sovTx(uint64(l))
}

l = len(m.ToAddress)
    if l > 0 {
    n += 1 + l + sovTx(uint64(l))
}
    if len(m.Amount) > 0 {
    for _, e := range m.Amount {
    l = e.Size()

n += 1 + l + sovTx(uint64(l))
}
	
}

return n
}

func (m *MsgSendResponse)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
	return n
}

func (m *MsgMultiSend)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
    if len(m.Inputs) > 0 {
    for _, e := range m.Inputs {
    l = e.Size()

n += 1 + l + sovTx(uint64(l))
}
	
}
    if len(m.Outputs) > 0 {
    for _, e := range m.Outputs {
    l = e.Size()

n += 1 + l + sovTx(uint64(l))
}
	
}

return n
}

func (m *MsgMultiSendResponse)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
	return n
}

func (m *MsgUpdateParams)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
	l = len(m.Authority)
    if l > 0 {
    n += 1 + l + sovTx(uint64(l))
}

l = m.Params.Size()

n += 1 + l + sovTx(uint64(l))

return n
}

func (m *MsgUpdateParamsResponse)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
	return n
}

func (m *MsgSetSendEnabled)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
	l = len(m.Authority)
    if l > 0 {
    n += 1 + l + sovTx(uint64(l))
}
    if len(m.SendEnabled) > 0 {
    for _, e := range m.SendEnabled {
    l = e.Size()

n += 1 + l + sovTx(uint64(l))
}
	
}
    if len(m.UseDefaultFor) > 0 {
    for _, s := range m.UseDefaultFor {
    l = len(s)

n += 1 + l + sovTx(uint64(l))
}
	
}

return n
}

func (m *MsgSetSendEnabledResponse)

Size() (n int) {
    if m == nil {
    return 0
}

var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
    return (math_bits.Len64(x|1) + 6) / 7
}

func sozTx(x uint64) (n int) {
    return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}

func (m *MsgSend)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgSend: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgSend: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    case 1:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
}

var stringLen uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    intStringLen := int(stringLen)
    if intStringLen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + intStringLen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.FromAddress = string(dAtA[iNdEx:postIndex])

iNdEx = postIndex
    case 2:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
}

var stringLen uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    intStringLen := int(stringLen)
    if intStringLen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + intStringLen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.ToAddress = string(dAtA[iNdEx:postIndex])

iNdEx = postIndex
    case 3:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
}

var msglen int
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    if msglen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + msglen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.Amount = append(m.Amount, types.Coin{
})
    if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
    return err
}

iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func (m *MsgSendResponse)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgSendResponse: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgSendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func (m *MsgMultiSend)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgMultiSend: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgMultiSend: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    case 1:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
}

var msglen int
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    if msglen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + msglen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.Inputs = append(m.Inputs, Input{
})
    if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
    return err
}

iNdEx = postIndex
    case 2:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
}

var msglen int
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    if msglen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + msglen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.Outputs = append(m.Outputs, Output{
})
    if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
    return err
}

iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func (m *MsgMultiSendResponse)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgMultiSendResponse: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgMultiSendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func (m *MsgUpdateParams)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    case 1:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
}

var stringLen uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    intStringLen := int(stringLen)
    if intStringLen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + intStringLen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.Authority = string(dAtA[iNdEx:postIndex])

iNdEx = postIndex
    case 2:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
}

var msglen int
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    if msglen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + msglen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}
    if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
    return err
}

iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func (m *MsgUpdateParamsResponse)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func (m *MsgSetSendEnabled)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgSetSendEnabled: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgSetSendEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    case 1:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
}

var stringLen uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    intStringLen := int(stringLen)
    if intStringLen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + intStringLen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.Authority = string(dAtA[iNdEx:postIndex])

iNdEx = postIndex
    case 2:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field SendEnabled", wireType)
}

var msglen int
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    if msglen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + msglen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.SendEnabled = append(m.SendEnabled, &SendEnabled{
})
    if err := m.SendEnabled[len(m.SendEnabled)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
    return err
}

iNdEx = postIndex
    case 3:
    if wireType != 2 {
    return fmt.Errorf("proto: wrong wireType = %d for field UseDefaultFor", wireType)
}

var stringLen uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    intStringLen := int(stringLen)
    if intStringLen < 0 {
    return ErrInvalidLengthTx
}
    postIndex := iNdEx + intStringLen
    if postIndex < 0 {
    return ErrInvalidLengthTx
}
    if postIndex > l {
    return io.ErrUnexpectedEOF
}

m.UseDefaultFor = append(m.UseDefaultFor, string(dAtA[iNdEx:postIndex]))

iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func (m *MsgSetSendEnabledResponse)

Unmarshal(dAtA []byte)

error {
    l := len(dAtA)
    iNdEx := 0
    for iNdEx < l {
    preIndex := iNdEx
		var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return ErrIntOverflowTx
}
    if iNdEx >= l {
    return io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    fieldNum := int32(wire >> 3)
    wireType := int(wire & 0x7)
    if wireType == 4 {
    return fmt.Errorf("proto: MsgSetSendEnabledResponse: wiretype end group for non-group")
}
    if fieldNum <= 0 {
    return fmt.Errorf("proto: MsgSetSendEnabledResponse: illegal tag %d (wire type %d)", fieldNum, wire)
}
    switch fieldNum {
    default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
    if err != nil {
    return err
}
    if (skippy < 0) || (iNdEx+skippy) < 0 {
    return ErrInvalidLengthTx
}
    if (iNdEx + skippy) > l {
    return io.ErrUnexpectedEOF
}

iNdEx += skippy
}
	
}
    if iNdEx > l {
    return io.ErrUnexpectedEOF
}

return nil
}

func skipTx(dAtA []byte) (n int, err error) {
    l := len(dAtA)
    iNdEx := 0
    depth := 0
    for iNdEx < l {
    var wire uint64
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return 0, ErrIntOverflowTx
}
    if iNdEx >= l {
    return 0, io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    wireType := int(wire & 0x7)
    switch wireType {
    case 0:
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return 0, ErrIntOverflowTx
}
    if iNdEx >= l {
    return 0, io.ErrUnexpectedEOF
}

iNdEx++
    if dAtA[iNdEx-1] < 0x80 {
    break
}
	
}
    case 1:
			iNdEx += 8
    case 2:
			var length int
    for shift := uint(0); ; shift += 7 {
    if shift >= 64 {
    return 0, ErrIntOverflowTx
}
    if iNdEx >= l {
    return 0, io.ErrUnexpectedEOF
}
    b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
    if b < 0x80 {
    break
}
	
}
    if length < 0 {
    return 0, ErrInvalidLengthTx
}

iNdEx += length
    case 3:
			depth++
    case 4:
    if depth == 0 {
    return 0, ErrUnexpectedEndOfGroupTx
}

depth--
    case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
}
    if iNdEx < 0 {
    return 0, ErrInvalidLengthTx
}
    if depth == 0 {
    return iNdEx, nil
}
	
}

return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")

ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")

ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
```

When possible, the existing module's [`Keeper`](keeper) should implement `MsgServer`, otherwise a `msgServer` struct that embeds the `Keeper` can be created, typically in `./keeper/msg_server.go`:

```go expandable
package keeper

import (
    
	"context"
    "github.com/armon/go-metrics"
    "github.com/cosmos/cosmos-sdk/telemetry"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
    "github.com/cosmos/cosmos-sdk/x/bank/types"
	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

type msgServer struct {
    Keeper
}

var _ types.MsgServer = msgServer{
}

// NewMsgServerImpl returns an implementation of the bank MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper)

types.MsgServer {
    return &msgServer{
    Keeper: keeper
}
}

func (k msgServer)

Send(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)
    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {
    return nil, err
}

from, err := sdk.AccAddressFromBech32(msg.FromAddress)
    if err != nil {
    return nil, err
}

to, err := sdk.AccAddressFromBech32(msg.ToAddress)
    if err != nil {
    return nil, err
}
    if k.BlockedAddr(to) {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.ToAddress)
}

err = k.SendCoins(ctx, from, to, msg.Amount)
    if err != nil {
    return nil, err
}

defer func() {
    for _, a := range msg.Amount {
    if a.Amount.IsInt64() {
    telemetry.SetGaugeWithLabels(
					[]string{"tx", "msg", "send"
},
					float32(a.Amount.Int64()),
					[]metrics.Label{
    telemetry.NewLabel("denom", a.Denom)
},
				)
}
	
}
	
}()

return &types.MsgSendResponse{
}, nil
}

func (k msgServer)

MultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)

	// NOTE: totalIn == totalOut should already have been checked
    for _, in := range msg.Inputs {
    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {
    return nil, err
}
	
}
    for _, out := range msg.Outputs {
    accAddr := sdk.MustAccAddressFromBech32(out.Address)
    if k.BlockedAddr(accAddr) {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", out.Address)
}
	
}
    err := k.InputOutputCoins(ctx, msg.Inputs, msg.Outputs)
    if err != nil {
    return nil, err
}

return &types.MsgMultiSendResponse{
}, nil
}

func (k msgServer)

UpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {
    if k.GetAuthority() != req.Authority {
    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), req.Authority)
}
    ctx := sdk.UnwrapSDKContext(goCtx)
    if err := k.SetParams(ctx, req.Params); err != nil {
    return nil, err
}

return &types.MsgUpdateParamsResponse{
}, nil
}

func (k msgServer)

SetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {
    if k.GetAuthority() != msg.Authority {
    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), msg.Authority)
}
    ctx := sdk.UnwrapSDKContext(goCtx)
    if len(msg.SendEnabled) > 0 {
    k.SetAllSendEnabled(ctx, msg.SendEnabled)
}
    if len(msg.UseDefaultFor) > 0 {
    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)
}

return &types.MsgSetSendEnabledResponse{
}, nil
}
```

`msgServer` methods can retrieve the `sdk.Context` from the `context.Context` parameter method using the `sdk.UnwrapSDKContext`:

```go expandable
package keeper

import (
    
	"context"
    "github.com/armon/go-metrics"
    "github.com/cosmos/cosmos-sdk/telemetry"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
    "github.com/cosmos/cosmos-sdk/x/bank/types"
	govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

type msgServer struct {
    Keeper
}

var _ types.MsgServer = msgServer{
}

// NewMsgServerImpl returns an implementation of the bank MsgServer interface
// for the provided Keeper.
func NewMsgServerImpl(keeper Keeper)

types.MsgServer {
    return &msgServer{
    Keeper: keeper
}
}

func (k msgServer)

Send(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)
    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {
    return nil, err
}

from, err := sdk.AccAddressFromBech32(msg.FromAddress)
    if err != nil {
    return nil, err
}

to, err := sdk.AccAddressFromBech32(msg.ToAddress)
    if err != nil {
    return nil, err
}
    if k.BlockedAddr(to) {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.ToAddress)
}

err = k.SendCoins(ctx, from, to, msg.Amount)
    if err != nil {
    return nil, err
}

defer func() {
    for _, a := range msg.Amount {
    if a.Amount.IsInt64() {
    telemetry.SetGaugeWithLabels(
					[]string{"tx", "msg", "send"
},
					float32(a.Amount.Int64()),
					[]metrics.Label{
    telemetry.NewLabel("denom", a.Denom)
},
				)
}
	
}
	
}()

return &types.MsgSendResponse{
}, nil
}

func (k msgServer)

MultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)

	// NOTE: totalIn == totalOut should already have been checked
    for _, in := range msg.Inputs {
    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {
    return nil, err
}
	
}
    for _, out := range msg.Outputs {
    accAddr := sdk.MustAccAddressFromBech32(out.Address)
    if k.BlockedAddr(accAddr) {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", out.Address)
}
	
}
    err := k.InputOutputCoins(ctx, msg.Inputs, msg.Outputs)
    if err != nil {
    return nil, err
}

return &types.MsgMultiSendResponse{
}, nil
}

func (k msgServer)

UpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {
    if k.GetAuthority() != req.Authority {
    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), req.Authority)
}
    ctx := sdk.UnwrapSDKContext(goCtx)
    if err := k.SetParams(ctx, req.Params); err != nil {
    return nil, err
}

return &types.MsgUpdateParamsResponse{
}, nil
}

func (k msgServer)

SetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {
    if k.GetAuthority() != msg.Authority {
    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, "invalid authority; expected %s, got %s", k.GetAuthority(), msg.Authority)
}
    ctx := sdk.UnwrapSDKContext(goCtx)
    if len(msg.SendEnabled) > 0 {
    k.SetAllSendEnabled(ctx, msg.SendEnabled)
}
    if len(msg.UseDefaultFor) > 0 {
    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)
}

return &types.MsgSetSendEnabledResponse{
}, nil
}
```

`sdk.Msg` processing usually follows these 3 steps:

### Validation

The message server must perform all validation required (both *stateful* and *stateless*) to make sure the `message` is valid.
The `signer` is charged for the gas cost of this validation.

For example, a `msgServer` method for a `transfer` message should check that the sending account has enough funds to actually perform the transfer.

It is recommended to implement all validation checks in a separate function that passes state values as arguments. This implementation simplifies testing. As expected, expensive validation functions charge additional gas. Example:

```go
ValidateMsgA(msg MsgA, now Time, gm GasMeter)

error {
    if now.Before(msg.Expire) {
    return sdkerrrors.ErrInvalidRequest.Wrap("msg expired")
}

gm.ConsumeGas(1000, "signature verification")

return signatureVerificaton(msg.Prover, msg.Data)
}
```

<Warning>
Previously, the `ValidateBasic` method was used to perform simple and stateless validation checks.
This way of validating is deprecated, this means the `msgServer` must perform all validation checks.
</Warning>

### State Transition

After the validation is successful, the `msgServer` method uses the [`keeper`](keeper) functions to access the state and perform a state transition.

### Events

Before returning, `msgServer` methods generally emit one or more [events](/docs/sdk/v0.47//learn/advanced/events) by using the `EventManager` held in the `ctx`. Use the new `EmitTypedEvent` function that uses protobuf-based event types:

```go
ctx.EventManager().EmitTypedEvent(
	&group.EventABC{
    Key1: Value1,  Key2, Value2
})
```

or the older `EmitEvent` function:

```go
ctx.EventManager().EmitEvent(
	sdk.NewEvent(
		eventType,  // e.g. sdk.EventTypeMessage for a message, types.CustomEventType for a custom event defined in the module
		sdk.NewAttribute(key1, value1),
		sdk.NewAttribute(key2, value2),
	),
)
```

These events are relayed back to the underlying consensus engine and can be used by service providers to implement services around the application. Click [here](/docs/sdk/v0.47//learn/advanced/events) to learn more about events.

The invoked `msgServer` method returns a `proto.Message` response and an `error`. These return values are then wrapped into an `*sdk.Result` or an `error` using `sdk.WrapServiceResult(ctx sdk.Context, res proto.Message, err error)`:

```go expandable
package baseapp

import (
    
	"context"
    "fmt"

	gogogrpc "github.com/cosmos/gogoproto/grpc"
    "github.com/cosmos/gogoproto/proto"
    "google.golang.org/grpc"

	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
)

// MsgServiceRouter routes fully-qualified Msg service methods to their handler.
type MsgServiceRouter struct {
    interfaceRegistry codectypes.InterfaceRegistry
	routes            map[string]MsgServiceHandler
}

var _ gogogrpc.Server = &MsgServiceRouter{
}

// NewMsgServiceRouter creates a new MsgServiceRouter.
func NewMsgServiceRouter() *MsgServiceRouter {
    return &MsgServiceRouter{
    routes: map[string]MsgServiceHandler{
},
}
}

// MsgServiceHandler defines a function type which handles Msg service message.
type MsgServiceHandler = func(ctx sdk.Context, req sdk.Msg) (*sdk.Result, error)

// Handler returns the MsgServiceHandler for a given msg or nil if not found.
func (msr *MsgServiceRouter)

Handler(msg sdk.Msg)

MsgServiceHandler {
    return msr.routes[sdk.MsgTypeURL(msg)]
}

// HandlerByTypeURL returns the MsgServiceHandler for a given query route path or nil
// if not found.
func (msr *MsgServiceRouter)

HandlerByTypeURL(typeURL string)

MsgServiceHandler {
    return msr.routes[typeURL]
}

// RegisterService implements the gRPC Server.RegisterService method. sd is a gRPC
// service description, handler is an object which implements that gRPC service.
//
// This function PANICs:
//   - if it is called before the service `Msg`s have been registered using
//     RegisterInterfaces,
//   - or if a service is being registered twice.
func (msr *MsgServiceRouter)

RegisterService(sd *grpc.ServiceDesc, handler interface{
}) {
	// Adds a top-level query handler based on the gRPC service name.
    for _, method := range sd.Methods {
    fqMethod := fmt.Sprintf("/%s/%s", sd.ServiceName, method.MethodName)
    methodHandler := method.Handler

		var requestTypeName string

		// NOTE: This is how we pull the concrete request type for each handler for registering in the InterfaceRegistry.
		// This approach is maybe a bit hacky, but less hacky than reflecting on the handler object itself.
		// We use a no-op interceptor to avoid actually calling into the handler itself.
		_, _ = methodHandler(nil, context.Background(), func(i interface{
})

error {
    msg, ok := i.(sdk.Msg)
    if !ok {
				// We panic here because there is no other alternative and the app cannot be initialized correctly
				// this should only happen if there is a problem with code generation in which case the app won't
				// work correctly anyway.
				panic(fmt.Errorf("unable to register service method %s: %T does not implement sdk.Msg", fqMethod, i))
}

requestTypeName = sdk.MsgTypeURL(msg)

return nil
}, noopInterceptor)

		// Check that the service Msg fully-qualified method name has already
		// been registered (via RegisterInterfaces). If the user registers a
		// service without registering according service Msg type, there might be
		// some unexpected behavior down the road. Since we can't return an error
		// (`Server.RegisterService` interface restriction)

we panic (at startup).
		reqType, err := msr.interfaceRegistry.Resolve(requestTypeName)
    if err != nil || reqType == nil {
    panic(
				fmt.Errorf(
					"type_url %s has not been registered yet. "+
						"Before calling RegisterService, you must register all interfaces by calling the `RegisterInterfaces` "+
						"method on module.BasicManager. Each module should call `msgservice.RegisterMsgServiceDesc` inside its "+
						"`RegisterInterfaces` method with the `_Msg_serviceDesc` generated by proto-gen",
					requestTypeName,
				),
			)
}

		// Check that each service is only registered once. If a service is
		// registered more than once, then we should error. Since we can't
		// return an error (`Server.RegisterService` interface restriction)

we
		// panic (at startup).
		_, found := msr.routes[requestTypeName]
    if found {
    panic(
				fmt.Errorf(
					"msg service %s has already been registered. Please make sure to only register each service once. "+
						"This usually means that there are conflicting modules registering the same msg service",
					fqMethod,
				),
			)
}

msr.routes[requestTypeName] = func(ctx sdk.Context, req sdk.Msg) (*sdk.Result, error) {
    ctx = ctx.WithEventManager(sdk.NewEventManager())
    interceptor := func(goCtx context.Context, _ interface{
}, _ *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{
}, error) {
    goCtx = context.WithValue(goCtx, sdk.SdkContextKey, ctx)

return handler(goCtx, req)
}
    if err := req.ValidateBasic(); err != nil {
    return nil, err
}
			// Call the method handler from the service description with the handler object.
			// We don't do any decoding here because the decoding was already done.
			res, err := methodHandler(handler, sdk.WrapSDKContext(ctx), noopDecoder, interceptor)
    if err != nil {
    return nil, err
}

resMsg, ok := res.(proto.Message)
    if !ok {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidType, "Expecting proto.Message, got %T", resMsg)
}

return sdk.WrapServiceResult(ctx, resMsg, err)
}
	
}
}

// SetInterfaceRegistry sets the interface registry for the router.
func (msr *MsgServiceRouter)

SetInterfaceRegistry(interfaceRegistry codectypes.InterfaceRegistry) {
    msr.interfaceRegistry = interfaceRegistry
}

func noopDecoder(_ interface{
})

error {
    return nil
}

func noopInterceptor(_ context.Context, _ interface{
}, _ *grpc.UnaryServerInfo, _ grpc.UnaryHandler) (interface{
}, error) {
    return nil, nil
}
```

This method takes care of marshaling the `res` parameter to protobuf and attaching any events on the `ctx.EventManager()` to the `sdk.Result`.

```protobuf
// Reference: https://github.com/cosmos/cosmos-sdk/blob/v0.47.0-rc1/proto/cosmos/base/abci/v1beta1/abci.proto#L88-L109
```

This diagram shows a typical structure of a Protobuf `Msg` service, and how the message propagates through the module.

![Transaction flow](https://raw.githubusercontent.com/cosmos/cosmos-sdk/release/v0.46.x/docs/uml/svg/transaction_flow.svg)

## Telemetry

New [telemetry metrics](/docs/sdk/v0.47//learn/advanced/telemetry) can be created from `msgServer` methods when handling messages.

This is an example from the `x/auth/vesting` module:

```go expandable
package vesting

import (
    
	"context"
    "github.com/armon/go-metrics"
    "github.com/cosmos/cosmos-sdk/telemetry"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
    "github.com/cosmos/cosmos-sdk/x/auth/keeper"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
    "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
)

type msgServer struct {
    keeper.AccountKeeper
	types.BankKeeper
}

// NewMsgServerImpl returns an implementation of the vesting MsgServer interface,
// wrapping the corresponding AccountKeeper and BankKeeper.
func NewMsgServerImpl(k keeper.AccountKeeper, bk types.BankKeeper)

types.MsgServer {
    return &msgServer{
    AccountKeeper: k,
    BankKeeper: bk
}
}

var _ types.MsgServer = msgServer{
}

func (s msgServer)

CreateVestingAccount(goCtx context.Context, msg *types.MsgCreateVestingAccount) (*types.MsgCreateVestingAccountResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)
    ak := s.AccountKeeper
    bk := s.BankKeeper
    if err := bk.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {
    return nil, err
}

from, err := sdk.AccAddressFromBech32(msg.FromAddress)
    if err != nil {
    return nil, err
}

to, err := sdk.AccAddressFromBech32(msg.ToAddress)
    if err != nil {
    return nil, err
}
    if bk.BlockedAddr(to) {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.ToAddress)
}
    if acc := ak.GetAccount(ctx, to); acc != nil {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists", msg.ToAddress)
}
    baseAccount := authtypes.NewBaseAccountWithAddress(to)

baseAccount = ak.NewAccount(ctx, baseAccount).(*authtypes.BaseAccount)
    baseVestingAccount := types.NewBaseVestingAccount(baseAccount, msg.Amount.Sort(), msg.EndTime)

var vestingAccount authtypes.AccountI
    if msg.Delayed {
    vestingAccount = types.NewDelayedVestingAccountRaw(baseVestingAccount)
}

else {
    vestingAccount = types.NewContinuousVestingAccountRaw(baseVestingAccount, ctx.BlockTime().Unix())
}

ak.SetAccount(ctx, vestingAccount)

defer func() {
    telemetry.IncrCounter(1, "new", "account")
    for _, a := range msg.Amount {
    if a.Amount.IsInt64() {
    telemetry.SetGaugeWithLabels(
					[]string{"tx", "msg", "create_vesting_account"
},
					float32(a.Amount.Int64()),
					[]metrics.Label{
    telemetry.NewLabel("denom", a.Denom)
},
				)
}
	
}
	
}()

err = bk.SendCoins(ctx, from, to, msg.Amount)
    if err != nil {
    return nil, err
}

return &types.MsgCreateVestingAccountResponse{
}, nil
}

func (s msgServer)

CreatePermanentLockedAccount(goCtx context.Context, msg *types.MsgCreatePermanentLockedAccount) (*types.MsgCreatePermanentLockedAccountResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)
    ak := s.AccountKeeper
    bk := s.BankKeeper
    if err := bk.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {
    return nil, err
}

from, err := sdk.AccAddressFromBech32(msg.FromAddress)
    if err != nil {
    return nil, err
}

to, err := sdk.AccAddressFromBech32(msg.ToAddress)
    if err != nil {
    return nil, err
}
    if bk.BlockedAddr(to) {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, "%s is not allowed to receive funds", msg.ToAddress)
}
    if acc := ak.GetAccount(ctx, to); acc != nil {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists", msg.ToAddress)
}
    baseAccount := authtypes.NewBaseAccountWithAddress(to)

baseAccount = ak.NewAccount(ctx, baseAccount).(*authtypes.BaseAccount)
    vestingAccount := types.NewPermanentLockedAccount(baseAccount, msg.Amount)

ak.SetAccount(ctx, vestingAccount)

defer func() {
    telemetry.IncrCounter(1, "new", "account")
    for _, a := range msg.Amount {
    if a.Amount.IsInt64() {
    telemetry.SetGaugeWithLabels(
					[]string{"tx", "msg", "create_permanent_locked_account"
},
					float32(a.Amount.Int64()),
					[]metrics.Label{
    telemetry.NewLabel("denom", a.Denom)
},
				)
}
	
}
	
}()

err = bk.SendCoins(ctx, from, to, msg.Amount)
    if err != nil {
    return nil, err
}

return &types.MsgCreatePermanentLockedAccountResponse{
}, nil
}

func (s msgServer)

CreatePeriodicVestingAccount(goCtx context.Context, msg *types.MsgCreatePeriodicVestingAccount) (*types.MsgCreatePeriodicVestingAccountResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)
    ak := s.AccountKeeper
    bk := s.BankKeeper

	from, err := sdk.AccAddressFromBech32(msg.FromAddress)
    if err != nil {
    return nil, err
}

to, err := sdk.AccAddressFromBech32(msg.ToAddress)
    if err != nil {
    return nil, err
}
    if acc := ak.GetAccount(ctx, to); acc != nil {
    return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidRequest, "account %s already exists", msg.ToAddress)
}

var totalCoins sdk.Coins
    for _, period := range msg.VestingPeriods {
    totalCoins = totalCoins.Add(period.Amount...)
}
    baseAccount := authtypes.NewBaseAccountWithAddress(to)

baseAccount = ak.NewAccount(ctx, baseAccount).(*authtypes.BaseAccount)
    vestingAccount := types.NewPeriodicVestingAccount(baseAccount, totalCoins.Sort(), msg.StartTime, msg.VestingPeriods)

ak.SetAccount(ctx, vestingAccount)

defer func() {
    telemetry.IncrCounter(1, "new", "account")
    for _, a := range totalCoins {
    if a.Amount.IsInt64() {
    telemetry.SetGaugeWithLabels(
					[]string{"tx", "msg", "create_periodic_vesting_account"
},
					float32(a.Amount.Int64()),
					[]metrics.Label{
    telemetry.NewLabel("denom", a.Denom)
},
				)
}
	
}
	
}()

err = bk.SendCoins(ctx, from, to, totalCoins)
    if err != nil {
    return nil, err
}

return &types.MsgCreatePeriodicVestingAccountResponse{
}, nil
}
```
