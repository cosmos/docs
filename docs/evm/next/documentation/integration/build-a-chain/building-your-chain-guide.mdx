# Building Your Custom Chain with Cosmos EVM

This guide walks through creating your own blockchain by forking and customizing the Cosmos EVM project. We'll cover the entire process from initial fork to running network, including parameter configuration, genesis setup, and validator coordination.

## Understanding the Cosmos SDK Application Structure

<Info>
Cosmos EVM is built on the Cosmos SDK, a modular framework for building application-specific blockchains. Understanding this structure helps you customize your chain effectively.
</Info>

A Cosmos SDK application consists of several key components:

- **App Module**: The core application logic (`evmd/app.go`) that composes various modules
- **Modules**: Functional units handling specific blockchain features (staking, governance, EVM, etc.)
- **Keeper**: Each module's state management and business logic handler
- **Genesis**: Initial state and configuration for each module
- **CLI Commands**: User interface for interacting with the chain

The `evmd` directory contains the example chain implementation that you'll fork and customize for your own blockchain.

## Forking and Initial Setup

<Tabs>
  <Tab title="Fork Repository">
    Begin by forking the Cosmos EVM repository and cloning your fork:

    ```bash
    git clone https://github.com/YOUR-ORG/YOUR-CHAIN.git
    cd YOUR-CHAIN
    ```

    The repository structure provides everything needed to build a custom chain. The `evmd` directory contains the example implementation you'll modify.
  </Tab>

  <Tab title="Rename Application">
    Replace `evmd` references throughout the codebase with your chain's name:

    ```bash
    # Rename the directory
    mv evmd yourchain

    # Update imports and references
    find . -type f -name "*.go" -exec sed -i 's/evmd/yourchain/g' {} \;
    find . -type f -name "*.md" -exec sed -i 's/evmd/yourchain/g' {} \;
    ```

    Update module paths in `go.mod` to reflect your repository.
  </Tab>

  <Tab title="Customize Branding">
    Update application metadata in `yourchain/cmd/yourchain/cmd/root.go`:
    - Application name
    - Default home directory
    - CLI descriptions and help text
  </Tab>
</Tabs>

## Core Configuration Parameters

<Warning>
Some parameters must be set before genesis and cannot be changed later without significant migration effort. Choose carefully based on your requirements.
</Warning>

### Chain Identity Configuration

These fundamental parameters define your chain's identity and must be configured before initialization.

<AccordionGroup>
  <Accordion title="Bech32 Address Prefix" id="bech32-address-prefix">
    Configure in `config/config.go`:

    ```go
    const (
        // Bech32Prefix defines the Bech32 prefix for accounts
        Bech32Prefix = "yourchain"  // Change from "cosmos"

        // Bech32PrefixAccAddr defines the Bech32 prefix of an account's address
        Bech32PrefixAccAddr = Bech32Prefix
        // Bech32PrefixAccPub defines the Bech32 prefix of an account's public key
        Bech32PrefixAccPub = Bech32Prefix + sdk.PrefixPublic
        // Bech32PrefixValAddr defines the Bech32 prefix of a validator's operator address
        Bech32PrefixValAddr = Bech32Prefix + sdk.PrefixValidator + sdk.PrefixOperator
        // Bech32PrefixValPub defines the Bech32 prefix of a validator's operator public key
        Bech32PrefixValPub = Bech32Prefix + sdk.PrefixValidator + sdk.PrefixOperator + sdk.PrefixPublic
        // Bech32PrefixConsAddr defines the Bech32 prefix of a consensus node address
        Bech32PrefixConsAddr = Bech32Prefix + sdk.PrefixValidator + sdk.PrefixConsensus
        // Bech32PrefixConsPub defines the Bech32 prefix of a consensus node public key
        Bech32PrefixConsPub = Bech32Prefix + sdk.PrefixValidator + sdk.PrefixConsensus + sdk.PrefixPublic
    )
    ```

    This affects how addresses appear:
    - `cosmos1abc...` becomes `yourchain1abc...`
  </Accordion>

  <Accordion title="HD Wallet Configuration" id="hd-wallet-configuration">
    Set the BIP44 coin type for hardware wallet compatibility in `crypto/hd/hdpath.go`:

    ```go
    const (
        // Bip44CoinType satisfies EIP84 for Ethereum compatibility
        // Use 60 for Ethereum compatibility or register your own
        Bip44CoinType uint32 = 60
    )
    ```
  </Accordion>

  <Accordion title="Chain IDs" id="chain-ids">
    You'll work with two different chain IDs:

    **Cosmos Chain ID** (string): Set during initialization
    ```bash
    yourchain init mynode --chain-id yourchain-1
    ```

    **EVM Chain ID** (number): Set in genesis (see below)
    - Must be unique to avoid replay attacks
    - Register at [chainlist.org](https://chainlist.org) for public chains
  </Accordion>
</AccordionGroup>

### Token Economics Configuration

<Note>
The precisebank module is optional and only required for non-18 decimal tokens. If your native token uses 18 decimals (matching EVM standard), you can replace precisebank with the standard Cosmos SDK bank module for simpler architecture.
</Note>

<Accordion title="Replacing Precisebank with Standard Bank Module (18-decimal chains)" id="replacing-precisebank-with-standard-bank-module-18-decimal-chains">
For chains using 18-decimal tokens natively, replace precisebank with the standard bank module:

**In `yourchain/app.go`:**
```go
import (
    // Remove precisebank imports
    // "github.com/cosmos/evm/x/precisebank"
    // precisebankkeeper "github.com/cosmos/evm/x/precisebank/keeper"
    // precisebanktypes "github.com/cosmos/evm/x/precisebank/types"

    // Standard bank is already imported
    bankkeeper "github.com/cosmos/cosmos-sdk/x/bank/keeper"
    banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
)

// In app struct, remove PreciseBankKeeper
type EVMD struct {
    // ... other keepers
    BankKeeper    bankkeeper.Keeper  // Standard bank keeper
    // PreciseBankKeeper precisebankkeeper.Keeper // Remove this line
    EVMKeeper     *evmkeeper.Keeper
    // ... other keepers
}

// In NewApp function:
// 1. Remove precisebank store key
keys := storetypes.NewKVStoreKeys(
    // ... other keys
    evmtypes.StoreKey,
    feemarkettypes.StoreKey,
    erc20types.StoreKey,
    // precisebanktypes.StoreKey, // Remove this line
)

// 2. Skip PreciseBankKeeper initialization
// Remove these lines:
// app.PreciseBankKeeper = precisebankkeeper.NewKeeper(
//     appCodec,
//     keys[precisebanktypes.StoreKey],
//     app.BankKeeper,
//     app.AccountKeeper,
// )

// 3. Update EVMKeeper to use BankKeeper directly
app.EVMKeeper = evmkeeper.NewKeeper(
    appCodec,
    keys[evmtypes.StoreKey],
    tkeys[evmtypes.TransientKey],
    keys,
    authtypes.NewModuleAddress(govtypes.ModuleName),
    app.AccountKeeper,
    app.BankKeeper,  // Use BankKeeper instead of PreciseBankKeeper
    app.StakingKeeper,
    app.FeeMarketKeeper,
    &app.ConsensusParamsKeeper,
    &app.Erc20Keeper,
    evmChainID,
    tracer,
)

// 4. Remove precisebank from ModuleManager
app.ModuleManager = module.NewManager(
    // ... other modules
    vm.NewAppModule(app.EVMKeeper, app.AccountKeeper, app.BankKeeper, app.AccountKeeper.AddressCodec()),
    feemarket.NewAppModule(app.FeeMarketKeeper),
    erc20.NewAppModule(app.Erc20Keeper, app.AccountKeeper),
    // precisebank.NewAppModule(...) // Remove this line
)

// 5. Remove from genesis order
genesisModuleOrder := []string{
    // ... other modules
    evmtypes.ModuleName,
    feemarkettypes.ModuleName,
    erc20types.ModuleName,
    // precisebanktypes.ModuleName, // Remove this line
    // ... rest
}
```

**Benefits of removing precisebank for 18-decimal chains:**
- Simpler architecture with one less module
- Direct 1:1 mapping between native token and EVM representation
- Reduced complexity in balance conversions
- Standard Cosmos SDK bank operations

**When precisebank IS required (non-18 decimal tokens):**
- 6-decimal tokens: Tracks fractional amounts in EVM (1 utoken = 10^12 wei)
- 12-decimal tokens: Handles 10^6 wei conversions
- Any non-18: Prevents dust accumulation from precision differences
</Accordion>

Native token configuration is set in genesis through a combination of bank module metadata and VM parameters. The VM module reads this configuration during initialization and stores it as `EvmCoinInfo` in its state:

<CodeGroup>
```json 6-decimal-token.json
{
  "bank": {
    "denom_metadata": [
      {
        "description": "The native staking token for evmd.",
        "denom_units": [
          {
            "denom": "utest",     // Base denomination (6 decimals = micro prefix)
            "exponent": 0,
            "aliases": []
          },
          {
            "denom": "test",      // Display denomination
            "exponent": 6,        // 6 decimals from base
            "aliases": []
          }
        ],
        "base": "utest",          // Must match vm.params.evm_denom
        "display": "test",        // Human-readable name
        "name": "Test Token",
        "symbol": "TEST"
      }
    ]
  },
  "evm": {
    "params": {
      "evm_denom": "utest",     // References bank metadata base denom
      "extended_denom_options": {
        "extended_denom": "atest"  // Required: 18-decimal representation for EVM
      }
    }
  }
}
```

```json 18-decimal-token.json
{
  "bank": {
    "denom_metadata": [
      {
        "description": "The native staking token for evmd.",
        "denom_units": [
          {
            "denom": "atest",     // Base denomination (18 decimals = atto prefix)
            "exponent": 0,
            "aliases": ["attotest"]
          },
          {
            "denom": "test",      // Display denomination
            "exponent": 18,       // 18 decimals from base
            "aliases": []
          }
        ],
        "base": "atest",         // Base denom with 18 decimals
        "display": "test",       // Human-readable name
        "name": "Test Token",
        "symbol": "TEST"
      }
    ]
  },
  "evm": {
    "params": {
      "evm_denom": "atest"      // References bank metadata base denom
      // No extended_denom_options needed for 18-decimal chains
    }
  }
}
```

```bash genesis-setup-example.sh
# Real example from local_node.sh showing how to configure genesis
# This sets up an 18-decimal token using jq commands

# Set the base denom in all modules
jq '.app_state["staking"]["params"]["bond_denom"]="atest"' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"
jq '.app_state["gov"]["params"]["min_deposit"][0]["denom"]="atest"' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"
jq '.app_state["evm"]["params"]["evm_denom"]="atest"' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"
jq '.app_state["mint"]["params"]["mint_denom"]="atest"' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"

# Set bank metadata (18 decimals)
jq '.app_state["bank"]["denom_metadata"]=[{"description":"The native staking token for evmd.","denom_units":[{"denom":"atest","exponent":0,"aliases":["attotest"]},{"denom":"test","exponent":18,"aliases":[]}],"base":"atest","display":"test","name":"Test Token","symbol":"TEST","uri":"","uri_hash":""}]' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"

# Enable precompiles
jq '.app_state["evm"]["params"]["active_static_precompiles"]=["0x0000000000000000000000000000000000000100","0x0000000000000000000000000000000000000400","0x0000000000000000000000000000000000000800","0x0000000000000000000000000000000000000801","0x0000000000000000000000000000000000000802","0x0000000000000000000000000000000000000803","0x0000000000000000000000000000000000000804","0x0000000000000000000000000000000000000805", "0x0000000000000000000000000000000000000806", "0x0000000000000000000000000000000000000807"]' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"

# Set up ERC20 native token representation
jq '.app_state.erc20.native_precompiles=["0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"]' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"
jq '.app_state.erc20.token_pairs=[{contract_owner:1,erc20_address:"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE",denom:"atest",enabled:true}]' "$GENESIS" >"$TMP_GENESIS" && mv "$TMP_GENESIS" "$GENESIS"
```
</CodeGroup>

The VM module's `SetGlobalConfigVariables` function (called during PreBlock) reads this configuration and:
1. Fetches bank metadata for the specified `evm_denom`
2. Extracts decimal precision from the denom units
3. Creates `EvmCoinInfo` with appropriate extended denom:
   - For 18-decimal tokens: `extended_denom` = `evm_denom` (direct mapping)
   - For non-18 decimals: Uses `extended_denom_options.extended_denom` for EVM representation
4. Stores this configuration in VM keeper state via `SetEvmCoinInfo()`

<Tip>
**Decimal Precision Guidelines:**
- **18 decimals**: Direct EVM compatibility, replace precisebank with standard bank module
- **6 decimals**: Common in Cosmos, requires precisebank for fractional amounts
- **Other values**: Test conversion logic thoroughly with precisebank

**Module Selection Based on Decimals:**
- `decimals: 18` → Use standard `x/bank` module
- `decimals: 6` or other → Use `x/precisebank` wrapper around bank
</Tip>

## Genesis Configuration

The genesis file (`~/.yourchain/config/genesis.json`) contains all initial chain parameters and state. After initialization with `yourchain init`, customize these sections:

### VM Module Parameters

<Accordion title="Complete VM Configuration" id="vm-module-parameters">
<CodeGroup>
```json genesis.json
{
  "vm": {
    "params": {
      "evm_denom": "ustake",  // Must match bank metadata base denom
      "extra_eips": [],        // Additional EIPs to activate
      "active_static_precompiles": [
        "0x0000000000000000000000000000000000000800", // Staking
        "0x0000000000000000000000000000000000000801", // Distribution
        "0x0000000000000000000000000000000000000804"  // Bank
      ],
      "evm_channels": [],      // IBC channels connected to EVM chains
      "access_control": {
        "create": {
          "access_type": 0,     // 0=permissionless, 1=restricted, 2=permissioned
          "access_control_list": []
        },
        "call": {
          "access_type": 0,     // 0=permissionless, 1=restricted, 2=permissioned
          "access_control_list": []
        }
      },
      "history_serve_window": "8192",
      "extended_denom_options": {
        "extended_denom": "astake"  // Only for non-18 decimal chains
      }
    },
    "accounts": [],  // EVM genesis accounts (optional)
    "preinstalls": []  // Pre-deployed contracts (optional)
  }
}
```
</CodeGroup>

**Key Parameters:**
- `evm_denom`: Must match the base denomination in bank metadata
- `active_static_precompiles`: Enable only the precompiles you need
- `access_control`: Use numeric values (0=permissionless, 1=restricted, 2=permissioned)
- `extended_denom_options`: Required only for non-18 decimal chains

**Note**: The EVM chain ID and Ethereum fork configuration are currently set as global variables during initialization and cannot be directly configured in genesis. To customize these, modify the default values in `x/vm/types/chain_config.go` before building.
</Accordion>

### Available Precompiles

<AccordionGroup>
  <Accordion title="Core Precompiles" icon="cube">
    | Address | Module | Description |
    |---------|--------|-------------|
    | `0x0100` | P256 | P256 curve cryptographic operations |
    | `0x0400` | Bech32 | Convert between Bech32 and hex addresses |
  </Accordion>

  <Accordion title="Cosmos Module Precompiles" icon="coins">
    | Address | Module | Description |
    |---------|--------|-------------|
    | `0x0800` | Staking | Delegate, undelegate, redelegate |
    | `0x0801` | Distribution | Claim rewards, set withdrawal address |
    | `0x0802` | ICS20 | IBC token transfers |
    | `0x0803` | Vesting | Vesting account operations |
    | `0x0804` | Bank | Native token transfers |
    | `0x0805` | Gov | Submit and vote on proposals |
    | `0x0806` | Slashing | Query slashing info |
  </Accordion>
</AccordionGroup>

### Fee Market Configuration

<CodeGroup>
```json EIP-1559-enabled.json
{
  "feemarket": {
    "params": {
      "no_base_fee": false,
      "base_fee": "1000000000",
      "base_fee_change_denominator": 8,
      "elasticity_multiplier": 2,
      "enable_height": 0,
      "min_gas_price": "1000000000",
      "min_gas_multiplier": "0.5"
    }
  }
}
```

```json Simple-fee.json
{
  "feemarket": {
    "params": {
      "no_base_fee": true,  // Disable EIP-1559
      "min_gas_price": "1000000000"
    }
  }
}
```
</CodeGroup>

### Standard Cosmos Modules

<Tabs>
  <Tab title="Staking">
    ```json
    {
      "staking": {
        "params": {
          "unbonding_time": "1814400s",  // 21 days
          "max_validators": 100,
          "max_entries": 7,
          "bond_denom": "ustake"  // Must match your base denom
        }
      }
    }
    ```
  </Tab>

  <Tab title="Governance">
    ```json
    {
      "gov": {
        "params": {
          "min_deposit": [{
            "denom": "ustake",
            "amount": "10000000"
          }],
          "max_deposit_period": "172800s",
          "voting_period": "172800s"
        }
      }
    }
    ```
  </Tab>

  <Tab title="Distribution">
    ```json
    {
      "distribution": {
        "params": {
          "community_tax": "0.020000000000000000",
          "base_proposer_reward": "0.000000000000000000",
          "bonus_proposer_reward": "0.000000000000000000"
        }
      }
    }
    ```
  </Tab>

  <Tab title="Mint">
    ```json
    {
      "mint": {
        "minter": {
          "inflation": "0.130000000000000000",
          "annual_provisions": "0.000000000000000000"
        },
        "params": {
          "mint_denom": "ustake",
          "inflation_rate_change": "0.130000000000000000",
          "inflation_max": "0.200000000000000000",
          "inflation_min": "0.070000000000000000",
          "goal_bonded": "0.670000000000000000"
        }
      }
    }
    ```
  </Tab>
</Tabs>

### Initial Token Distribution

Add initial account balances in the `bank` section:

```json
{
  "bank": {
    "balances": [
      {
        "address": "yourchain1...",
        "coins": [
          {
            "denom": "ustake",
            "amount": "1000000000000"
          }
        ]
      }
    ]
  }
}
```

## Runtime Configuration (app.toml)

The `app.toml` file contains node-specific settings that can be changed without affecting consensus:

### JSON-RPC Configuration

<Accordion title="Complete JSON-RPC Settings">
```toml
###############################################################################
###                           JSON-RPC Configuration                      ###
###############################################################################

[json-rpc]
# Enable JSON-RPC server
enable = true

# Address to bind the HTTP server
address = "0.0.0.0:8545"

# Address to bind WebSocket server
ws-address = "0.0.0.0:8546"

# API namespaces to enable
# Available: web3, eth, personal, net, txpool, debug, miner
api = ["eth", "net", "web3", "txpool"]

# Gas cap for eth_call/estimateGas (0=default)
gas-cap = 25000000

# Timeout for eth_call
evm-timeout = "5s"

# Transaction fee cap (in ether)
txfee-cap = 1.0

# Maximum number of filters
filter-cap = 200

# Maximum blocks for fee history
feehistory-cap = 100

# Maximum logs per query
logs-cap = 10000

# Maximum block range for eth_getLogs
block-range-cap = 10000

# HTTP server timeouts
http-timeout = "30s"
http-idle-timeout = "120s"

# Allow non-EIP155 signed transactions
allow-unprotected-txs = false

# Batch request settings
batch-request-limit = 1000
batch-response-max-size = 25000000

# Connection limit (0 = unlimited)
max-open-connections = 0

# Enable custom indexer
enable-indexer = false

# Metrics server
metrics-address = "127.0.0.1:6065"

# WebSocket allowed origins
ws-origins = ["localhost", "127.0.0.1"]

# Dangerous: only for development
allow-insecure-unlock = false
enable-profiling = false
```
</Accordion>

### EVM Configuration

```toml
[evm]
# EVM tracer ("" | "json" | "struct" | "access_list" | "markdown")
tracer = ""

# Maximum gas wanted for a transaction
max-tx-gas-wanted = 0

# Track SHA3 preimages
cache-preimage = false

# Minimum priority fee (tip) in wei
min-tip = 1000000000

# Geth metrics server
geth-metrics-address = "127.0.0.1:8100"
```

## Creating the Genesis Validator Set

A production network requires multiple validators for decentralization and fault tolerance. The process involves collecting genesis transactions from each validator and combining them into the final genesis file.

### Validator Key Generation

Each validator must generate their operator keys:

<CodeGroup>
```bash validator-setup.sh
# Each validator runs these commands
yourchain init validator-1 --chain-id yourchain-1

# Create operator key
yourchain keys add validator --keyring-backend file

# Get validator consensus public key
yourchain tendermint show-validator

# Create genesis transaction
yourchain genesis gentx validator \
  1000000000000ustake \
  --chain-id yourchain-1 \
  --commission-rate 0.10 \
  --commission-max-rate 0.20 \
  --commission-max-change-rate 0.01 \
  --min-self-delegation 1 \
  --keyring-backend file \
  --gas-prices 0.025ustake
```

```bash coordinator-setup.sh
# Genesis coordinator runs
yourchain init genesis-node --chain-id yourchain-1

# Add accounts for all validators
yourchain genesis add-genesis-account validator1-address 1000000000000ustake
yourchain genesis add-genesis-account validator2-address 1000000000000ustake
# ... repeat for all validators
```
</CodeGroup>

### Collecting Genesis Transactions

<Warning>
The genesis coordinator must be trusted as they will create the final genesis file. Consider using a multi-signature setup or trusted third party for production networks.
</Warning>

<Tabs>
  <Tab title="Manual Collection">
    Validators send their genesis transactions to the coordinator:

    1. Each validator shares their `gentx-*.json` file from `~/.yourchain/config/gentx/`
    2. Coordinator places all files in their `~/.yourchain/config/gentx/` directory
    3. Coordinator runs:

    ```bash
    yourchain genesis collect-gentxs
    yourchain genesis validate-genesis
    ```
  </Tab>

  <Tab title="GitHub Coordination">
    Use a repository for transparent coordination:

    1. Create a genesis repository
    2. Validators submit PRs with their gentx files
    3. Verify validator identities before merging
    4. Generate final genesis from collected transactions
  </Tab>

  <Tab title="Automated Tools">
    For larger networks, use automation:

    ```bash
    # Example script for collecting via HTTP
    for validator in "${VALIDATORS[@]}"; do
      curl -O "https://${validator}/gentx.json"
      mv gentx.json ~/.yourchain/config/gentx/gentx-${validator}.json
    done

    yourchain genesis collect-gentxs
    ```
  </Tab>
</Tabs>

### Distributing the Final Genesis

Once the genesis file is complete with all validator transactions:

1. **Calculate genesis hash** for verification:
   ```bash
   sha256sum ~/.yourchain/config/genesis.json
   ```

2. **Distribute to all validators** who replace their local genesis:
   ```bash
   # Each validator downloads and verifies
   curl -O https://genesis.yourchain.com/genesis.json
   sha256sum genesis.json  # Verify hash matches
   mv genesis.json ~/.yourchain/config/
   ```

3. **Share peer information** for network discovery:
   ```bash
   # Get node ID and IP
   yourchain tendermint show-node-id
   # Share: nodeID@IP:26656
   ```

## Starting the Network

### Coordinated Network Launch

<AccordionGroup>
  <Accordion title="Configure Persistent Peers" id="configure-persistent-peers">
    Each validator adds peers to `config.toml`:

    ```toml
    # Persistent peers
    persistent_peers = "nodeID1@IP1:26656,nodeID2@IP2:26656,..."

    # Recommended settings for new networks
    addr_book_strict = false
    max_num_inbound_peers = 100
    max_num_outbound_peers = 100
    ```
  </Accordion>

  <Accordion title="Launch Coordination" id="launch-coordination">
    Coordinate the genesis time (usually set in genesis.json):

    ```json
    {
      "genesis_time": "2024-01-15T15:00:00Z"
    }
    ```

    All genesis validators must start their nodes before this time:

    ```bash
    # For validators (no RPC exposed)
    yourchain start \
      --minimum-gas-prices 0.025ustake \
      --log_level info

    # For RPC nodes (separate from validators)
    yourchain start \
      --minimum-gas-prices 0.025ustake \
      --json-rpc.enable \
      --json-rpc.api eth,net,web3,txpool \
      --evm.tracer "" \
      --log_level info
    ```
  </Accordion>
</AccordionGroup>

### Monitoring Network Health

After launch, monitor these critical metrics:

<Tabs>
  <Tab title="Block Production">
    ```bash
    # Check latest block
    yourchain status | jq .sync_info

    # Monitor block time
    yourchain query block | jq .block.header.time
    ```
  </Tab>

  <Tab title="Validator Set">
    ```bash
    # Check active validators
    yourchain query staking validators --output json | jq '.validators[] | {moniker: .description.moniker, status: .status}'

    # Check voting power distribution
    yourchain query tendermint-validator-set
    ```
  </Tab>

  <Tab title="Network Peers">
    ```bash
    # Check connected peers
    yourchain status | jq .node_info.network

    # Monitor peer count
    curl http://localhost:26657/net_info | jq '.result.n_peers'
    ```
  </Tab>
</Tabs>

## Post-Launch Operations

### Governance Parameter Updates

Most parameters can be modified through governance after launch:

<CodeGroup>
```json param-change-proposal.json
{
  "title": "Update EVM Parameters",
  "description": "Enable additional precompiles",
  "changes": [
    {
      "subspace": "vm",
      "key": "ActiveStaticPrecompiles",
      "value": ["0x0000000000000000000000000000000000000800", "0x0000000000000000000000000000000000000805"]
    }
  ],
  "deposit": "10000000ustake"
}
```

```bash submit-proposal.sh
yourchain tx gov submit-proposal param-change proposal.json \
  --from validator \
  --chain-id yourchain-1 \
  --keyring-backend file
```
</CodeGroup>

### Software Upgrades

For breaking changes requiring new binary versions:

<Accordion title="Upgrade Process">
**1. Implement upgrade handler** in `yourchain/upgrades.go`:
```go
const UpgradeName = "v1.0.0-to-v2.0.0"

func (app EVMD) RegisterUpgradeHandlers() {
    app.UpgradeKeeper.SetUpgradeHandler(
        UpgradeName,
        func(ctx context.Context, _ upgradetypes.Plan, fromVM module.VersionMap) (module.VersionMap, error) {
            sdkCtx := sdk.UnwrapSDKContext(ctx)

            // Perform any state migrations here
            // For example, setting bank metadata for token configuration:
            app.BankKeeper.SetDenomMetaData(ctx, banktypes.Metadata{
                DenomUnits: []*banktypes.DenomUnit{
                    {Denom: "ustake", Exponent: 0},
                    {Denom: "stake", Exponent: 6},
                },
                Base: "ustake",
                Display: "stake",
            })

            // For non-18 decimal chains, set extended denom
            if decimals != 18 {
                evmParams := app.EVMKeeper.GetParams(sdkCtx)
                evmParams.ExtendedDenomOptions = &types.ExtendedDenomOptions{
                    ExtendedDenom: "astake",
                }
                app.EVMKeeper.SetParams(sdkCtx, evmParams)
            }

            return app.ModuleManager.RunMigrations(ctx, app.Configurator(), fromVM)
        },
    )
}
```

**2. Propose upgrade** via governance:
```bash
yourchain tx gov submit-proposal software-upgrade v1.0.0-to-v2.0.0 \
    --title "Upgrade to v2.0.0" \
    --description "Upgrade with new features" \
    --upgrade-height 1000000 \
    --from validator \
    --chain-id yourchain-1
```

**3. Validators prepare** by installing new binary before upgrade height

**4. Automatic upgrade** at specified height using Cosmovisor or manual restart
</Accordion>

## Advanced Customization

### Module Architecture Decisions

<Accordion title="Bank vs Precisebank Module Architecture">
The choice between standard bank and precisebank affects your entire token architecture:

**Standard Bank Module (18-decimal chains):**
```go
// Module initialization order in app.go
genesisModuleOrder := []string{
    authtypes.ModuleName,
    banktypes.ModuleName,
    distrtypes.ModuleName,
    stakingtypes.ModuleName,
    slashingtypes.ModuleName,
    govtypes.ModuleName,
    minttypes.ModuleName,
    ibcexported.ModuleName,
    evmtypes.ModuleName,
    feemarkettypes.ModuleName,
    erc20types.ModuleName,
    // precisebanktypes.ModuleName removed for 18-decimal chains
    ibctransfertypes.ModuleName,
    genutiltypes.ModuleName,
    evidencetypes.ModuleName,
    authz.ModuleName,
    feegrant.ModuleName,
    upgradetypes.ModuleName,
    vestingtypes.ModuleName,
}

// EVM keeper initialization (using standard bank)
app.EVMKeeper = evmkeeper.NewKeeper(
    appCodec,
    keys[evmtypes.StoreKey],
    tkeys[evmtypes.TransientKey],
    keys,
    authtypes.NewModuleAddress(govtypes.ModuleName),
    app.AccountKeeper,
    app.BankKeeper,  // Use standard bank keeper directly
    app.StakingKeeper,
    app.FeeMarketKeeper,
    &app.ConsensusParamsKeeper,
    &app.Erc20Keeper,
    evmChainID,
    tracer,
)
```

**Precisebank Module (non-18 decimal chains):**
```go
// Module initialization order (current evmd implementation)
genesisModuleOrder := []string{
    authtypes.ModuleName,
    banktypes.ModuleName,
    distrtypes.ModuleName,
    stakingtypes.ModuleName,
    slashingtypes.ModuleName,
    govtypes.ModuleName,
    minttypes.ModuleName,
    ibcexported.ModuleName,
    evmtypes.ModuleName,
    feemarkettypes.ModuleName,
    erc20types.ModuleName,
    precisebanktypes.ModuleName,  // Included for non-18 decimal chains
    ibctransfertypes.ModuleName,
    // ... rest of modules
}

// Precisebank wraps standard bank
app.PreciseBankKeeper = precisebankkeeper.NewKeeper(
    appCodec,
    keys[precisebanktypes.StoreKey],
    app.BankKeeper,  // Wraps standard bank keeper
    app.AccountKeeper,
)

// EVM keeper uses precisebank
app.EVMKeeper = evmkeeper.NewKeeper(
    appCodec,
    keys[evmtypes.StoreKey],
    tkeys[evmtypes.TransientKey],
    keys,
    authtypes.NewModuleAddress(govtypes.ModuleName),
    app.AccountKeeper,
    app.PreciseBankKeeper,  // Precisebank wrapper instead of bank directly
    app.StakingKeeper,
    app.FeeMarketKeeper,
    &app.ConsensusParamsKeeper,
    &app.Erc20Keeper,
    evmChainID,
    tracer,
)
```

**Key Differences:**
- **18-decimal**: EVM interacts directly with bank module
- **Non-18 decimal**: EVM interacts through precisebank wrapper
- **Genesis order**: Precisebank must initialize after bank but before modules that use it
- **Keeper dependencies**: VM keeper takes different keeper type based on decimal configuration
</Accordion>

### Custom Precompiles

<Note>
Teams can implement custom precompiled contracts for chain-specific functionality.
</Note>

Create custom precompiles by:

1. Implementing the precompile interface
2. Registering in the VM keeper
3. Adding to available precompiles list
4. Enabling in genesis configuration

### Access Control Configurations

<Tabs>
  <Tab title="Permissionless">
    Default - anyone can deploy and call contracts:
    ```json
    {
      "access_control": {
        "create": {
          "access_type": 0,  // ACCESS_TYPE_PERMISSIONLESS
          "access_control_list": []
        },
        "call": {
          "access_type": 0,  // ACCESS_TYPE_PERMISSIONLESS
          "access_control_list": []
        }
      }
    }
    ```
  </Tab>

  <Tab title="Permissioned">
    Only allowlisted addresses can deploy/call:
    ```json
    {
      "access_control": {
        "create": {
          "access_type": 2,  // ACCESS_TYPE_PERMISSIONED
          "access_control_list": ["0xallowed1", "0xallowed2"]
        },
        "call": {
          "access_type": 0,  // Keep calls permissionless
          "access_control_list": []
        }
      }
    }
    ```
  </Tab>

  <Tab title="Restricted">
    Block all contract deployment:
    ```json
    {
      "access_control": {
        "create": {
          "access_type": 1,  // ACCESS_TYPE_RESTRICTED - blocks all
          "access_control_list": []  // Ignored for restricted type
        },
        "call": {
          "access_type": 0,  // Keep calls permissionless
          "access_control_list": []
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Best Practices and Recommendations

<AccordionGroup>
  <Accordion title="Security Considerations" icon="shield">
    - Enable only necessary precompiles to minimize attack surface
    - Use hardware security modules (HSM) for validator keys
    - Implement proper key management procedures
    - Regular security audits for custom modifications
    - Monitor for unusual activity or governance proposals
  </Accordion>

  <Accordion title="Performance Optimization" icon="gauge">
    - Adjust block size and gas limits based on network capacity
    - Configure appropriate peer connections
    - Use SSDs for validator nodes
    - Monitor and adjust mempool settings
    - Consider pruning strategies for long-term sustainability
  </Accordion>

  <Accordion title="Network Stability" icon="heart-pulse">
    - Start with conservative parameters
    - Gradually increase limits through governance
    - Maintain validator diversity (geography, infrastructure)
    - Implement monitoring and alerting
    - Plan for emergency response procedures
  </Accordion>
</AccordionGroup>

## Conclusion

Building a custom chain with Cosmos EVM provides the flexibility to create an application-specific blockchain with full EVM compatibility. The modular architecture allows you to enable only the features you need while maintaining the security and decentralization of the Cosmos ecosystem.

Remember to thoroughly test your configuration in a testnet environment before launching your mainnet, and consider engaging with the Cosmos EVM community for support and best practices.