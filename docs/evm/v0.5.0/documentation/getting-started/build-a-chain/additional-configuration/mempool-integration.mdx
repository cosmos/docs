---
title: "EVM Mempool Integration"
description: "Integrate the EVM mempool with your Cosmos EVM chain"
---

<Warning>
This mempool implementation is **experimental** and under active development. It is intended for testing and evaluation purposes. Use in production environments is **not recommended** without thorough testing and risk assessment.

Please report issues and submit feedback to help improve stability.
</Warning>

## Overview

This guide provides step-by-step instructions for integrating the EVM mempool into your Cosmos EVM chain.

The EVM mempool is responsible for managing both EVM and Cosmos transactions in a unified pool, enabling Ethereum-compatible transaction flows including out-of-order transactions and nonce gap handling. It serves as a replacement for the default CometBFT FIFO mempool to support Ethereum tooling expectations while maintaining Cosmos SDK compatibility.

The mempool implements a two-tier architecture: a local transaction pool for queuing nonce-gapped transactions and CometBFT broadcasting for executable transactions, preventing network spam while enabling proper EVM transaction semantics.

<Note>
For conceptual information about mempool design and architecture, see the [Mempool Concepts](/docs/evm/v0.5.0/documentation/concepts/mempool) page.
</Note>

## Integration

### Quick Start

To integrate the EVM mempool in your Cosmos application, follow these steps:

#### 1. Add EVM Mempool to App Struct

```go expandable
type App struct {
    *baseapp.BaseApp
    // ... other keepers

    // Cosmos EVM keepers
    FeeMarketKeeper   feemarketkeeper.Keeper
    EVMKeeper         *evmkeeper.Keeper
    EVMMempool        *evmmempool.ExperimentalEVMMempool
}
```

#### 2. Configure Mempool in NewApp Constructor

<Note>
The mempool must be initialized **after** the antehandler has been set in the app.
</Note>

The reference implementation from `evmd` shows the recommended setup pattern:

```go expandable
// Configure EVM mempool (evmd reference implementation)
func (app *App) configureEVMMempool(appOpts servertypes.AppOptions, logger log.Logger) error {
    if evmtypes.GetChainConfig() == nil {
        logger.Debug("evm chain config is not set, skipping mempool configuration")
        return nil
    }

    cosmosPoolMaxTx := evmconfig.GetCosmosPoolMaxTx(appOpts, logger)
    if cosmosPoolMaxTx < 0 {
        logger.Debug("app-side mempool is disabled, skipping evm mempool configuration")
        return nil
    }

    mempoolConfig := &evmmempool.EVMMempoolConfig{
        AnteHandler:      app.GetAnteHandler(),
        LegacyPoolConfig: evmconfig.GetLegacyPoolConfig(appOpts, logger),
        BlockGasLimit:    evmconfig.GetBlockGasLimit(appOpts, logger),
        MinTip:           evmconfig.GetMinTip(appOpts, logger),
    }

    evmMempool := evmmempool.NewExperimentalEVMMempool(
        app.CreateQueryContext,
        logger,
        app.EVMKeeper,
        app.FeeMarketKeeper,
        app.txConfig,
        app.clientCtx,
        mempoolConfig,
        cosmosPoolMaxTx,
    )
    app.EVMMempool = evmMempool

    // Replace BaseApp mempool
    app.SetMempool(evmMempool)

    // Set custom CheckTx handler for nonce gap support
    checkTxHandler := evmmempool.NewCheckTxHandler(evmMempool)
    app.SetCheckTxHandler(checkTxHandler)

    // Set custom PrepareProposal handler
    abciProposalHandler := baseapp.NewDefaultProposalHandler(evmMempool, app)
    abciProposalHandler.SetSignerExtractionAdapter(
        evmmempool.NewEthSignerExtractionAdapter(
            sdkmempool.NewDefaultSignerExtractionAdapter(),
        ),
    )
    app.SetPrepareProposal(abciProposalHandler.PrepareProposalHandler())

    return nil
}
```

#### 3. Add Cleanup Handler

```go expandable
// Close unsubscribes from the CometBFT event bus (if set) and closes the underlying BaseApp.
func (app *App) Close() error {
    var err error
    if m, ok := app.GetMempool().(*evmmempool.ExperimentalEVMMempool); ok {
        err = m.Close()
    }
    err = errors.Join(err, app.BaseApp.Close())
    msg := "Application gracefully shutdown"
    if err == nil {
        app.Logger().Info(msg)
    } else {
        app.Logger().Error(msg, "error", err)
    }
    return err
}
```

### Configuration Options

The `EVMMempoolConfig` struct provides several configuration options:

```go expandable
type EVMMempoolConfig struct {
    // Required: AnteHandler for transaction validation
    AnteHandler   sdk.AnteHandler

    // Required: Block gas limit for transaction selection
    BlockGasLimit uint64

    // Optional: Custom legacy pool configuration
    LegacyPoolConfig *legacypool.Config

    // Optional: Custom Cosmos pool configuration
    CosmosPoolConfig *sdkmempool.PriorityNonceMempoolConfig[math.Int]

    // Optional: Custom broadcast function for promoted transactions
    BroadCastTxFn func(txs []*ethtypes.Transaction) error

    // Optional: Minimum tip required for EVM transactions
    MinTip *uint256.Int
}
```

**Configuration Helpers**:

The `evmconfig` package provides helpers to read configuration from `app.toml` and genesis:

- `GetLegacyPoolConfig(appOpts, logger)` - Reads EVM mempool settings from app.toml, falls back to `legacypool.DefaultConfig`
- `GetBlockGasLimit(appOpts, logger)` - Extracts block gas limit from genesis consensus params
- `GetMinTip(appOpts, logger)` - Reads minimum priority fee from app.toml
- `GetCosmosPoolMaxTx(appOpts, logger)` - Reads mempool.max-txs from app.toml

**Minimal Configuration**:

```go expandable
mempoolConfig := &evmmempool.EVMMempoolConfig{
    AnteHandler:   app.GetAnteHandler(),
    BlockGasLimit: 100_000_000, // or use evmconfig.GetBlockGasLimit
}

evmMempool := evmmempool.NewExperimentalEVMMempool(
    app.CreateQueryContext,
    logger,
    app.EVMKeeper,
    app.FeeMarketKeeper,
    app.txConfig,
    app.clientCtx,
    mempoolConfig,
    5000, // cosmosPoolMaxTx
)
```

### Custom Configuration

#### Custom Legacy Pool Configuration

Customize EVM transaction pool parameters via app.toml or programmatically:

**Via app.toml**:
```toml expandable
[evm.mempool]
# Minimum gas price (wei)
price-limit = 1

# Minimum price bump percentage to replace transaction
price-bump = 10

# Maximum executable transactions per account
account-slots = 16

# Maximum total executable transactions
global-slots = 5120

# Maximum queued (non-executable) transactions per account
account-queue = 64

# Maximum total queued transactions
global-queue = 1024

# Maximum time transactions can stay in mempool
lifetime = "3h"
```

**Programmatically**:
```go expandable
// Override specific values
legacyCfg := legacypool.DefaultConfig
legacyCfg.PriceLimit = 2              // Minimum gas price (wei)
legacyCfg.PriceBump = 15              // 15% price bump to replace
legacyCfg.AccountSlots = 32           // Slots per account
legacyCfg.GlobalSlots = 10240         // Total executable slots
legacyCfg.AccountQueue = 128          // Non-executable per account
legacyCfg.GlobalQueue = 2048          // Total non-executable
legacyCfg.Lifetime = 6 * time.Hour    // Max queue time

mempoolConfig.LegacyPoolConfig = &legacyCfg
```

#### Custom Cosmos Mempool Configuration

The mempool uses a default `PriorityNonceMempool` for Cosmos transactions. You can customize the priority calculation:

```go expandable
// Define custom priority calculation for Cosmos transactions
cosmosCfg := sdkmempool.PriorityNonceMempoolConfig[math.Int]{}
cosmosCfg.TxPriority = sdkmempool.TxPriority[math.Int]{
    GetTxPriority: func(goCtx context.Context, tx sdk.Tx) math.Int {
        feeTx, ok := tx.(sdk.FeeTx)
        if !ok {
            return math.ZeroInt()
        }

        // Get fee in bond denomination
        bondDenom := "stake" // your chain's bond denom
        fee := feeTx.GetFee()
        found, coin := fee.Find(bondDenom)
        if !found {
            return math.ZeroInt()
        }

        // Calculate gas price: fee_amount / gas_limit
        gasPrice := coin.Amount.Quo(math.NewIntFromUint64(feeTx.GetGas()))
        return gasPrice
    },
    Compare: func(a, b math.Int) int {
        return a.BigInt().Cmp(b.BigInt()) // Higher values have priority
    },
    MinValue: math.ZeroInt(),
}

mempoolConfig.CosmosPoolConfig = &cosmosCfg
```

<Note>
The evmd reference implementation does **not** set `CosmosPoolConfig` - it uses the default priority function which calculates gas price based on the EVM denom from `vmKeeper.GetEvmCoinInfo(ctx).Denom`.
</Note>

#### Custom Block Gas Limit

Different chains may require different gas limits:

```go expandable
// Example: 50M gas limit for lower capacity chains
mempoolConfig := &evmmempool.EVMMempoolConfig{
    AnteHandler:   app.GetAnteHandler(),
    BlockGasLimit: 50_000_000,
}
```

#### Custom Minimum Tip

Set a minimum priority fee requirement:

```go expandable
// Via app.toml
[evm.mempool]
min-tip = 1000000000  # 1 gwei in wei

// Or programmatically
mempoolConfig.MinTip = uint256.NewInt(1000000000) // 1 gwei
```

#### Custom Broadcast Function

Override the default broadcast behavior for promoted EVM transactions:

```go expandable
// Custom EVM broadcast (optional)
mempoolConfig.BroadCastTxFn = func(txs []*ethtypes.Transaction) error {
    // Custom logic for broadcasting promoted transactions
    return nil
}
```

### Prerequisites

1. **EVM Module Integration**: EVM keeper and module initialized before mempool
2. **FeeMarket Module**: Required for base fee calculations
3. **Compatible AnteHandler**: Must support EVM transaction validation

### Event Bus Integration

For best results, connect the mempool to CometBFT's EventBus so it can react to finalized blocks:

```go expandable
// After starting the CometBFT node
if m, ok := app.GetMempool().(*evmmempool.ExperimentalEVMMempool); ok {
    m.SetEventBus(bftNode.EventBus())
}
```
This enables chain-head notifications so the mempool can promptly promote/evict transactions when blocks are committed.

## v0.4.x to v0.5.0 Migration

**Breaking Change:** Pre-built pools replaced with configuration objects

PR [#496](https://github.com/cosmos/evm/pull/496) replaced pre-built pools with configs in `EVMMempoolConfig`:

- **Removed:** `TxPool *txpool.TxPool`, `CosmosPool sdkmempool.ExtMempool`
- **Added:** `LegacyPoolConfig *legacypool.Config`, `CosmosPoolConfig *sdkmempool.PriorityNonceMempoolConfig[math.Int]`
- **Added:** `cosmosPoolMaxTx int` parameter to `NewExperimentalEVMMempool`

### Minimal Setups: Update Function Signature

If you use the default mempool wiring, update the function call to include `cosmosPoolMaxTx`:

**Before (v0.4.x):**
```go expandable
evmMempool := evmmempool.NewExperimentalEVMMempool(
    app.CreateQueryContext, logger, app.EVMKeeper, app.FeeMarketKeeper,
    app.txConfig, app.clientCtx, mempoolConfig
)
```

**After (v0.5.0):**
```go expandable
cosmosPoolMaxTx := 5000 // or read from app.toml
evmMempool := evmmempool.NewExperimentalEVMMempool(
    app.CreateQueryContext, logger, app.EVMKeeper, app.FeeMarketKeeper,
    app.txConfig, app.clientCtx, mempoolConfig,
    cosmosPoolMaxTx, // ← NEW required parameter
)
```

### Advanced Setups: Migrate Your Customizations

If you built custom pools yourself, replace them with configuration objects:

**Before (v0.4.x):**
```go expandable
mempoolConfig := &evmmempool.EVMMempoolConfig{
    TxPool:     customTxPool,      // ← REMOVED
    CosmosPool: customCosmosPool,  // ← REMOVED
    AnteHandler:   app.GetAnteHandler(),
    BlockGasLimit: 100_000_000,
}
```

**After (v0.5.0):**
```go expandable
mempoolConfig := &evmmempool.EVMMempoolConfig{
    LegacyPoolConfig: &legacyCfg,  // ← NEW (or nil for defaults)
    CosmosPoolConfig: &cosmosCfg,  // ← NEW (or nil for defaults)
    AnteHandler:      app.GetAnteHandler(),
    BlockGasLimit:    100_000_000,
}
```

## Monitoring and Debugging

The mempool extends RPC functionality through the `/txpool` namespace compatible with go-ethereum:

### txpool_status

Returns pool statistics (pending/queued transaction counts).

```shell expandable
curl -X POST -H "Content-Type: application/json" \
  --data '{"method":"txpool_status","params":[],"id":1,"jsonrpc":"2.0"}' \
  http://localhost:8545
```

Example Output:

```json expandable
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "pending": 42,
    "queued": 7
  }
}
```

### txpool_content

Returns full transaction content grouped by account and state.

```shell expandable
curl -X POST -H "Content-Type: application/json" \
  --data '{"method":"txpool_content","params":[],"id":1,"jsonrpc":"2.0"}' \
  http://localhost:8545
```

### txpool_contentFrom

Returns transactions from a specific address.

```shell expandable
curl -X POST -H "Content-Type: application/json" \
  --data '{"method":"txpool_contentFrom","params":["0x1234..."],"id":1,"jsonrpc":"2.0"}' \
  http://localhost:8545
```

### txpool_inspect

Returns transaction summaries without full transaction data.

```shell expandable
curl -X POST -H "Content-Type: application/json" \
  --data '{"method":"txpool_inspect","params":[],"id":1,"jsonrpc":"2.0"}' \
  http://localhost:8545
```

## Related Documentation

- [Mempool Concepts](/docs/evm/v0.5.0/documentation/concepts/mempool) - Understanding mempool behavior and design
- [Using the Local Node](/docs/evm/v0.5.0/documentation/getting-started/build-a-chain/using-local-node#evm-mempool-integration) - Quick setup example
- [JSON-RPC Methods](/docs/evm/v0.5.0/api-reference/ethereum-json-rpc/methods#txpool-methods) - Complete API reference
