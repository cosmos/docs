---
title: "Governance"
description: "On-chain governance participation through proposal submission, voting, and governance query operations"
icon: "scale"
keywords: ['governance', 'voting', 'proposals', 'precompile', 'cosmos sdk', 'on-chain governance', 'deposit', 'vote', 'submit proposal', 'cancel proposal', 'tally', 'dao', 'decentralized governance']
---

## Overview

The Governance precompile provides comprehensive access to the Cosmos SDK's `x/gov` module, enabling smart contracts to participate in on-chain governance. It allows for submitting and canceling proposals, depositing funds, and casting votes. Additionally, it offers extensive query capabilities to retrieve information about proposals, votes, deposits, and overall governance parameters.

**Precompile Address**: `0x0000000000000000000000000000000000000805`
**Related Module**: [x/gov](https://docs.cosmos.network/main/modules/gov)

## Gas Costs

<Info>
Gas costs are approximated and may vary based on proposal complexity and chain settings.
</Info>

| Method | Gas Cost |
|---|---|
| **Transactions** | `2000 + (30 × bytes of input)` |
| **Queries** | `1000 + (3 × bytes of input)` |

## Transaction Methods

### `submitProposal`
Submits a new governance proposal.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceExample {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct Coin {
        string denom;
        uint256 amount;
    }
    
    event ProposalSubmitted(address indexed proposer, uint64 indexed proposalId);
    
    function submitProposal(bytes calldata jsonProposal, Coin[] calldata initialDeposit) 
        external 
        payable 
        returns (uint64 proposalId) 
    {
        require(jsonProposal.length > 0, "Proposal cannot be empty");
        require(initialDeposit.length > 0, "Initial deposit required");
        
        // Call the governance precompile
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.call(
            abi.encodeWithSignature(
                "submitProposal(address,bytes,tuple(string,uint256)[])",
                msg.sender,
                jsonProposal,
                initialDeposit
            )
        );
        
        require(success, "Proposal submission failed");
        proposalId = abi.decode(result, (uint64));
        
        emit ProposalSubmitted(msg.sender, proposalId);
        return proposalId;
    }
    
    // Helper function to create a coin struct
    function createCoin(string memory denom, uint256 amount) external pure returns (Coin memory) {
        return Coin({denom: denom, amount: amount});
    }
}
```
</CodeGroup>

### `vote`
Casts a single vote on an active proposal.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceExample {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    enum VoteOption {
        Unspecified,
        Yes,
        Abstain,
        No,
        NoWithVeto
    }
    
    event VoteCast(address indexed voter, uint64 indexed proposalId, VoteOption option);
    
    function vote(uint64 proposalId, VoteOption option, string calldata metadata) external {
        require(proposalId > 0, "Invalid proposal ID");
        require(option != VoteOption.Unspecified, "Must specify a vote option");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.call(
            abi.encodeWithSignature(
                "vote(address,uint64,uint8,string)",
                msg.sender,
                proposalId,
                uint8(option),
                metadata
            )
        );
        
        require(success, "Vote failed");
        bool voteSuccess = abi.decode(result, (bool));
        require(voteSuccess, "Vote was rejected");
        
        emit VoteCast(msg.sender, proposalId, option);
    }
    
    // Convenience function to vote yes
    function voteYes(uint64 proposalId) external {
        this.vote(proposalId, VoteOption.Yes, "");
    }
    
    // Convenience function to vote no
    function voteNo(uint64 proposalId) external {
        this.vote(proposalId, VoteOption.No, "");
    }
}
```
</CodeGroup>

### `voteWeighted`
Casts a weighted vote, splitting voting power across multiple options.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceWeightedVote {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    enum VoteOption {
        Unspecified,
        Yes,
        Abstain,
        No,
        NoWithVeto
    }
    
    struct WeightedVoteOption {
        VoteOption option;
        string weight;
    }
    
    event WeightedVoteCast(
        address indexed voter, 
        uint64 indexed proposalId, 
        WeightedVoteOption[] options
    );
    
    function voteWeighted(
        uint64 proposalId, 
        WeightedVoteOption[] calldata options, 
        string calldata metadata
    ) external returns (bool success) {
        require(proposalId > 0, "Invalid proposal ID");
        require(options.length > 0, "Must provide vote options");
        
        // Validate that weights sum to 1.0 (represented as "1.000000000000000000")
        // This is just a basic check - in practice you'd want more robust validation
        
        (bool callSuccess, bytes memory result) = GOVERNANCE_PRECOMPILE.call(
            abi.encodeWithSignature(
                "voteWeighted(address,uint64,tuple(uint8,string)[],string)",
                msg.sender,
                proposalId,
                options,
                metadata
            )
        );
        
        require(callSuccess, "Weighted vote failed");
        success = abi.decode(result, (bool));
        require(success, "Weighted vote was rejected");
        
        emit WeightedVoteCast(msg.sender, proposalId, options);
        return success;
    }
    
    // Helper function to create a split vote (e.g., 70% Yes, 30% Abstain)
    function voteSplit(
        uint64 proposalId,
        uint256 yesPercent,
        uint256 abstainPercent
    ) external returns (bool) {
        require(yesPercent + abstainPercent == 100, "Percentages must sum to 100");
        
        WeightedVoteOption[] memory options = new WeightedVoteOption[](2);
        
        // Convert percentages to decimal weights (e.g., 70% = "0.700000000000000000")
        options[0] = WeightedVoteOption({
            option: VoteOption.Yes,
            weight: string(abi.encodePacked("0.", _padPercentage(yesPercent)))
        });
        
        options[1] = WeightedVoteOption({
            option: VoteOption.Abstain,
            weight: string(abi.encodePacked("0.", _padPercentage(abstainPercent)))
        });
        
        return voteWeighted(proposalId, options, "Split vote");
    }
    
    // Helper function to pad percentage to 18 decimal places
    function _padPercentage(uint256 percent) internal pure returns (string memory) {
        require(percent <= 100, "Percent cannot exceed 100");
        
        if (percent == 100) return "000000000000000000"; // Special case for 100%
        
        // This is a simplified version - in practice you'd want more robust decimal handling
        string memory percentStr = _toString(percent);
        if (percent < 10) {
            return string(abi.encodePacked("0", percentStr, "0000000000000000"));
        } else {
            return string(abi.encodePacked(percentStr, "0000000000000000"));
        }
    }
    
    function _toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) return "0";
        
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}
```
```bash cURL expandable lines
# Note: Transaction methods require signatures - use ethers.js or other Web3 library
echo "Weighted voting requires a signed transaction"
```
</CodeGroup>

### `deposit`
Adds funds to a proposal's deposit during the deposit period.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceExample {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct Coin {
        string denom;
        uint256 amount;
    }
    
    event DepositMade(address indexed depositor, uint64 indexed proposalId, uint256 amount);
    
    function deposit(uint64 proposalId, Coin[] calldata amount) external payable {
        require(proposalId > 0, "Invalid proposal ID");
        require(amount.length > 0, "Deposit amount required");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.call{value: msg.value}(
            abi.encodeWithSignature(
                "deposit(address,uint64,tuple(string,uint256)[])",
                msg.sender,
                proposalId,
                amount
            )
        );
        
        require(success, "Deposit failed");
        bool depositSuccess = abi.decode(result, (bool));
        require(depositSuccess, "Deposit was rejected");
        
        // Calculate total deposited amount for event
        uint256 totalAmount = 0;
        for (uint i = 0; i < amount.length; i++) {
            totalAmount += amount[i].amount;
        }
        
        emit DepositMade(msg.sender, proposalId, totalAmount);
    }
    
    // Convenience function to deposit native tokens
    function depositNative(uint64 proposalId, uint256 amount, string memory denom) external payable {
        require(msg.value >= amount, "Insufficient value sent");
        
        Coin[] memory coins = new Coin[](1);
        coins[0] = Coin({denom: denom, amount: amount});
        
        this.deposit{value: amount}(proposalId, coins);
    }
}
```
</CodeGroup>

### `cancelProposal`
Cancels a proposal that is still in its deposit period.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceCancelProposal {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    event ProposalCanceled(address indexed proposer, uint64 indexed proposalId, bool success);
    
    function cancelProposal(uint64 proposalId) external returns (bool success) {
        require(proposalId > 0, "Invalid proposal ID");
        
        (bool callSuccess, bytes memory result) = GOVERNANCE_PRECOMPILE.call(
            abi.encodeWithSignature("cancelProposal(address,uint64)", msg.sender, proposalId)
        );
        
        require(callSuccess, "Cancel proposal call failed");
        success = abi.decode(result, (bool));
        
        emit ProposalCanceled(msg.sender, proposalId, success);
        return success;
    }
    
    // Function to safely cancel a proposal with additional checks
    function safeCancelProposal(uint64 proposalId) external returns (bool success) {
        // First, check if the proposal exists and can be canceled
        // Note: In practice, you'd want to call getProposal first to verify status
        
        success = cancelProposal(proposalId);
        require(success, "Proposal cancellation failed - check if you're the proposer and proposal is in deposit period");
        
        return success;
    }
}
```
```bash cURL expandable lines
# Note: Transaction methods require signatures - use ethers.js or other Web3 library
echo "Canceling proposals requires a signed transaction"
```
</CodeGroup>

## Query Methods

### `getProposal`
Retrieves detailed information about a specific proposal.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceQueries {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct ProposalData {
        uint64 id;
        string[] messages;
        uint32 status;
        TallyResultData finalTallyResult;
        uint64 submitTime;
        uint64 depositEndTime;
        Coin[] totalDeposit;
        uint64 votingStartTime;
        uint64 votingEndTime;
        string metadata;
        string title;
        string summary;
        address proposer;
    }
    
    struct TallyResultData {
        string yes;
        string abstain;
        string no;
        string noWithVeto;
    }
    
    struct Coin {
        string denom;
        uint256 amount;
    }
    
    function getProposal(uint64 proposalId) external view returns (ProposalData memory proposal) {
        require(proposalId > 0, "Invalid proposal ID");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature("getProposal(uint64)", proposalId)
        );
        
        require(success, "Failed to get proposal");
        proposal = abi.decode(result, (ProposalData));
        return proposal;
    }
    
    // Helper function to check if proposal is in voting period
    function isProposalInVotingPeriod(uint64 proposalId) external view returns (bool) {
        ProposalData memory proposal = this.getProposal(proposalId);
        return proposal.status == 2; // PROPOSAL_STATUS_VOTING_PERIOD
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile, including the complex return struct
const precompileAbi = [
  "function getProposal(uint64 proposalId) view returns (tuple(uint64 id, address proposer, string metadata, uint64 submit_time, uint64 voting_start_time, uint64 voting_end_time, uint8 status, tuple(string yes_count, string abstain_count, string no_count, string no_with_veto_count) final_tally_result, tuple(string denom, uint256 amount)[] total_deposit, string[] messages) proposal)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

// Input: The ID of the proposal to query
const proposalId = 1;

async function getProposalDetails() {
  try {
    const proposal = await contract.getProposal(proposalId);
    console.log(`Proposal ${proposalId} Details:`, JSON.stringify(proposal, null, 2));
  } catch (error) {
    console.error(`Error fetching proposal ${proposalId}:`, error);
  }
}

getProposalDetails();

```

```bash cURL expandable lines
# Note: Replace <RPC_URL> with your actual data.
# This example queries for proposal with ID 1.
# Data is ABI-encoded: function selector + padded proposal ID
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0xc73dce9c0000000000000000000000000000000000000000000000000000000000000001"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getProposals`
Retrieves a filtered and paginated list of proposals.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceProposalsList {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct PageRequest {
        bytes key;
        uint64 offset;
        uint64 limit;
        bool countTotal;
        bool reverse;
    }
    
    struct PageResponse {
        bytes nextKey;
        uint64 total;
    }
    
    struct ProposalData {
        uint64 id;
        string[] messages;
        uint32 status;
        TallyResultData finalTallyResult;
        uint64 submitTime;
        uint64 depositEndTime;
        Coin[] totalDeposit;
        uint64 votingStartTime;
        uint64 votingEndTime;
        string metadata;
        string title;
        string summary;
        address proposer;
    }
    
    struct TallyResultData {
        string yes;
        string abstain;
        string no;
        string noWithVeto;
    }
    
    struct Coin {
        string denom;
        uint256 amount;
    }
    
    function getProposals(
        uint32 proposalStatus,
        address voter,
        address depositor,
        PageRequest memory pagination
    ) external view returns (ProposalData[] memory proposals, PageResponse memory pageResponse) {
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature(
                "getProposals(uint32,address,address,(bytes,uint64,uint64,bool,bool))",
                proposalStatus,
                voter,
                depositor,
                pagination
            )
        );
        
        require(success, "Failed to get proposals");
        (proposals, pageResponse) = abi.decode(result, (ProposalData[], PageResponse));
        return (proposals, pageResponse);
    }
    
    // Helper function to get all active proposals (in voting period)
    function getActiveProposals(uint64 limit) external view returns (ProposalData[] memory) {
        PageRequest memory pagination = PageRequest({
            key: "",
            offset: 0,
            limit: limit,
            countTotal: true,
            reverse: false
        });
        
        uint32 votingStatus = 2; // PROPOSAL_STATUS_VOTING_PERIOD
        (ProposalData[] memory proposals,) = this.getProposals(
            votingStatus,
            address(0),
            address(0),
            pagination
        );
        
        return proposals;
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile, including the complex return struct
const precompileAbi = [
  "function getProposals(tuple(uint64 offset, bytes key, uint64 limit, bool count_total, bool reverse) pagination, uint8 proposal_status, address voter, address depositor) view returns (tuple(uint64 id, address proposer, string metadata, uint64 submit_time, uint64 voting_start_time, uint64 voting_end_time, uint8 status, tuple(string yes_count, string abstain_count, string no_count, string no_with_veto_count) final_tally_result, tuple(string denom, uint256 amount)[] total_deposit, string[] messages)[] proposals, tuple(bytes next_key, uint64 total) page_response)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

// Inputs for filtering and pagination
const pagination = {
  offset: 0,
  key: "0x", // Start from the beginning
  limit: 10,
  count_total: true,
  reverse: false,
};
const proposalStatus = 0; // 0 for Unspecified, 1 for Deposit, 2 for Voting, etc.
const voterAddress = ethers.ZeroAddress; // Filter by voter, or ZeroAddress for none
const depositorAddress = ethers.ZeroAddress; // Filter by depositor, or ZeroAddress for none

async function getProposalsList() {
  try {
    const result = await contract.getProposals(pagination, proposalStatus, voterAddress, depositorAddress);
    // The result object contains 'proposals' and 'page_response'
    console.log("Proposals:", JSON.stringify(result.proposals, null, 2));
    console.log("Pagination Response:", result.page_response);
  } catch (error) {
    console.error("Error fetching proposals:", error);
  }
}

getProposalsList();
```
```bash cURL expandable lines
# Note: Replace <RPC_URL> with your actual RPC endpoint.
# This example queries for the first 10 proposals with any status.
# Data is ABI-encoded: function selector + complex input struct.
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x458af537000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getTallyResult`
Retrieves the current or final vote tally for a proposal.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceTally {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct TallyResultData {
        string yes;
        string abstain;
        string no;
        string noWithVeto;
    }
    
    function getTallyResult(uint64 proposalId) external view returns (TallyResultData memory tallyResult) {
        require(proposalId > 0, "Invalid proposal ID");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature("getTallyResult(uint64)", proposalId)
        );
        
        require(success, "Failed to get tally result");
        tallyResult = abi.decode(result, (TallyResultData));
        return tallyResult;
    }
    
    // Helper function to check if proposal is passing
    function isProposalPassing(uint64 proposalId) external view returns (bool) {
        TallyResultData memory tally = this.getTallyResult(proposalId);
        
        // Convert string votes to numbers for comparison (simplified)
        // In production, use proper decimal math libraries
        return keccak256(bytes(tally.yes)) > keccak256(bytes(tally.no));
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile
const precompileAbi = [
  "function getTallyResult(uint64 proposalId) view returns (tuple(string yes_count, string abstain_count, string no_count, string no_with_veto_count) tally)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

// Input: The ID of the proposal to get the tally for
const proposalId = 1;

async function getTally() {
  try {
    const tally = await contract.getTallyResult(proposalId);
    console.log(`Tally for Proposal ${proposalId}:`, {
      yes: tally.yes_count,
      abstain: tally.abstain_count,
      no: tally.no_count,
      noWithVeto: tally.no_with_veto_count,
    });
  } catch (error) {
    console.error(`Error fetching tally for proposal ${proposalId}:`, error);
  }
}

getTally();
```
```bash cURL expandable lines
# Note: Replace <RPC_URL> with your actual data.
# This example queries the tally for proposal with ID 1.
# Data is ABI-encoded: function selector + padded proposal ID
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x25a8c82a0000000000000000000000000000000000000000000000000000000000000001"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getVote`
Retrieves the vote cast by a specific address on a proposal.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceVoteQuery {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    enum VoteOption {
        Unspecified,
        Yes,
        Abstain,
        No,
        NoWithVeto
    }
    
    struct WeightedVoteOption {
        VoteOption option;
        string weight;
    }
    
    struct WeightedVote {
        uint64 proposalId;
        address voter;
        WeightedVoteOption[] options;
        string metadata;
    }
    
    function getVote(uint64 proposalId, address voter) external view returns (WeightedVote memory vote) {
        require(proposalId > 0, "Invalid proposal ID");
        require(voter != address(0), "Invalid voter address");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature("getVote(uint64,address)", proposalId, voter)
        );
        
        require(success, "Failed to get vote");
        vote = abi.decode(result, (WeightedVote));
        return vote;
    }
    
    // Helper function to check if an address has voted
    function hasVoted(uint64 proposalId, address voter) external view returns (bool) {
        try this.getVote(proposalId, voter) returns (WeightedVote memory vote) {
            return vote.options.length > 0;
        } catch {
            return false;
        }
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile
const precompileAbi = [
  "function getVote(uint64 proposalId, address voter) view returns (tuple(uint64 proposal_id, address voter, tuple(uint8 option, string weight)[] options, string metadata) vote)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

// Inputs
const proposalId = 1;
const voterAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"; // Placeholder

async function getVoteDetails() {
  try {
    const vote = await contract.getVote(proposalId, voterAddress);
    console.log("Vote Details:", JSON.stringify(vote, null, 2));
  } catch (error) {
    console.error("Error fetching vote:", error);
  }
}

getVoteDetails();
```
```bash cURL expandable lines
# Note: Replace <RPC_URL> and the placeholder address with your actual data.
# This example queries the vote of a specific address on proposal with ID 1.
# Data is ABI-encoded: function selector + padded proposal ID + padded voter address
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x54f6530f0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getVotes`
Retrieves all votes cast on a proposal, with pagination.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceVotesList {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct PageRequest {
        bytes key;
        uint64 offset;
        uint64 limit;
        bool countTotal;
        bool reverse;
    }
    
    struct PageResponse {
        bytes nextKey;
        uint64 total;
    }
    
    enum VoteOption {
        Unspecified,
        Yes,
        Abstain,
        No,
        NoWithVeto
    }
    
    struct WeightedVoteOption {
        VoteOption option;
        string weight;
    }
    
    struct WeightedVote {
        uint64 proposalId;
        address voter;
        WeightedVoteOption[] options;
        string metadata;
    }
    
    function getVotes(
        uint64 proposalId,
        PageRequest memory pagination
    ) external view returns (WeightedVote[] memory votes, PageResponse memory pageResponse) {
        require(proposalId > 0, "Invalid proposal ID");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature(
                "getVotes(uint64,(bytes,uint64,uint64,bool,bool))",
                proposalId,
                pagination
            )
        );
        
        require(success, "Failed to get votes");
        (votes, pageResponse) = abi.decode(result, (WeightedVote[], PageResponse));
        return (votes, pageResponse);
    }
    
    // Helper function to get all Yes votes
    function getYesVoters(uint64 proposalId, uint64 limit) external view returns (address[] memory) {
        PageRequest memory pagination = PageRequest({
            key: "",
            offset: 0,
            limit: limit,
            countTotal: false,
            reverse: false
        });
        
        (WeightedVote[] memory votes,) = this.getVotes(proposalId, pagination);
        
        uint256 yesCount = 0;
        for (uint i = 0; i < votes.length; i++) {
            if (votes[i].options.length > 0 && votes[i].options[0].option == VoteOption.Yes) {
                yesCount++;
            }
        }
        
        address[] memory yesVoters = new address[](yesCount);
        uint256 index = 0;
        for (uint i = 0; i < votes.length; i++) {
            if (votes[i].options.length > 0 && votes[i].options[0].option == VoteOption.Yes) {
                yesVoters[index++] = votes[i].voter;
            }
        }
        
        return yesVoters;
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile
const precompileAbi = [
  "function getVotes(uint64 proposalId, tuple(uint64 offset, bytes key, uint64 limit, bool count_total, bool reverse) pagination) view returns (tuple(uint64 proposal_id, address voter, tuple(uint8 option, string weight)[] options, string metadata)[] votes, tuple(bytes next_key, uint64 total) page_response)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

// Inputs
const proposalId = 1;
const pagination = {
  offset: 0,
  key: "0x",
  limit: 10,
  count_total: true,
  reverse: false,
};

async function getVotesList() {
  try {
    const result = await contract.getVotes(proposalId, pagination);
    console.log(`Votes for proposal ${proposalId}:`, JSON.stringify(result.votes, null, 2));
    console.log("Pagination Response:", result.page_response);
  } catch (error) {
    console.error("Error fetching votes:", error);
  }
}

getVotesList();
```
```bash cURL expandable lines
# Note: Replace <RPC_URL> with your actual RPC endpoint.
# This example queries for the first 10 votes on proposal with ID 1.
# Data is ABI-encoded: function selector + padded proposal ID + pagination struct.
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x6f74a8f300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getDeposit`
Retrieves deposit information for a specific depositor on a proposal.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceDepositQuery {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct Coin {
        string denom;
        uint256 amount;
    }
    
    struct DepositData {
        uint64 proposalId;
        address depositor;
        Coin[] amount;
    }
    
    function getDeposit(uint64 proposalId, address depositor) external view returns (DepositData memory deposit) {
        require(proposalId > 0, "Invalid proposal ID");
        require(depositor != address(0), "Invalid depositor address");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature("getDeposit(uint64,address)", proposalId, depositor)
        );
        
        require(success, "Failed to get deposit");
        deposit = abi.decode(result, (DepositData));
        return deposit;
    }
    
    // Helper function to get total deposit amount for a specific denom
    function getDepositAmount(uint64 proposalId, address depositor, string memory denom) external view returns (uint256) {
        DepositData memory deposit = this.getDeposit(proposalId, depositor);
        
        for (uint i = 0; i < deposit.amount.length; i++) {
            if (keccak256(bytes(deposit.amount[i].denom)) == keccak256(bytes(denom))) {
                return deposit.amount[i].amount;
            }
        }
        
        return 0;
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile
const precompileAbi = [
  "function getDeposit(uint64 proposalId, address depositor) view returns (tuple(address depositor, tuple(string denom, uint256 amount)[] amount) deposit)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

// Inputs
const proposalId = 1;
const depositorAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"; // Placeholder

async function getDepositDetails() {
  try {
    const deposit = await contract.getDeposit(proposalId, depositorAddress);
    console.log("Deposit Details:", JSON.stringify(deposit, null, 2));
  } catch (error) {
    console.error("Error fetching deposit:", error);
  }
}

getDepositDetails();
```
```bash cURL expandable lines
# Note: Replace <RPC_URL> and the placeholder address with your actual data.
# This example queries the deposit of a specific address on proposal with ID 1.
# Data is ABI-encoded: function selector + padded proposal ID + padded depositor address
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x582138a30000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getDeposits`
Retrieves all deposits made on a proposal, with pagination.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceDepositsList {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct PageRequest {
        bytes key;
        uint64 offset;
        uint64 limit;
        bool countTotal;
        bool reverse;
    }
    
    struct PageResponse {
        bytes nextKey;
        uint64 total;
    }
    
    struct Coin {
        string denom;
        uint256 amount;
    }
    
    struct DepositData {
        uint64 proposalId;
        address depositor;
        Coin[] amount;
    }
    
    function getDeposits(
        uint64 proposalId,
        PageRequest memory pagination
    ) external view returns (DepositData[] memory deposits, PageResponse memory pageResponse) {
        require(proposalId > 0, "Invalid proposal ID");
        
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature(
                "getDeposits(uint64,(bytes,uint64,uint64,bool,bool))",
                proposalId,
                pagination
            )
        );
        
        require(success, "Failed to get deposits");
        (deposits, pageResponse) = abi.decode(result, (DepositData[], PageResponse));
        return (deposits, pageResponse);
    }
    
    // Helper function to get all depositors
    function getDepositors(uint64 proposalId, uint64 limit) external view returns (address[] memory) {
        PageRequest memory pagination = PageRequest({
            key: "",
            offset: 0,
            limit: limit,
            countTotal: false,
            reverse: false
        });
        
        (DepositData[] memory deposits,) = this.getDeposits(proposalId, pagination);
        
        address[] memory depositors = new address[](deposits.length);
        for (uint i = 0; i < deposits.length; i++) {
            depositors[i] = deposits[i].depositor;
        }
        
        return depositors;
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile
const precompileAbi = [
  "function getDeposits(uint64 proposalId, tuple(uint64 offset, bytes key, uint64 limit, bool count_total, bool reverse) pagination) view returns (tuple(address depositor, tuple(string denom, uint256 amount)[] amount)[] deposits, tuple(bytes next_key, uint64 total) page_response)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

// Inputs
const proposalId = 1;
const pagination = {
  offset: 0,
  key: "0x",
  limit: 10,
  count_total: true,
  reverse: false,
};

async function getDepositsList() {
  try {
    const result = await contract.getDeposits(proposalId, pagination);
    console.log(`Deposits for proposal ${proposalId}:`, JSON.stringify(result.deposits, null, 2));
    console.log("Pagination Response:", result.page_response);
  } catch (error) {
    console.error("Error fetching deposits:", error);
  }
}

getDepositsList();
```
```bash cURL expandable lines
# Note: Replace <RPC_URL> with your actual RPC endpoint.
# This example queries for the first 10 deposits on proposal with ID 1.
# Data is ABI-encoded: function selector + padded proposal ID + pagination struct.
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x3677fd5500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getParams`
Retrieves current governance parameters.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceParams {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    struct Coin {
        string denom;
        uint256 amount;
    }
    
    struct Params {
        int64 votingPeriod;
        Coin[] minDeposit;
        int64 maxDepositPeriod;
        string quorum;
        string threshold;
        string vetoThreshold;
        string minInitialDepositRatio;
        string proposalCancelRatio;
        string proposalCancelDest;
        int64 expeditedVotingPeriod;
        string expeditedThreshold;
        Coin[] expeditedMinDeposit;
        bool burnVoteQuorum;
        bool burnProposalDepositPrevote;
        bool burnVoteVeto;
        string minDepositRatio;
    }
    
    function getParams() external view returns (Params memory params) {
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature("getParams()")
        );
        
        require(success, "Failed to get params");
        params = abi.decode(result, (Params));
        return params;
    }
    
    // Helper function to get minimum deposit amount for a specific denom
    function getMinDepositForDenom(string memory denom) external view returns (uint256) {
        Params memory params = this.getParams();
        
        for (uint i = 0; i < params.minDeposit.length; i++) {
            if (keccak256(bytes(params.minDeposit[i].denom)) == keccak256(bytes(denom))) {
                return params.minDeposit[i].amount;
            }
        }
        
        return 0;
    }
    
    // Helper function to get voting period in seconds
    function getVotingPeriodSeconds() external view returns (int64) {
        Params memory params = this.getParams();
        return params.votingPeriod;
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile
const precompileAbi = [
  "function getParams() view returns (tuple(string[] min_deposit, string max_deposit_period, string voting_period, string yes_quorum, string veto_threshold, string min_initial_deposit_ratio, string proposal_cancel_ratio, string proposal_cancel_dest, string min_deposit_ratio) params)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

async function getGovParams() {
  try {
    const params = await contract.getParams();
    console.log("Governance Parameters:", JSON.stringify(params, null, 2));
  } catch (error) {
    console.error("Error fetching governance parameters:", error);
  }
}

getGovParams();
```

**Note**: The `getParams()` function returns a complex nested structure that may require manual ABI decoding in some ethers.js versions. The cURL method is more reliable for this specific function.

```bash cURL expandable lines
# Note: Replace <RPC_URL> with your actual RPC endpoint.
# Data is ABI-encoded: just the function selector.
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x5e615a6b"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

### `getConstitution`
Retrieves the current governance constitution.

<CodeGroup>
```solidity Solidity expandable lines
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GovernanceConstitution {
    address constant GOVERNANCE_PRECOMPILE = 0x0000000000000000000000000000000000000805;
    
    function getConstitution() external view returns (string memory constitution) {
        (bool success, bytes memory result) = GOVERNANCE_PRECOMPILE.staticcall(
            abi.encodeWithSignature("getConstitution()")
        );
        
        require(success, "Failed to get constitution");
        constitution = abi.decode(result, (string));
        return constitution;
    }
    
    // Helper function to check if constitution is set
    function hasConstitution() external view returns (bool) {
        string memory constitution = this.getConstitution();
        return bytes(constitution).length > 0;
    }
    
    // Helper function to get constitution length
    function getConstitutionLength() external view returns (uint256) {
        string memory constitution = this.getConstitution();
        return bytes(constitution).length;
    }
}
```
```javascript Ethers.js expandable lines
import { ethers } from "ethers";

// ABI for the precompile
const precompileAbi = [
  "function getConstitution() view returns (string constitution)"
];

// Provider and contract setup
const provider = new ethers.JsonRpcProvider("<RPC_URL>");
const precompileAddress = "0x0000000000000000000000000000000000000805";
const contract = new ethers.Contract(precompileAddress, precompileAbi, provider);

async function getGovConstitution() {
  try {
    const constitution = await contract.getConstitution();
    console.log("Governance Constitution:", constitution);
  } catch (error) {
    console.error("Error fetching governance constitution:", error);
  }
}

getGovConstitution();
```
```bash cURL expandable lines
# Note: Replace <RPC_URL> with your actual RPC endpoint.
# Data is ABI-encoded: just the function selector.
curl -X POST --data '{
    "jsonrpc": "2.0",
    "method": "eth_call",
    "params": [
        {
            "to": "0x0000000000000000000000000000000000000805",
            "data": "0x04b12c7f"
        },
        "latest"
    ],
    "id": 1
}' -H "Content-Type: application/json" <RPC_URL>
```
</CodeGroup>

## Full Solidity Interface & ABI

```solidity title="Governance Solidity Interface" lines expandable
// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity >=0.8.17;

import "../common/Types.sol";

/// @dev The IGov contract's address.
address constant GOV_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000805;

/// @dev The IGov contract's instance.
IGov constant GOV_CONTRACT = IGov(GOV_PRECOMPILE_ADDRESS);

/**
 * @dev VoteOption enumerates the valid vote options for a given governance proposal.
 */
enum VoteOption {
    // Unspecified defines a no-op vote option.
    Unspecified,
    // Yes defines a yes vote option.
    Yes,
    // Abstain defines an abstain vote option.
    Abstain,
    // No defines a no vote option.
    No,
    // NoWithVeto defines a no with veto vote option.
    NoWithVeto
}

/// @dev WeightedVote represents a vote on a governance proposal
struct WeightedVote {
    uint64 proposalId;
    address voter;
    WeightedVoteOption[] options;
    string metadata;
}

/// @dev WeightedVoteOption represents a weighted vote option
struct WeightedVoteOption {
    VoteOption option;
    string weight;
}

/// @dev DepositData represents information about a deposit on a proposal
struct DepositData {
    uint64 proposalId;
    address depositor;
    Coin[] amount;
}

/// @dev TallyResultData represents the tally result of a proposal
struct TallyResultData {
    string yes;
    string abstain;
    string no;
    string noWithVeto;
}

/// @dev ProposalData represents a governance proposal
struct ProposalData {
    uint64 id;
    string[] messages;
    uint32 status;
    TallyResultData finalTallyResult;
    uint64 submitTime;
    uint64 depositEndTime;
    Coin[] totalDeposit;
    uint64 votingStartTime;
    uint64 votingEndTime;
    string metadata;
    string title;
    string summary;
    address proposer;
}

/// @dev Params defines the governance parameters
struct Params {
    int64 votingPeriod;
    Coin[] minDeposit;
    int64 maxDepositPeriod;
    string quorum;
    string threshold;
    string vetoThreshold;
    string minInitialDepositRatio;
    string proposalCancelRatio;
    string proposalCancelDest;
    int64 expeditedVotingPeriod;
    string expeditedThreshold;
    Coin[] expeditedMinDeposit;
    bool burnVoteQuorum;
    bool burnProposalDepositPrevote;
    bool burnVoteVeto;
    string minDepositRatio;
}

/// @author The Evmos Core Team
/// @title Gov Precompile Contract
/// @dev The interface through which solidity contracts will interact with Gov
interface IGov {
    /// @dev SubmitProposal defines an Event emitted when a proposal is submitted.
    /// @param proposer the address of the proposer
    /// @param proposalId the proposal of id
    event SubmitProposal(address indexed proposer, uint64 proposalId);

    /// @dev CancelProposal defines an Event emitted when a proposal is canceled.
    /// @param proposer the address of the proposer
    /// @param proposalId the proposal of id
    event CancelProposal(address indexed proposer, uint64 proposalId);

    /// @dev Deposit defines an Event emitted when a deposit is made.
    /// @param depositor the address of the depositor
    /// @param proposalId the proposal of id
    /// @param amount the amount of the deposit
    event Deposit(address indexed depositor, uint64 proposalId, Coin[] amount);

    /// @dev Vote defines an Event emitted when a proposal voted.
    /// @param voter the address of the voter
    /// @param proposalId the proposal of id
    /// @param option the option for voter
    event Vote(address indexed voter, uint64 proposalId, uint8 option);

    /// @dev VoteWeighted defines an Event emitted when a proposal voted.
    /// @param voter the address of the voter
    /// @param proposalId the proposal of id
    /// @param options the options for voter
    event VoteWeighted(
        address indexed voter,
        uint64 proposalId,
        WeightedVoteOption[] options
    );

    /// TRANSACTIONS

    /// @notice submitProposal creates a new proposal from a protoJSON document.
    /// @dev submitProposal defines a method to submit a proposal.
    /// @param jsonProposal The JSON proposal
    /// @param deposit The deposit for the proposal
    /// @return proposalId The proposal id
    function submitProposal(
        address proposer,
        bytes calldata jsonProposal,
        Coin[] calldata deposit
    ) external returns (uint64 proposalId);

    /// @dev cancelProposal defines a method to cancel a proposal.
    /// @param proposalId The proposal id
    /// @return success Whether the transaction was successful or not
    function cancelProposal(
        address proposer,
        uint64 proposalId
    ) external returns (bool success);

    /// @dev deposit defines a method to add a deposit to a proposal.
    /// @param proposalId The proposal id
    /// @param amount The amount to deposit
    function deposit(
        address depositor,
        uint64 proposalId,
        Coin[] calldata amount
    ) external returns (bool success);

    /// @dev vote defines a method to add a vote on a specific proposal.
    /// @param voter The address of the voter
    /// @param proposalId the proposal of id
    /// @param option the option for voter
    /// @param metadata the metadata for voter send
    /// @return success Whether the transaction was successful or not
    function vote(
        address voter,
        uint64 proposalId,
        VoteOption option,
        string memory metadata
    ) external returns (bool success);

    /// @dev voteWeighted defines a method to add a vote on a specific proposal.
    /// @param voter The address of the voter
    /// @param proposalId The proposal id
    /// @param options The options for voter
    /// @param metadata The metadata for voter send
    /// @return success Whether the transaction was successful or not
    function voteWeighted(
        address voter,
        uint64 proposalId,
        WeightedVoteOption[] calldata options,
        string memory metadata
    ) external returns (bool success);

    /// QUERIES

    /// @dev getVote returns the vote of a single voter for a
    /// given proposalId.
    /// @param proposalId The proposal id
    /// @param voter The voter on the proposal
    /// @return vote Voter's vote for the proposal
    function getVote(
        uint64 proposalId,
        address voter
    ) external view returns (WeightedVote memory vote);

    /// @dev getVotes Returns the votes for a specific proposal.
    /// @param proposalId The proposal id
    /// @param pagination The pagination options
    /// @return votes The votes for the proposal
    /// @return pageResponse The pagination information
    function getVotes(
        uint64 proposalId,
        PageRequest calldata pagination
    )
        external
        view
        returns (WeightedVote[] memory votes, PageResponse memory pageResponse);

    /// @dev getDeposit returns the deposit of a single depositor for a given proposalId.
    /// @param proposalId The proposal id
    /// @param depositor The address of the depositor
    /// @return deposit The deposit information
    function getDeposit(
        uint64 proposalId,
        address depositor
    ) external view returns (DepositData memory deposit);

    /// @dev getDeposits returns all deposits for a specific proposal.
    /// @param proposalId The proposal id
    /// @param pagination The pagination options
    /// @return deposits The deposits for the proposal
    /// @return pageResponse The pagination information
    function getDeposits(
        uint64 proposalId,
        PageRequest calldata pagination
    )
        external
        view
        returns (
            DepositData[] memory deposits,
            PageResponse memory pageResponse
        );

    /// @dev getTallyResult returns the tally result of a proposal.
    /// @param proposalId The proposal id
    /// @return tallyResult The tally result of the proposal
    function getTallyResult(
        uint64 proposalId
    ) external view returns (TallyResultData memory tallyResult);

    /// @dev getProposal returns the proposal details based on proposal id.
    /// @param proposalId The proposal id
    /// @return proposal The proposal data
    function getProposal(
        uint64 proposalId
    ) external view returns (ProposalData memory proposal);

    /// @dev getProposals returns proposals with matching status.
    /// @param proposalStatus The proposal status to filter by
    /// @param voter The voter address to filter by, if any
    /// @param depositor The depositor address to filter by, if any
    /// @param pagination The pagination config
    /// @return proposals The proposals matching the filter criteria
    /// @return pageResponse The pagination information
    function getProposals(
        uint32 proposalStatus,
        address voter,
        address depositor,
        PageRequest calldata pagination
    )
        external
        view
        returns (
            ProposalData[] memory proposals,
            PageResponse memory pageResponse
        );

    /// @dev getParams returns the current governance parameters.
    /// @return params The governance parameters
    function getParams() external view returns (Params memory params);

    /// @dev getConstitution returns the current constitution.
    /// @return constitution The current constitution
    function getConstitution() external view returns (string memory constitution);
}
```

```json title="Governance ABI" lines expandable
{
  "_format": "hh-sol-artifact-1",
  "contractName": "IGov",
  "sourceName": "solidity/precompiles/gov/IGov.sol",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        }
      ],
      "name": "CancelProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "denom",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct Coin[]",
          "name": "amount",
          "type": "tuple[]"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        }
      ],
      "name": "SubmitProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "voter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "option",
          "type": "uint8"
        }
      ],
      "name": "Vote",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "voter",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "enum VoteOption",
              "name": "option",
              "type": "uint8"
            },
            {
              "internalType": "string",
              "name": "weight",
              "type": "string"
            }
          ],
          "indexed": false,
          "internalType": "struct WeightedVoteOption[]",
          "name": "options",
          "type": "tuple[]"
        }
      ],
      "name": "VoteWeighted",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        }
      ],
      "name": "cancelProposal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "denom",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "internalType": "struct Coin[]",
          "name": "amount",
          "type": "tuple[]"
        }
      ],
      "name": "deposit",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getConstitution",
      "outputs": [
        {
          "internalType": "string",
          "name": "constitution",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        }
      ],
      "name": "getDeposit",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "denom",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Coin[]",
              "name": "amount",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct DepositData",
          "name": "deposit",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "key",
              "type": "bytes"
            },
            {
              "internalType": "uint64",
              "name": "offset",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "limit",
              "type": "uint64"
            },
            {
              "internalType": "bool",
              "name": "countTotal",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "reverse",
              "type": "bool"
            }
          ],
          "internalType": "struct PageRequest",
          "name": "pagination",
          "type": "tuple"
        }
      ],
      "name": "getDeposits",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "denom",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Coin[]",
              "name": "amount",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct DepositData[]",
          "name": "deposits",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "nextKey",
              "type": "bytes"
            },
            {
              "internalType": "uint64",
              "name": "total",
              "type": "uint64"
            }
          ],
          "internalType": "struct PageResponse",
          "name": "pageResponse",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getParams",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "minDeposit",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "maxDepositPeriod",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "votingPeriod",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "quorum",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "threshold",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "vetoThreshold",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "minInitialDepositRatio",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "proposalCancelRatio",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "proposalCancelDest",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "minDepositRatio",
              "type": "string"
            }
          ],
          "internalType": "struct Params",
          "name": "params",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        }
      ],
      "name": "getProposal",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "id",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "proposer",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "metadata",
              "type": "string"
            },
            {
              "internalType": "uint64",
              "name": "submitTime",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "votingStartTime",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "votingEndTime",
              "type": "uint64"
            },
            {
              "internalType": "uint8",
              "name": "status",
              "type": "uint8"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "yesCount",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "abstainCount",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "noCount",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "noWithVetoCount",
                  "type": "string"
                }
              ],
              "internalType": "struct TallyResultData",
              "name": "finalTallyResult",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "denom",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Coin[]",
              "name": "totalDeposit",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "messages",
              "type": "string[]"
            }
          ],
          "internalType": "struct ProposalData",
          "name": "proposal",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "key",
              "type": "bytes"
            },
            {
              "internalType": "uint64",
              "name": "offset",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "limit",
              "type": "uint64"
            },
            {
              "internalType": "bool",
              "name": "countTotal",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "reverse",
              "type": "bool"
            }
          ],
          "internalType": "struct PageRequest",
          "name": "pagination",
          "type": "tuple"
        },
        {
          "internalType": "uint8",
          "name": "proposalStatus",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "voter",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "depositor",
          "type": "address"
        }
      ],
      "name": "getProposals",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "id",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "proposer",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "metadata",
              "type": "string"
            },
            {
              "internalType": "uint64",
              "name": "submitTime",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "votingStartTime",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "votingEndTime",
              "type": "uint64"
            },
            {
              "internalType": "uint8",
              "name": "status",
              "type": "uint8"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "yesCount",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "abstainCount",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "noCount",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "noWithVetoCount",
                  "type": "string"
                }
              ],
              "internalType": "struct TallyResultData",
              "name": "finalTallyResult",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "denom",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Coin[]",
              "name": "totalDeposit",
              "type": "tuple[]"
            },
            {
              "internalType": "string[]",
              "name": "messages",
              "type": "string[]"
            }
          ],
          "internalType": "struct ProposalData[]",
          "name": "proposals",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "nextKey",
              "type": "bytes"
            },
            {
              "internalType": "uint64",
              "name": "total",
              "type": "uint64"
            }
          ],
          "internalType": "struct PageResponse",
          "name": "pageResponse",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        }
      ],
      "name": "getTallyResult",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "yesCount",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "abstainCount",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "noCount",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "noWithVetoCount",
              "type": "string"
            }
          ],
          "internalType": "struct TallyResultData",
          "name": "tally",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "voter",
          "type": "address"
        }
      ],
      "name": "getVote",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "proposalId",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "voter",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "option",
                  "type": "uint8"
                },
                {
                  "internalType": "string",
                  "name": "weight",
                  "type": "string"
                }
              ],
              "internalType": "struct WeightedVoteOption[]",
              "name": "options",
              "type": "tuple[]"
            },
            {
              "internalType": "string",
              "name": "metadata",
              "type": "string"
            }
          ],
          "internalType": "struct WeightedVote",
          "name": "vote",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "key",
              "type": "bytes"
            },
            {
              "internalType": "uint64",
              "name": "offset",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "limit",
              "type": "uint64"
            },
            {
              "internalType": "bool",
              "name": "countTotal",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "reverse",
              "type": "bool"
            }
          ],
          "internalType": "struct PageRequest",
          "name": "pagination",
          "type": "tuple"
        }
      ],
      "name": "getVotes",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "proposalId",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "voter",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint8",
                  "name": "option",
                  "type": "uint8"
                },
                {
                  "internalType": "string",
                  "name": "weight",
                  "type": "string"
                }
              ],
              "internalType": "struct WeightedVoteOption[]",
              "name": "options",
              "type": "tuple[]"
            },
            {
              "internalType": "string",
              "name": "metadata",
              "type": "string"
            }
          ],
          "internalType": "struct WeightedVote[]",
          "name": "votes",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "nextKey",
              "type": "bytes"
            },
            {
              "internalType": "uint64",
              "name": "total",
              "type": "uint64"
            }
          ],
          "internalType": "struct PageResponse",
          "name": "pageResponse",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "jsonProposal",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "denom",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "internalType": "struct Coin[]",
          "name": "deposit",
          "type": "tuple[]"
        }
      ],
      "name": "submitProposal",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "voter",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "internalType": "enum VoteOption",
          "name": "option",
          "type": "uint8"
        },
        {
          "internalType": "string",
          "name": "metadata",
          "type": "string"
        }
      ],
      "name": "vote",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "voter",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "proposalId",
          "type": "uint64"
        },
        {
          "components": [
            {
              "internalType": "enum VoteOption",
              "name": "option",
              "type": "uint8"
            },
            {
              "internalType": "string",
              "name": "weight",
              "type": "string"
            }
          ],
          "internalType": "struct WeightedVoteOption[]",
          "name": "options",
          "type": "tuple[]"
        },
        {
          "internalType": "string",
          "name": "metadata",
          "type": "string"
        }
      ],
      "name": "voteWeighted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]
}