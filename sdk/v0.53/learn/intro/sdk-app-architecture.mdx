---
title: Blockchain Architecture
description: 'At its core, a blockchain is a replicated deterministic state machine.'
---

## State machine

At its core, a blockchain is a [replicated deterministic state machine](https://en.wikipedia.org/wiki/State_machine_replication): multiple nodes independently execute the same state machine over the same ordered inputs and, as a result, reach the same state.

A **state machine** is a computer science abstraction in which a system can exist in many possible states, but only one at any given time. It is defined by:

- a **state** `S`, which represents the current data of the system, and
- **transactions** `T`, which describe how the state can change.

Given a state `S` and a transaction `T`, the state machine computes a new state `S'`:

```text
+--------+                 +--------+
|        |                 |        |
|   S    +---------------->+   S'   |
|        |    apply(T)     |        |
+--------+                 +--------+
```

In practice, transactions are grouped into **blocks** to improve efficiency. A block `B` is an ordered list of transactions, and the resulting state is obtained by applying each transaction sequentially:

```text
+--------+                              +--------+
|        |                              |        |
|   S    +----------------------------> |   S'   |
|        |   For each T in B: apply(T)  |        |
+--------+                              +--------+
```

In a blockchain context, the state machine must be **deterministic**. This means that if a node starts from a given state and replays the same transactions in the same order, it will always arrive at the same final state. Determinism is essential: without it, nodes would diverge and consensus would be impossible.

The Cosmos SDK gives developers full control over how the application state is defined, which transaction types are supported, and how state transitions are executed. Building state machines with the Cosmos SDK is covered in later sections. First, however, you'll learn how this state machine is replicated across the network using **CometBFT**.

## CometBFT: Networking and Consensus

Thanks to the Cosmos SDK, developers only need to define the application state machine. CometBFT then takes care of replicating that state machine across the network by handling networking and consensus.

In this context:

- **Networking** refers to how nodes discover each other, exchange messages, and propagate transaction and block data across a peer-to-peer network.
- **Consensus** refers to how nodes agree on a single, ordered sequence of blocks to apply to the state machine, even in the presence of faulty or malicious nodes.


```text
                ^  +-------------------------------+  ^
                |  |                               |  |   Built with Cosmos SDK
                |  |  State-machine = Application  |  |
                |  |                               |  v
                |  +-------------------------------+
                |  |                               |  ^
Blockchain node |  |           Consensus           |  |
                |  |                               |  |
                |  +-------------------------------+  |   CometBFT
                |  |                               |  |
                |  |           Networking          |  |
                |  |                               |  |
                v  +-------------------------------+  v
```


[CometBFT](/cometbft/v0.38/docs/introduction/intro) is an application-agnostic engine responsible for these two layers. Through its networking layer, CometBFT propagates transaction and block data between nodes. Through its consensus layer, it deterministically orders transactions into blocks that can be safely applied by the application.

Importantly, CometBFT does not interpret the meaning of transactions. It treats them as raw bytes and is only responsible for their dissemination and ordering.

To agree on a single transaction order, CometBFT relies on a Byzantine Fault Tolerant (BFT) consensus algorithm.

The CometBFT [consensus algorithm](/cometbft/v0.38/spec/consensus/Byzantine-Consensus-Algorithm) operates over a set of special nodes called *validators*. Validators are responsible for proposing and voting on blocks. At any given block height, there exists a validator set `V`. One validator from `V` is selected as the proposer for the next block.

A proposed block is considered committed if more than two thirds of the voting power in `V` sign both a `prevote` and a `precommit` for that block, and if all transactions it contains are valid according to the application. The validator set itself is part of the application state and can be updated by rules defined in the state machine.


## ABCI

CometBFT passes transactions to the application through an interface called the [ABCI](/cometbft/v0.38/spec/abci/Overview), which the application must implement.

```text expandable
              +---------------------+
              |                     |
              |     Application     |
              |                     |
              +--------+---+--------+
                       ^   |
                       |   | ABCI
                       |   v
              +--------+---+--------+
              |                     |
              |                     |
              |       CometBFT      |
              |                     |
              |                     |
              +---------------------+
```

Note that **CometBFT only handles transaction bytes**. It has no knowledge of what these bytes mean. All CometBFT does is order these transaction bytes deterministically. CometBFT passes the bytes to the application via the ABCI, and expects a return code to inform it if the messages contained in the transactions were successfully processed or not.

Here are the most important messages of the ABCI:

* `CheckTx`: When a transaction is received by CometBFT, it is passed to the application to check if a few basic requirements are met. `CheckTx` is used to protect the mempool of full-nodes against spam transactions. . A special handler called the [`AnteHandler`](/sdk/v0.53/learn/beginner/gas-fees#antehandler) is used to execute a series of validation steps such as checking for sufficient fees and validating the signatures. If the checks are valid, the transaction is added to the [mempool](/cometbft/v0.38/spec/p2p/legacy-docs/messages/mempool) and relayed to peer nodes. Note that transactions are not processed (i.e. no modification of the state occurs) with `CheckTx` since they have not been included in a block yet.
* `DeliverTx`: When a [valid block](/cometbft/v0.38/spec/core/Data_structures#block) is received by CometBFT, each transaction in the block is passed to the application via `DeliverTx` in order to be processed. It is during this stage that the state transitions occur. The `AnteHandler` executes again, along with the actual [`Msg` service](/sdk/v0.53/build/building-modules/msg-services) RPC for each message in the transaction.
* `BeginBlock`/`EndBlock`: These messages are executed at the beginning and the end of each block, whether the block contains transactions or not. It is useful to trigger automatic execution of logic. Proceed with caution though, as computationally expensive loops could slow down your blockchain, or even freeze it if the loop is infinite.

Find a more detailed view of the ABCI methods from the [CometBFT docs](/cometbft/v0.38/spec/abci/Overview).

Any application built on CometBFT needs to implement the ABCI interface in order to communicate with the underlying local CometBFT engine. Fortunately, you do not have to implement the ABCI interface. The Cosmos SDK provides a boilerplate implementation of it in the form of [baseapp](/sdk/v0.53/learn/intro/sdk-design).
