---
title: Cosmos SDK Architecture
description: How Cosmos SDK implements blockchains through separation of consensus, interface, and application logic.
---

## Introduction: From Blockchain Basics to Cosmos

In [Introduction to Blockchains](/sdk/v0.53/learn/intro/blockchain-basics), you learned that a blockchain is a replicated, deterministic state machine maintained by independent nodes through consensus. The Cosmos SDK implements this model through a clean separation of concerns: CometBFT handles consensus, networking, and block production; ABCI (Application Blockchain Interface) defines the boundary between consensus and application; and the Cosmos SDK implements the application logic and state machine.

This page explains the high-level architecture of Cosmos SDK blockchains: how components interact, what each layer is responsible for, and why this separation matters. 

## Cosmos Application Architecture

The most basic Cosmos SDK blockchain application consists of three distinct layers, all running within a node's daemon process:

```text
+---------------------------------------+
|                                       |
|       Cosmos SDK Application          |  <- State machine
|       (Modules, Keepers, State)       |     - Transaction execution
|                                       |     - Business logic
+------------------+--------------------+
                   |
                 ABCI  <- Application Blockchain Interface
                   |
+------------------+--------------------+
|                                       |
|              CometBFT                 |  <- Consensus engine
|      (Consensus, Networking,          |     - Block production
|         Block Replication)            |     - p2p networking
|                                       |
+---------------------------------------+
```

### CometBFT: The Consensus Engine

[CometBFT](/cometbft/v0.38/docs/introduction/intro) sits at the foundation and handles consensus, networking, and block production. It manages peer-to-peer connections between nodes, determines which transactions get included in blocks and in what order, and reaches Byzantine Fault Tolerant (BFT) consensus on block proposals. Once consensus is reached, CometBFT replicates finalized blocks across all nodes and provides deterministic block ordering with instant finality: once a block is committed, it cannot be reverted.

Critically, CometBFT is application-agnostic by design. It treats transactions as opaque bytes and knows nothing about what they mean or how they should be executed. This separation allows the same consensus engine to power many different blockchain applications.

### ABCI: Application Blockchain Interface

ABCI is the strict interface boundary between CometBFT and the application. It defines when the application is invoked during the block lifecycle, what information is passed (transaction bytes and block metadata), and what the application must return (execution results and state commitments). This interface enforces the separation between consensus (managed by CometBFT) and execution (managed by the Cosmos SDK). The application cannot influence consensus decisions, and consensus cannot interpret application-specific logic.

### Cosmos SDK: Application and State Machine

The [Cosmos SDK](/sdk/v0.53/learn/intro/overview) implements the application-specific state machine. It defines transaction and message formats, validates transactions, executes state transitions, maintains application state across all modules, and produces cryptographic commitments to the state called the AppHash. Application logic is organized into modules (such as bank, staking, and governance), with each module responsible for a domain-specific part of the state machine.

### Separating Consensus and Application Logic

Separating consensus from application logic provides several benefits. Security improves because isolating consensus logic prevents application bugs from affecting block production or network stability. Flexibility increases as developers can build application-specific blockchains without reimplementing consensus. The modular design allows consensus and application layers to evolve independently, and reusability means one consensus engine (CometBFT) can power many different blockchains without modification.

## Nodes and Daemons

A blockchain is made up of nodes, or participants in the blockchain network. Each node runs a daemon process (for example, `simd` for a chain built with SimApp) that includes both a CometBFT instance for consensus and networking, and a Cosmos SDK application for the state machine and execution logic. The daemon participates in networking, reaches consensus with other nodes, and executes transactions to update the application state.

Nodes can operate in different roles. There are two main types of nodes, **validators** and **full nodes:

- **Validators** are nodes that participate in consensus by proposing and voting on blocks, with consensus power staked or attributed to them making them responsible for block production. They are in charge of validating blocks before voting, ensuring that only valid blocks are finalized.

- **Full nodes** replicate and verify blocks without participating in consensus voting, maintaining complete state and answering queries but not voting on proposals. 

Although anyone can typically run a full node, becoming a validator depends on the chain's staking, governance, or permissioning rules. In a proof-of-stake blockchain, validator candidates are selected based on their stake, and they must meet certain criteria to be elected as validators. In a proof-of-authority blockchain, validators are selected based on permissioned criteria.

## CometBFT

CometBFT is a Byzantine Fault Tolerant consensus engine that provides fast, deterministic finality. It's used by Cosmos SDK blockchains to replicate the state machine across a decentralized network.

### Core Responsibilities

CometBFT handles several core responsibilities:

- **Peer-to-peer networking**: CometBFT manages node discovery, establishes and maintains connections with other validators and full nodes, and implements gossip protocols for propagating information across the network.

- **Transaction propagation and mempool management**: When users submit transactions to a node, CometBFT gossips them to other nodes. Each node maintains a mempool (memory pool), which is a waiting area for valid transactions that have not yet been included in a block. The mempool holds transactions temporarily until a validator includes them in a block proposal.

- **Block proposal and transaction ordering**: CometBFT uses deterministic proposer selection to choose which validator will propose the next block. The proposer selects transactions from the mempool, orders them, and packages them into a block proposal.

- **Byzantine Fault Tolerant consensus**: CometBFT coordinates voting rounds where validators vote on block proposals. When a proposal receives more than two-thirds of voting power, consensus is reached and the block is finalized.

- **Block replication**: Once finalized, CometBFT ensures the block is replicated across all nodes in the network, maintaining a consistent, ordered history of all committed blocks.

### Byzantine Fault Tolerance and Finality

Byzantine Fault Tolerance (BFT) refers to a system's ability to reach consensus even when some participants behave arbitrarily; they may crash, send conflicting messages, or act maliciously. The name comes from the [Byzantine Generals Problem](https://lamport.azurewebsites.net/pubs/byz.pdf), a game theory thought experiment about coordinating agreement in the presence of malicious or faulty participants. In blockchain networks, Byzantine faults include validators that are compromised, malicious, or simply behaving unpredictably due to software bugs or network issues.

CometBFT's BFT consensus was built for strong security and finality. As long as fewer than one-third of voting power is Byzantine (malicious or faulty), the network will not commit conflicting blocks. This means the network can tolerate up to 33% of validators acting arbitrarily without breaking consensus. Liveness is maintained as long as more than two-thirds of voting power is online and participating, ensuring the network continues producing blocks. Unlike proof-of-work blockchains, CometBFT provides instant finality: once a block is committed, it cannot be reverted. There are no reorganizations or probabilistic finality when building a blockchain using CometBFT.

### Orchestrating Block Production

CometBFT drives the entire block production lifecycle. It determines when blocks are produced (maintaining consistent block times), which validator proposes each block (through deterministic proposer selection), and the order in which transactions are included in blocks. CometBFT coordinates the consensus process by managing the voting rounds where validators evaluate and vote on block proposals.

### Content Agnosticism

Although CometBFT fascilitates the production of blocks, it is agnostic to both the content of the blocks and the implementation of the application. It treats transactions as opaque byte arrays, and it does not interpret or validate their contents beyond basic formatting. CometBFT has no knowledge of what constitutes a valid transaction for your application; it only ensures that all nodes receive the same ordered sequence of transaction bytes. All application-specific logic is handled by the Cosmos SDK application layer through the ABCI interface.

This agnosticism also extends to programming languages. Because the ABCI is a language-agnostic protocol, applications can be written in any language that implements the ABCI interface. While the Cosmos SDK is written in Go, applications have been built using ABCI implementations in Rust, Python, JavaScript, and other languages. CometBFT doesn't care what language your application uses—it only cares that the application responds correctly to ABCI method calls.

## ABCI (Application Blockchain Interface)

ABCI is a strict request/response interface between CometBFT and a Cosmos SDK blockchain application. It defines the block execution lifecycle and ensures a clean separation between consensus and application logic to ensure secure, reliable block production that cannot be compromised by application faults or bugs.

The ABCI is unidirectional: all calls flow from CometBFT to the application, and the application cannot call into or control CometBFT. The Cosmos SDK application must respond deterministically to all ABCI calls, producing the same results given the same inputs. 

The ABCI itself is a stateless protocol containing no business logic, only interface definitions. 

### Block Lifecycle Methods

Modern Cosmos SDK applications (v0.50+) use ABCI 2.0, which provides several key methods that CometBFT invokes at different points in the block lifecycle.

As the driver of block production, CometBFT controls when the application is invoked. It calls the application through ABCI at specific points in the block lifecycle—to validate transactions for the mempool (CheckTx), to construct or evaluate block proposals (PrepareProposal and ProcessProposal), to execute finalized blocks (FinalizeBlock), and to persist state (Commit). The application responds to these calls but cannot initiate them. This means CometBFT, not the application, determines the timing and cadence of block production and state transitions.


```python
+---------------+              |          +--------------------------+
|   CometBFT    |              |          |    SDK Application       |
| (Consensus)   |             ABCI        |  (State Machine Logic)   |
+---------------+              |          +--------------------------+
1) CheckTx                     |
   Mempool validation ---------|-------> Validate tx (sigs, fees)
                               |
2) PrepareProposal             |
   Proposer builds block ------|--------> Construct block proposal
                               |
3) ProcessProposal             |
   Validators evaluate --------|--------> Validate proposal
                               |
4) Consensus                   |
   BFT voting, finalizing block|
   (SDK not involved)          |
                               |
5) FinalizeBlock               |
   Execute block --------------|--------> PreBlock hooks
                               |          BeginBlock hooks
                               |          Execute transactions
                               |          EndBlock hooks
                               |          Return AppHash
                               |
6) Commit                      |
   Persist state --------------|--------> Persist to disk
                               |<-------- Return AppHash
```

1. **CheckTx** validates transactions before adding them to the mempool. It checks that transactions are well-formed and economically viable (proper signature, sufficient fees) without making state changes. This protects the mempool against spam.

2. **PrepareProposal** is invoked when a validator constructs a new block proposal. This gives the application control over block construction, allowing it to reorder transactions or add application-specific data.

3. **ProcessProposal** is called when validators evaluate a block proposal from another validator. The application can validate the proposed block according to application-specific rules before voting to accept it.

4. **Consensus** occurs entirely within CometBFT. After validators evaluate the proposal (via ProcessProposal), they participate in BFT voting rounds. If the proposal receives votes from more than two-thirds of voting power, consensus is reached and the block is finalized. 

5. **FinalizeBlock** is invoked after consensus on a block is reached. This is where state transitions occur, executing the entire block atomically. BaseApp invokes lifecycle hooks in this order: PreBlock hooks (required in SDK v0.53), BeginBlock hooks, transaction execution, and EndBlock hooks. The application returns the new AppHash (a cryptographic commitment to the state) and any validator set changes.

6. **Commit** is called after FinalizeBlock to persist the finalized state to disk and return the AppHash that gets included in the next block header.

<Note>
SDK v0.53 introduces **PreBlock** hooks, which run before BeginBlock. PreBlockers must be explicitly ordered using `SetOrderPreBlockers`. Some core modules (notably `x/auth`) require PreBlock execution—missing PreBlock wiring will cause runtime errors.
</Note>

### Why This Separation Exists

The ABCI boundary prevents application logic from influencing consensus, enables consensus engine reuse across many applications, improves security by separating concerns, and simplifies testing by allowing applications to be tested independently of consensus mechanisms.

## Cosmos SDK

A Cosmos SDK application is a deterministic state machine that defines a blockchain's behavior. It focuses entirely on defining what state the blockchain tracks, what transactions are valid, and how transactions change state.

### Responsibilities

Cosmos SDK applications define transaction and message formats using Protocol Buffers for serialization, validate transactions by checking signatures and fees, execute message handlers to apply state transitions, maintain state across all modules, and produce the AppHash that cryptographically commits to the current state.

### Application Structure

A typical Cosmos SDK application consists of **BaseApp** (providing the ABCI implementation and execution framework), **Modules** (containing domain-specific logic like bank, staking, and governance), **Keepers** (providing interfaces for accessing module state while enforcing access control), and **app.go** (serving as the composition root that wires everything together).

SDK v0.53 supports both manual wiring in app.go and declarative runtime-based wiring via `runtime.AppBuilder`, which reduces boilerplate and provides clear dependency graphs. SDK v0.53 also uses Governance v1 by default, where proposals are submitted via `MsgSubmitProposal` containing executable messages.

## State, Storage, and Commitments

### Application State Model

Application state in the Cosmos SDK is a collection of key-value pairs. State is updated only during block execution (via FinalizeBlock), ensuring that state changes only occur when consensus is reached. All state changes are deterministic and replayable—executing the same block against the same initial state will always produce the same final state.

### KV Stores and Multistore

Each module owns a namespaced key-value store, isolating its data from other modules. The multistore combines all module stores into a single, unified state representation with height-based versioning for historical queries.

```text
+-----------------------------------------+
|           Multistore (Root)             |
|                                         |
|  +----------+  +----------+  +-----+    |
|  |  Bank    |  | Staking  |  | ... |    |
|  |  Store   |  |  Store   |  |     |    |
|  +----------+  +----------+  +-----+    |
|                                         |
+-----------------------------------------+
```

### Merkle Trees and Commitments

Application state is committed using Merkle tree structures. Each module store is organized as a Merkle tree, and the multistore root is a Merkle tree of module store roots. The AppHash is the root hash of this multistore structure, uniquely identifying a state version.

```text
                 AppHash (Root)
                      |
        +-------------+-------------+
        |                           |
    BankRoot                   StakingRoot
        |                           |
   +----+----+                 +----+----+
   |         |                 |         |
 Key1     Key2               Key3      Key4
```

CometBFT includes the AppHash in block headers, allowing anyone to verify state commitments. This is crucial for light clients, which can verify state without downloading all blocks.

## Modules and Application Logic

Modules are the building blocks of Cosmos SDK applications. Each module implements a specific domain of functionality—the bank module handles token transfers, the staking module manages validator delegation, the governance module implements on-chain proposals, and so on.

Modules define message types (the transactions users can submit), state schemas (what data the module stores), state transitions (how messages modify state), queries (allowing clients to read module state), and optional lifecycle hooks for tasks that run at block boundaries.

### Keepers

Keepers are the gatekeepers to module state. They provide the only interface for accessing a module's state, enforce access control between modules, and encapsulate all state transition logic. Modules interact through keeper interfaces rather than directly accessing each other's state, enforcing modularity and preventing tight coupling.

## BaseApp and app.go

BaseApp is the Cosmos SDK's standard implementation of the ABCI interface. It handles all ABCI method calls from CometBFT, routes messages to the appropriate module handlers, manages state versioning and caching, and enforces transaction execution semantics. Developers don't implement ABCI directly—they extend BaseApp and register their modules with it.

The `app.go` file is the composition root of a Cosmos SDK application. This is where a specific blockchain is assembled from SDK components by creating the BaseApp instance, instantiating all module keepers with their dependencies, registering store keys for each module's state, and wiring together block lifecycle hooks.

## Replication and Determinism

Understanding how state replicates across nodes is critical to understanding Cosmos SDK architecture. CometBFT does not replicate application state directly. Instead, it replicates blocks (ordered transactions) and consensus decisions (which blocks were committed). Each node then independently executes these blocks through their local application.

State consistency relies entirely on deterministic execution. CometBFT ensures all nodes have the same ordered blocks. Each node independently executes these blocks through their local Cosmos SDK application. Deterministic execution guarantees that identical inputs produce identical outputs. Nodes verify state agreement by comparing AppHash commitments—if execution were non-deterministic, nodes would compute different AppHashes and fail to reach consensus.

### Sources of Non-Determinism

Applications must avoid sources of non-determinism. For example, using local timestamps breaks determinism because different nodes execute at different wall-clock times (use block time instead). Floating-point arithmetic can produce different results on different hardware (use integer math instead). Random number generation without deterministic seeds produces different values on each node (use deterministic PRNGs seeded with block data). External API calls or network requests can return different results for different nodes (all necessary data must be included in transactions).

### AppHash as Proof of Agreement

The AppHash serves as cryptographic proof of state agreement. After executing a block, each node computes the AppHash from its local state. This AppHash is included in the next block header. Nodes with divergent state will produce different AppHashes. Validators will not sign blocks with incorrect AppHashes, preventing consensus on invalid states. This makes state disagreement detectable and ensures that consensus implies state agreement across all honest nodes.


## Communication Layers

Cosmos SDK blockchains use different communication mechanisms depending on the context.

### Node-to-Node Communication

Nodes communicate with each other using CometBFT's custom peer-to-peer gossip protocol. This handles transaction propagation across the network, block replication to all nodes, and consensus messages like votes and proposals. This communication is entirely within CometBFT and is application-agnostic.

### Consensus to Application Communication

CometBFT communicates with the Cosmos SDK application through ABCI using local function calls. This is in-process communication within the same daemon, not a network protocol. CometBFT invokes the application at key points in the block lifecycle, and the application returns execution results and state commitments.

### Client to Node Communication

Clients (wallets, explorers, and other external applications) interact with nodes through the Cosmos SDK's gRPC API, with HTTP/REST available via gRPC-Gateway. This external API allows clients to query application state and submit transactions for mempool inclusion. This communication is completely separate from consensus—clients never directly interact with CometBFT's consensus protocols.

## Summary

The architecture of a Cosmos SDK blockchain cleanly separates three concerns. CometBFT determines when blocks happen and which transactions they contain through its consensus mechanism. ABCI defines how and when the application is invoked as part of the block lifecycle. The Cosmos SDK defines what those transactions mean and how they change state deterministically.

This separation enables secure, application-specific blockchains where developers focus on state machine logic while CometBFT handles the complexities of consensus and networking. The modularity allows both layers to evolve independently, and the clean interfaces make the system easier to reason about, test, and audit.

## What's Next

Understanding the architecture provides the foundation for deeper topics. The [Transaction Lifecycle](/sdk/v0.53/learn/beginner/tx-lifecycle) page follows a transaction from submission through mempool admission, consensus, and execution. The [Application Anatomy](/sdk/v0.53/learn/beginner/app-anatomy) page provides a deep dive into building a Cosmos SDK application, exploring modules, keepers, and the composition of app.go in detail.
