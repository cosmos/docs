---
title: Transaction Lifecycle
---

In the [Transactions, Messages, and Queries](/sdk/v0.53/learn/concepts/transactions) page, you learned that transactions are the actual mechanism that authorizes and executes logic on the chain. This page explains how transactions are validated, executed, and committed in the Cosmos SDK.

Before building with the Cosmos SDK, it's important to connect the high-level architecture from [SDK Application Architecture](/sdk/v0.53/learn/intro/sdk-app-architecture) with how blocks and transactions actually execute in code.

A Cosmos SDK application can be conceptually split into layers:

- **[CometBFT](/cometbft) (consensus engine)** — orders and proposes blocks
- **[ABCI](/sdk/v0.53/learn/intro/sdk-app-architecture#abci-application-blockchain-interface) (Application-Blockchain Interface)** — the protocol CometBFT uses to talk to the application
- **SDK application (BaseApp + modules)** — the deterministic state machine that executes transactions
- **Protobuf schemas** — define transactions, messages, state, and query types

This page maps the block and transaction lifecycle back to those layers.

## ABCI overview

**BaseApp** is a struct in the Cosmos SDK that implements the ABCI interface. {/* cosmos/cosmos-sdk baseapp/baseapp.go:63 */} Modules plug into BaseApp and execute logic during these phases.

```go title="ABCI Flow"
CometBFT
  ↓
ABCI: InitChain (once at genesis)

For each submitted transaction (async, independent of blocks):
  ↓
ABCI: CheckTx → Mempool

For every block:
  ↓
ABCI: FinalizeBlock
  → PreBlock
  → BeginBlock
  → Execute transactions
  → EndBlock
  ↓
ABCI: Commit
```

## InitChain (genesis only)

`InitChain` runs once when the chain starts for the first time. {/* cosmos/cosmos-sdk baseapp/abci.go:43 */} This involves loading a `genesis.json` file, which defines the chain's initial state (balances, validators, module parameters, and other bootstrapping data). Modules define genesis logic in their `module.go` file. Specifically, they implement the `InitGenesis` {/* cosmos/cosmos-sdk x/bank/module.go:152 */} and `ExportGenesis` {/* cosmos/cosmos-sdk x/bank/module.go:161 */} functions.

During this phase:

- BaseApp initializes stores and in-memory resources
- Modules load state from the genesis file via `InitGenesis` {/* cosmos/cosmos-sdk baseapp/abci.go:114 — InitChainer dispatches to each module's InitGenesis */}
- The initial validator set is established

Genesis runs before the first block begins.

## CheckTx and the mempool

Before a transaction can enter a block, it goes through `CheckTx`:

```
User
  ↓
Node
  ↓
ABCI: CheckTx
  ↓
Mempool
```

Transactions are sent as raw **protobuf-encoded bytes**.

{/* todo: link to encoding section above */}

During `CheckTx`, BaseApp decodes the transaction, verifies signatures and sequences, validates fees and gas, and performs basic message validation. {/* cosmos/cosmos-sdk baseapp/abci.go:375 — CheckTx calls RunTx, which orchestrates decode and ante handler execution */}

No state changes are committed during `CheckTx`. {/* cosmos/cosmos-sdk baseapp/baseapp.go:985 — message msCache.Write() is gated on execModeFinalize; messages don't execute in check mode (baseapp/baseapp.go:1017) */} If validation fails, the transaction is rejected. If it passes, it enters the mempool. The mempool is a node's in-memory pool of validated transactions waiting to be included in a block.

When a validator proposes a block, CometBFT selects transactions from the mempool, orders them, and reaches consensus on the block. Once the block is finalized, CometBFT sends it to the application via `FinalizeBlock`.

## FinalizeBlock

CometBFT calls `FinalizeBlock` once per block. {/* cosmos/cosmos-sdk baseapp/abci.go:943 */} Inside `FinalizeBlock`, BaseApp runs these phases in order: `PreBlock` → `BeginBlock` → transaction execution → `EndBlock`. {/* cosmos/cosmos-sdk baseapp/abci.go:766 — internalFinalizeBlock calls preBlock:835, beginBlock:842, executeTxsWithExecutor:870, endBlock:899 */}

### PreBlock

PreBlock runs before BeginBlock and is generally used for logic that must affect consensus-critical state before the block begins, such as activating a chain upgrade {/* cosmos/cosmos-sdk x/upgrade/module.go:162 */} or modifying consensus parameters. Because these changes need to take effect before any block logic runs, they cannot happen inside BeginBlock. Modules implement this via the `PreBlock` function in `x/<module>/module.go`. {/* cosmos/cosmos-sdk x/upgrade/module.go:162 — PreBlock implementation in upgrade module */}

### BeginBlock

BeginBlock runs after PreBlock and handles per-block housekeeping that must happen before any transactions execute, regardless of what transactions are in the block. Common uses include minting inflation rewards, {/* cosmos/cosmos-sdk x/mint/module.go:157 */} distributing staking rewards, {/* cosmos/cosmos-sdk x/distribution/module.go:164 */} and resetting per-block state. Modules implement this via the `BeginBlock` function in `x/<module>/module.go`. {/* cosmos/cosmos-sdk x/mint/module.go:157 — BeginBlock implementation in mint module */}

### Transaction execution

After BeginBlock, BaseApp iterates over each transaction in the block and runs it through a fixed pipeline. {/* cosmos/cosmos-sdk baseapp/abci.go:870 — executeTxsWithExecutor processes all transactions after beginBlock */}

#### Step 1: AnteHandler

Configured in a Cosmos SDK chain's `app.go` file, the AnteHandler runs first for every transaction. {/* cosmos/cosmos-sdk baseapp/baseapp.go:899 */} It verifies the transaction's signature, {/* cosmos/cosmos-sdk x/auth/ante/sigverify.go:400 */} increments the sequence number, {/* cosmos/cosmos-sdk x/auth/ante/sigverify.go:537 */} deducts the fee, {/* cosmos/cosmos-sdk x/auth/ante/fee.go:111 */} and meters the gas. {/* cosmos/cosmos-sdk x/auth/ante/sigverify.go:177 */}

If the AnteHandler fails, the transaction aborts and its messages do not execute. {/* cosmos/cosmos-sdk baseapp/baseapp.go:924 — returns error before reaching runMsgs if ante fails */}

#### Step 2: Message routing and execution

Each message in the transaction is routed to its module handler. Messages are module-specific and defined in the `proto/cosmos/<module>/v1beta1/tx.proto` file. BaseApp routes these messages to handlers in `x/<module>/keeper/msg_server.go`. {/* cosmos/cosmos-sdk x/bank/keeper/msg_server.go:29 — MsgSend handler as representative example */}

The message handler contains the execution logic for that message type. It validates the message content, applies business rules, and updates state. State is read and written through the module's **keeper**, which is the object that owns exclusive access to the module's KV store. For example, when `x/bank` processes a `MsgSend`, the message handler calls the bank keeper to debit the sender {/* cosmos/cosmos-sdk x/bank/keeper/send.go:240 — subUnlockedCoins debits fromAddr */} and credit the recipient. {/* cosmos/cosmos-sdk x/bank/keeper/send.go:245 — addCoins credits toAddr */}

Messages execute sequentially in the order they appear in the transaction. {/* cosmos/cosmos-sdk baseapp/baseapp.go:1016 */}

#### Step 3: Atomicity

Transactions are atomic — all messages succeed or none are committed: {/* cosmos/cosmos-sdk baseapp/baseapp.go:989 — msCache.Write() only called when err == nil and mode == execModeFinalize */}

```
Tx
  ├─ Msg 1
  ├─ Msg 2
  └─ Msg 3
```

If any message fails, all state changes from that transaction are discarded and the transaction returns an error. Thenext transaction in the block still executes. BaseApp uses cached stores internally to implement this. {/* cosmos/cosmos-sdk baseapp/baseapp.go:664 — cacheTxContext creates a branched CacheMultiStore per transaction */}

### EndBlock

EndBlock runs after all transactions in the block have executed. {/* cosmos/cosmos-sdk baseapp/abci.go:899 */} It is used for logic that depends on the block's cumulative state, like tallying governance votes after all vote transactions have been processed, or recalculating validator power after all delegation changes in the block. {/* cosmos/cosmos-sdk x/staking/module.go:181 */} Modules implement this via the `EndBlock` function in `x/<module>/module.go`. {/* cosmos/cosmos-sdk x/staking/module.go:181 — EndBlock implementation in staking module */}

## Commit

After `FinalizeBlock` returns, CometBFT calls `Commit`. {/* cosmos/cosmos-sdk baseapp/abci.go:1044 */} This persists the state changes to the node's local disk. {/* cosmos/cosmos-sdk baseapp/abci.go:1062 — cms.Commit() writes all KV stores to disk */} All validators must compute the same app hash. If they do not, consensus halts.

## Deterministic execution

Across all validators, the block execution is deterministic. Blocks must contain the same ordered transactions, and transactions must use canonical protobuf binary encoding. State transitions must be deterministic, which ensures that every validator computes the same app hash during `FinalizeBlock`, {/* cosmos/cosmos-sdk baseapp/abci.go:1013 — res.AppHash = app.workingHash() set on ResponseFinalizeBlock, not ResponseCommit */} which guarantees consensus safety. This is critical for the safety and liveness of the consensus protocol.

## Complete lifecycle overview

```
CometBFT
  ↓ ABCI InitChain
BaseApp → x/<module>/InitGenesis

For each submitted transaction (async):
  ↓ ABCI CheckTx
    → decode, verify, validate
    → insert into mempool

For every block:
  ↓ ABCI FinalizeBlock
    → PreBlock
    → x/<module>/BeginBlock
    For each tx (in the block):
      → AnteHandler
      → Message routing
      → Message execution (atomic)
    → x/<module>/EndBlock
  ↓ ABCI Commit
BaseApp commits KVStores
```

<Note>
The hooks that run at each phase — the AnteHandler, BeginBlocker, EndBlocker, and InitChainer — are registered in your chain's `app.go` before any block executes. `app.go` is the configuration layer that wires modules into BaseApp. Both are covered in detail in later sections.
{/* todo: add links to app.go and BaseApp sections */}
</Note>

CometBFT drives block processing through ABCI. BaseApp implements ABCI and orchestrates execution.

- Transactions are validated in `CheckTx` before entering the mempool
- Each block is executed inside a single `FinalizeBlock` call
- Within `FinalizeBlock`: PreBlock → BeginBlock → transactions → EndBlock
- Each transaction runs through AnteHandler → message routing → message execution
- Transactions are atomic: all messages commit or none do
- `FinalizeBlock` computes and returns the app hash; `Commit` persists state to disk

Protobuf ensures canonical encoding so all validators interpret transactions identically.

