---
title: Intro to Modules
---

In the previous section, you saw how blocks and transactions are processed. But where does the actual application logic of a blockchain live?

In the Cosmos SDK, **modules** define that logic.

Modules are the fundamental building blocks of a Cosmos SDK application. Each module encapsulates a specific piece of functionality, such as accounts, token transfers, validator management, governance, or any custom logic you define.

## Why modules exist

A blockchain application needs to manage many independent concerns (accounts, balances, validator management, etc). Instead of placing all logic in a single monolithic state machine, the Cosmos SDK divides the application into modules. The SDK provides a base layer that for these modules to operate together as a cohesive blockchain.

Each module owns a slice of state, defines its messages and queries, implements its business rules, and hooks into the block lifecycle and genesis as needed. This keeps the application organized, composable, and easier to reason about. It also separates safety concerns between modules, creating a more secure system.

## What a module defines

A module is a self-contained unit of state and logic.

At a high level, a module defines:

- state: a kv store namespace that contains the module's data
- messages: the actions the module allows
- queries: read-only access to the module's state
- message server: validates, applies business logic, and delegates to the keeper
- keeper: the state access layer — the only sanctioned path to the store

### State

Each module owns its own part of the blockchain state. For example:

- The `x/auth` module stores account metadata.
- The `x/bank` module stores account balances.

Modules do not share storage directly. Each module has its own key-value store namespace located in a `multistore`. For example, the bank module's store might contain entries like:

```
// x/bank store (conceptual)
balances | cosmos1abc...xyz | uatom  →  1000000
balances | cosmos1def...uvw | uatom  →   500000
```

The key encodes the namespace, address, and denomination. The value is the encoded amount. No other module can read or write these entries directly, only the [bank keeper](#keeper) can.


### Messages

As you learned in the [Transactions, Messages, and Queries](/sdk/v0.53/learn/concepts/transactions) section, each module defines the actions it allows via messages (`sdk.Msg`).

Messages are defined in the module’s `tx.proto` file and implemented by that module’s `MsgServer`. Here is a simplified example of a message definition from the bank module:

```
message MsgSend {
  string from_address = 1;
  string to_address   = 2;
  repeated cosmos.base.v1beta1.Coin amount = 3;
}
```

This message represents a request to transfer tokens from one account to another.  
When included in a transaction and executed:

1. The sender’s balance is checked.  
2. The amount is deducted from `from_address`.  
3. The amount is credited to `to_address`.  

When a transaction is executed, the SDK's `BaseApp` struct routes each message to the module that defines it.


### Queries

Modules expose read-only access to their state through query services, defined in `query.proto`. Queries do not modify state and do not go through block execution. For example:

```
// query.proto
rpc Balance(QueryBalanceRequest) returns (QueryBalanceResponse);
```

A caller provides an address and denomination; the query reads the balance from the keeper and returns it without modifying state.

### Business logic

While messages defines the intent, the `MsgServer` and `Keeper` implement the business logic to execute that intent and apply it to the module's state.

Business logic is split across two layers:

- The **`MsgServer`** handles the "What should happen" logic: it validates inputs, checks authorization. Then, it applies the business logic. Once satisfied, it delegates to the keeper. 
- The **`Keeper`** handles the "make it happen" part: it is the only sanctioned path to the module’s store and executes the actual reads and writes. It trusts that the caller has already validated the request.

### Message execution (`MsgServer`)

Each module implements a **MsgServer**, which is invoked by `BaseApp`’s message router when a message is routed to that module. The `MsgServer` checks that the signer is authorized, validates the message, applies business rules, then calls the keeper to read or write state. It emits events and returns a response. The following is a simplified example from the counter module’s `Add` handler:

```go
func (m msgServer) Add(ctx context.Context, request *types.MsgAddRequest) (*types.MsgAddResponse, error) {
    if request.GetAdd() >= math.MaxUint64 {
        return nil, ErrNumTooLarge
    }

    params, err := m.GetParams(ctx)
    if err != nil {
        return nil, err
    }

    if params.MaxAddValue > 0 && request.GetAdd() > params.MaxAddValue {
        return nil, ErrExceedsMaxAdd
    }

    count, err := m.counter.Get(ctx)
    if err != nil && !errors.Is(err, collections.ErrNotFound) {
        return nil, err
    }

    newCount := count + request.GetAdd()

    if err = m.counter.Set(ctx, newCount); err != nil {
        return nil, err
    }

    return &types.MsgAddResponse{UpdatedCount: newCount}, nil
}
```

## Keeper

A **keeper** is a Go struct that holds a reference to the module’s KV store and provides typed methods for reading and writing state. It is the only sanctioned way to access a module’s state; no code touches the store directly. For example, the counter keeper:

```go
type Keeper struct {
    Schema     collections.Schema
    counter    collections.Item[uint64]
    params     collections.Item[types.Params]
    bankKeeper types.BankKeeper

    // authority is the address capable of executing a MsgUpdateParams message.
    // Typically, this should be the x/gov module account.
    authority string
}

func (k *Keeper) GetParams(ctx context.Context) (types.Params, error) {
    return k.params.Get(ctx)
}
```

The keeper does not perform authorization checks; that responsibility belongs to the `MsgServer`. The `MsgServer` and `QueryServer` both embed the keeper and call its methods. 

Some messages, like `MsgUpdateParams`, are privileged and may only be executed by a specific address. The `authority` field in the keeper stores that address (typically the governance module account).

### Inter-module access

Modules are isolated by default. Each module owns its state, and direct access to that state is restricted through the module’s keeper. Other modules cannot arbitrarily mutate another module’s storage.

Instead, modules interact through explicitly defined keeper interfaces.

For example:

- The validator module calls methods on the bank keeper to transfer tokens.
- The governance module calls parameter update methods on other modules.

Each module defines an `expected_keepers.go` file that declares the interfaces it requires from other modules. This makes cross-module dependencies explicit: a module can only call methods the other module has chosen to expose.

This design keeps dependencies auditable and prevents accidental or unsafe cross-module state mutation.


### Block hooks

Modules may execute logic at specific points in the block lifecycle by implementing optional hook interfaces:

- `HasBeginBlocker` — runs logic at the start of each block
- `HasEndBlocker` — runs logic at the end of each block
- `HasPreBlocker` — runs logic before BeginBlock, used for consensus parameter changes

Modules only implement the hooks they need. Most modules implement none. These hooks are invoked during block execution, as described in the lifecycle section.

### Genesis initialization

Modules define how their state is initialized when the chain starts.

Each module implements:

- `DefaultGenesis`  
- `ValidateGenesis`  
- `InitGenesis`  
- `ExportGenesis`  

During `InitChain`, BaseApp calls each module’s `InitGenesis` to populate its state from `genesis.json`.


## Built-in and custom modules

The Cosmos SDK provides many built-in modules, including:

- `x/auth`
- `x/bank`
- `x/gov`
- `x/distribution`

Applications can include any subset of these modules and can define entirely new custom modules.

A Cosmos SDK blockchain is ultimately a collection of modules assembled into a single application. This customization of modules and application logic down to the lowest levels of a chain is what makes the Cosmos sdk so flexible and powerful.

## Anatomy of a module (high-level)

Modules live under the `x/` directory of an SDK application:

```
x/
├── auth/        # Accounts and authentication
├── bank/        # Token balances and transfers
├── poa/         # Proof-of-authority validator management
├── gov/         # Governance system
└── mymodule/    # Your custom module
```

Each subdirectory under `x/` is a self-contained module.  
An application composes multiple modules together to form a complete blockchain.

---

Inside a module, you will typically see a structure like this:

```
x/mymodule/
├── keeper/
│   ├── keeper.go        # Keeper struct and state access methods
│   ├── msg_server.go    # MsgServer implementation
│   └── query_server.go  # QueryServer implementation
├── types/
│   ├── expected_keepers.go  # Interfaces for other modules’ keepers
│   ├── keys.go              # Store key definitions
│   └── *.pb.go              # Generated from proto definitions
└── module.go            # AppModule implementation and hook registration
```

Proto files live separately at the repository root, not inside `x/`:

```
proto/myapp/mymodule/v1/
├── tx.proto       # Message definitions
├── query.proto    # Query service definitions
├── state.proto    # On-chain state types
└── genesis.proto  # Genesis state definition
```

- **`keeper/`**
  Contains the `Keeper` struct (state access) and implementations of the `MsgServer` and `QueryServer` interfaces.

- **`types/`**
  Defines the module’s public types: generated protobuf structs, store keys, and the `expected_keepers.go` interfaces that declare what this module needs from other modules.

- **`module.go`**
  Connects the module to the application and registers genesis handlers, block hooks, and message and query services.

- **`.proto` files**
  Define messages, queries, state schemas, and genesis state. Go code is generated from these files and used throughout the module.

## Modules in context

Putting everything together:

- **Accounts** authorize transactions.  
- **Transactions** carry messages.  
- **Blocks** determine when execution happens.  
- **Modules** define what execution means.  
- **MsgServer** executes state transitions.  
- **Keeper** manages storage.  
- **State** records the result.  

```
Transaction
   ↓
Message
   ↓
Module
   ↓
MsgServer
   ↓
Keeper
   ↓
State
```

Modules are where the blockchain’s rules live.

In the next section, you will look more closely at how module state is stored, how genesis initializes it, and how the application commits deterministic state transitions.